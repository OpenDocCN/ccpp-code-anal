# Nmap源码解析 67

# `libpcap/scanner.c`

这段代码是一个C语言代码，定义了一个名为“scanner.c”的文件。这段代码的作用是包含一个名为“config.h”的配置文件，如果该文件存在，则需要包括在源代码中。

具体来说，如果计算机上安装了AIX操作系统，同时定义了“__LARGE_FILE_API”，那么就需要包含这个文件。这是AIX系统的一个特性。

此外，这段代码还包含一些关于Flex扫描器和Windows编译器的信息。Flex是一个类库，用于生成FoxBang扫频器，而Windows编译器可能不支持所有C语言特性，因此需要通过其他途径获取对<inttypes.h>的定义。为了避免编译器警告，这段代码还包含一个名为“pcap-inttypes.h”的文件，该文件可能包含MSVC定义的inttypes.h。


```cpp
#line 2 "scanner.c"
/* Must come first for _LARGE_FILE_API on AIX. */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/*
 * Must come first to avoid warnings on Windows.
 *
 * Flex-generated scanners may only include <inttypes.h> if __STDC_VERSION__
 * is defined with a value >= 199901, meaning "full C99", and MSVC may not
 * define it with that value, because it isn't 100% C99-compliant, even
 * though it has an <inttypes.h> capable of defining everything the Flex
 * scanner needs.
 *
 * We, however, will include it if we know we have an MSVC version that has
 * it; this means that we may define the INTn_MAX and UINTn_MAX values in
 * scanner.c, and then include <stdint.h>, which may define them differently
 * (same value, but different string of characters), causing compiler warnings.
 *
 * If we include it here, and they're defined, that'll prevent scanner.c
 * from defining them.  So we include <pcap/pcap-inttypes.h>, to get
 * <inttypes.h> if we have it.
 */
```

这段代码是一个网络应用程序，它包括两个头文件：pcap-inttypes.h 和 grammar.h。pcap-inttypes.h 是用宏定义的方式定义了一些整型变量，而 grammar.h 是包含了一些头文件（包括 gencode.h 和 diag-control.h）以及一个定义YY_INT_ALIGNED类型的变量。

另外，定义了一个常量YY_INT_ALIGNED，它的值为short int类型。

接下来在 diag-control.c 中，可能是在初始化一些头文件，并定义了一些常量和变量。


```cpp
#include <pcap/pcap-inttypes.h>

/*
 * grammar.h requires gencode.h and sometimes breaks in a polluted namespace
 * (see ftmacros.h), so include it early.
 */
#include "gencode.h"
#include "grammar.h"

#include "diag-control.h"

#line 37 "scanner.c"

#define  YY_INT_ALIGNED short int

```



这段代码是一个C语言编译器扩展，由Flex生成。定义了一系列宏，用于定义编译器的版本信息和语言定义。其中，YY_FLEX_MAJOR_VERSION表示Flex Major版本，YY_FLEX_MINOR_VERSION表示Flex Minor版本，YY_FLEX_SUBMINOR_VERSION表示Flex Subminor版本。如果当前安装的Flex版本不满足SUBMINOR_VERSION大于0的条件，则定义FLEX_BETA。

接下来定义了一些标准C头文件包含的内容，包括printf函数。然后开始处理与平台或编译器相关的问题，如YY_FLEX_SUBMINOR_VERSION大于0时定义FLEX_BETA。最后，定义了一些与编译器版本相关的预处理指令。


```cpp
/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 0
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
```

这段代码的作用是包含了一个头文件（标准输入输出库头文件），该头文件包含了一个名为__STDC_LIMIT_MACROS的函数，它会在定义时检查(__STDC_VERSION__)的值是否大于或等于199901L。如果大于或等于199901L，则会包含这个函数。这个函数的作用是在定义整数变量时，限制整数变量的值域，确保不会超出定义的值域。这个函数通过引入了一个头文件stdint.h来实现。


```cpp
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
```

这段代码定义了一系列别名，用于在不同的头文件中统一使用某些类型的整数。这些头文件可以在其他源文件中定义，而无需在每个源文件中重新定义。具体的，定义了一系列被命名为flex_intXX_t的类型，分别对应于int8_t，uint8_t，int16_t和uint16_t。接下来，定义了一系列被命名为flex_intXX_t的别名，分别对应于 signed char，short和 int32_t。这些别名使得在这些头文件中定义这些类型时，不需要在每处显式地定义这些别名。


```cpp
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
```

这段代码定义了三个名为flex_uint8_t、flex_uint16_t和flex_uint32_t的变量，它们的类型为无符号整数(flex_uint)。这些变量可以表示的范围如下：

- flex_uint8_t：表示8位无符号整数的最大值是255(0xFFFF)，最小值是-128(0xFFFF)。
- flex_uint16_t：表示16位无符号整数的最大值是65535(0xFFFFF)，最小值是-32767(0xFFFF)。
- flex_uint32_t：表示32位无符号整数的最大值是4294967295(0xFFFFFF)，最小值是-2147483647(0xFFFFFF)。

这三个人称的变量是为了定义某些整数类型的极限而定义的。使用这些变量，可以确保在定义整数变量时，始终知道该变量最大可以表示为多少，以及最小必须是多少。


```cpp
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
```

这段代码是一个C语言中的预处理指令，用于定义各种数据类型的最大值。这里定义了8个整型数据类型的最大值，以及一个无符号整型数据类型的最大值。

具体来说，这段代码定义了以下数据类型的最大值：

- INT8_MAX：8位整型的最大值是127。
- INT16_MAX：16位整型的最大值是32767。
- INT32_MAX：32位整型的最大值是2147483647。
- UINT8_MAX：8位无符号整型的最大值是255。
- UINT16_MAX：16位无符号整型的最大值是65535。
- UINT32_MAX：32位无符号整型的最大值没有定义，但是可以使用#define INT32_MAX "2147483647"来定义。


```cpp
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
```

这段代码的作用是定义了一些宏，主要是与C语言相关的一些定义。下面是一些简要的解释：

1. `#define UINT32_MAX`：这是一个定义，定义了一个名为`UIDX_MAX`的宏，它的值为`4294967295U`。`UINT32_MAX`是`unsigned int`（无符号32位整数）的最大值。

2. `#ifdef __cplusplus`：这是一个条件编译指令，判断当前编译器是否支持`__cplusplus`定义的特性。如果支持，那么下面的代码会执行。

3. `#include <stdio.h>`：这是一个引入`stdio.h`头文件的指令，用于在当前文件中输出信息。

4. `#include <cstdint>`：这是一个引入`cstdint`头文件的指令，用于在当前文件中使用`const`、`volatile`等存储类修饰符。

5. `#include <math.h>`：这是一个引入`math.h`头文件的指令，用于在当前文件中使用数学函数。

6. `#include <signal.h>`：这是一个引入`signal.h`头文件的指令，用于在当前文件中使用`signal.h`标准库头文件。

7. `#include <stdbool.h>`：这是一个引入`stdbool.h`头文件的指令，用于在当前文件中使用`bool`类型。

8. `#define YY_USE_CONST`：这是一个定义，定义了一个名为`YYY_USE_CONST`的符号，其值为`1`。这意味着`YYY_USE_CONST`将被用来编译或运行计算机程序。

9. `#elif defined(__STDC__)`：这是一个条件编译指令，判断当前的编译器是否支持`__STDC__`定义的特性。如果支持，那么将下面的代码编译为`const`修饰符。

10. `#define XX_MAX (YYY_USE_CONST * 2)`：这是一个定义，定义了一个名为`XX_MAX`的宏，它的值为`YYY_USE_CONST * 2`。这个宏将在`YYY_USE_CONST`为`1`时编译为`const`，否则编译为普通文本。


```cpp
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
```

这段代码是一个C语言的预处理指令，主要作用是定义了一些符号常量，以及对预处理说明文件的包含条件进行判断。

具体来说，代码中的以下语句会在编译时执行：

1. `#if defined (__STDC__)`：如果当前源文件是C语言标准库定义的文件，则定义了`__STDC__`这个符号常量。

2. `#define YY_USE_CONST`：定义了一个名为`YYY_USE_CONST`的符号常量，其值为1。

3. `#ifdef YY_USE_CONST`：对`YYY_USE_CONST`进行定义，如果当前源文件是C语言标准库定义的文件，则定义了`const`类型的符号常量。否则不定义。

4. `#endif`：处理完符号常量定义后，添加了两个`#ifdef`和两个`#ifndef`。

5. `#define YY_NULL 0`：定义了一个名为`YYY_NULL`的符号常量，其值为0。

6. `#define YY_USE_CONST`：定义了一个名为`YYY_USE_CONST`的符号常量，其值为1。

7. `#ifdef YY_USE_CONST`：对`YYY_USE_CONST`进行定义，如果当前源文件是C语言标准库定义的文件，则定义了`const`类型的符号常量。否则不定义。

8. `#endif`：处理完符号常量定义后，添加了两个`#ifdef`和两个`#ifndef`。

9. `#define YY_NULL 0`：定义了一个名为`YYY_NULL`的符号常量，其值为0。

最终，这段代码定义了一些符号常量，包括`YYY_USE_CONST`、`YYY_NULL`和`YYY_USE_CONST`。通过这些符号常量的定义，可以对程序进行更严格的控制。


```cpp
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

```

这段代码定义了一个名为YY_SC_TO_UI的宏，该宏将一个可能是负数也可能是符号的单目变量（单个char类型）转换为可能的负数，也可能是符号的8位无符号整数，以便作为数组的索引。

具体来说，如果输入的单目变量是负数，则将其转换为8位无符号整数并将其作为索引，而不是将其作为负数对待。这是通过将单目变量强制转换为无符号整数类型，然后将其转换为8位无符号整数类型来实现的。

此外，还定义了一个名为YY_TYPEDEF_YY_SCANNER_T的宏，其表示一个指向YY_SCANNER结构的指针类型。YY_SCANNER是一个自定义的扫描器，用于从输入流中读取YY序列，如YY_SPELL、YY_FILE等。

最后，定义了一些辅助定义，包括YY_SC_TO_UI函数的实现，YY_SCANNER_PTR指针类型定义等。


```cpp
/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
```

这段代码定义了一系列宏，它们都是 "YYIN"、"YYOUT"、"YYEXTRA"、"YYLENG" 和 "YYTEXT" 的别称。这些宏的作用是将 "YY_CURRENT_BUFFER_LVALUE" 变量中的相应的值复制到 "yyin"、"yyout"、"yyextra" 和 "yytext" 变量中，以便在代码中更方便地引用这些值。

宏的作用是通过定义别名来自动给 "YY_CURRENT_BUFFER_LVALUE" 变量添加前缀 "yy_"。这个前缀将在复制时传递给 "yyin"、"yyout"、"yyextra" 和 "yytext" 变量。

该代码的另一个作用是将 "YY_CURRENT_BUFFER_LVALUE" 中的 "yy_bs_lineno" 和 "yy_bs_column" 变量复制到 "yyylink" 和 "yy歌词本" 变量中，以便在代码中更方便地引用这些值。

该代码的最后一个定义 "YY_CURRENT_BUFFER_LVALUE" 中的 "yy_flex_debug" 变量，这个变量的作用是复制 "YY_CURRENT_BUFFER_LVALUE" 中的 "yy_flex_debug_r" 变量，以便在代码中更方便地引用这些值。


```cpp
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *

```

这段代码定义了一些常量和常量，然后定义了一些函数，最后定义了一些常量。

定义的函数有：

- YYSTART：将YYG指针中的当前开始状态转换为可以 later handed to BEGIN的值。
- YYSTATE：使用YYG指针中的YYSTART常量，定义YYSTATE为YY_START。
- YY_STATE_EOF：使用YYG指针中的YYEND_OF_BUFFER常量，定义YY_STATE_EOF为YY_END_OF_BUFFER+state+1。
- YYNEW_FILE：定义了一个名为YYNEW_FILE的函数，它的参数为yyin和yyscanner，表示开始处理一个新的文件。
- YYEND_OF_BUFFER_CHAR：定义了一个名为YYEND_OF_BUFFER_CHAR的常量，表示YYEND_OF_BUFFER字符的ASCII码。

YYG指针中的YYSTART常量表示输入文本文件中的起始行，YYEND_OF_BUFFER常量表示输入文本文件中的结束行，YYEND_OF_BUFFER_CHAR常量表示结束行字符的ASCII码。YYNEW_FILE函数用于处理YYG指针中表示的输入文本文件，YYEND_OF_BUFFER_CHAR常量用于指示YYNEW_FILE函数在YYG指针中YYEND_OF_BUFFER字符的ASCII码处结束。


```cpp
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE pcap_restart(yyin ,yyscanner )

#define YY_END_OF_BUFFER_CHAR 0

```

这段代码定义了一个默认输入缓冲区的大小（YYY_BUF_SIZE）。

首先，在#elif #语句块内，我们检查当前处理器架构（IA-64）是否为当前输入缓冲区的大小（YYY_BUF_SIZE）的2倍（YYY_READ_BUF_SIZE）。如果是，则我们将YYY_BUF_SIZE设置为16k，如果不是，则将YYY_BUF_SIZE设置为8k。这种情况下，YYY_BUF_SIZE是固定的，不会因为输入缓冲区的不同而改变。

接下来，我们定义了一个宏（#define）来定义YYY_BUF_SIZE，这个宏将在编译时被替换为具体的数字。这个宏的实现方式是：如果当前处理器架构（IA-64）支持__ia64__，则将YYY_BUF_SIZE设置为16k；否则，将YYY_BUF_SIZE设置为8k。


```cpp
/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
```



这段代码定义了一些宏，用于定义YY文本缓冲区的状态和类型定义。

YY_STATE_BUF_SIZE 是 YY 缓冲区状态 类型的缓冲区大小，它是由一个已定义的宏定义的，其计算方式是将 YY 缓冲区大小加上 2，然后乘以 sizeof(yy_state_type)。这个宏定义了缓冲区大小，因此它可以在编译时或其他时期进行修改，而不会影响程序的运行。

YY_BUFFER_STATE 是 yy 缓冲区状态 类型的别名，它是一个指向 struct yy_buffer_state 类型的指针。这个别名在定义时被定义为宏，因此它可以被用来代替使用 struct yy_buffer_state 来声明变量。

YY_BUFFER_SIZE_T 是 yy 缓冲区大小 的类型定义，它的定义使用了 YY 类型定义的语法，用于定义变量或函数参数。

EOB_ACT_CONTINUE_SCAN,EOB_ACT_END_OF_FILE 和 EOB_ACT_LAST_MATCH 是三个常量，它们定义了缓冲区操作中三个不同的结束状态。这些常量被定义为宏，因此它们也可以在程序的其他部分中被修改，而不需要修改源代码。


```cpp
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
```

这两行代码定义了两个宏，分别为 `yyless` 和 `unput`。

`yyless` 宏的作用是返回输入流中前 `n` 个匹配的字符，但不包括 `n`。具体实现包括以下几个步骤：

1. 定义一个整型变量 `yyless_macro_arg`，并将其设置为 `n`。
2. 通过调用 `YY_LESS_LINENO` 函数将 `yyless_macro_arg` 的值传递给 `YY_RESTORE_YY_MORE_OFFSET` 函数。
3. 将 `yy_cp` 指向要复制的字符，并将 `YY_RESTORE_YY_MORE_OFFSET` 中的 `yy_cp` 替换为 `yy_bp`。
4. 调用 `YY_DO_BEFORE_ACTION` 函数，使 `yytext` 重新设置。

如果 `yyless_macro_arg` 的值大于 `YY_MORE_ADJ`，那么 `YY_DO_BEFORE_ACTION` 函数会继续执行，否则宏将不再执行。

`unput` 宏的作用是将输入流中的字符 `c` 输出，并将输出指针 `yyyg->yytext_ptr` 和字符扫描器 `yscanner` 更新为 `c`。


```cpp
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = yyg->yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )

```

这段代码定义了一个名为`yy_buffer_state`的结构体，用于描述输入缓冲区的状态。这个结构体包含了一些与输入缓冲区相关的信息，如输入文件、输入缓冲区的大小、已读入的字符数量、是否是我们自己的输入缓冲区、是否是交互式输入源、是否在尝试填充缓冲区等。

这个结构体在`YY_STRUCT_YY_BUFFER_STATE`定义中声明，然后在`yy_buffer_state`定义中具体化。它的定义与`yy_input_file`、`yy_ch_buf`、`yy_buf_size`、`yy_n_chars`、`yy_is_our_buffer`、`yy_is_interactive`、`yy_at_bol`、`yy_bs_lineno`、`yy_bs_column`、`yy_fill_buffer`和`yy_buffer_status`等信息点一一对应。

这个结构体在`YY_BUFFER_API`中作为参数进行传递，用于实现对输入缓冲区的操作。


```cpp
#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

```

这段代码定义了两个宏：YY_BUFFER_NEW 和 YY_BUFFER_NORMAL。它们用于定义缓冲区的状态。

YY_BUFFER_NEW 表示当前缓冲区为等待输入状态，即EOF尚未出现，但仍然有一些文本需要处理。在这种情况下，我们不会尝试从输入源中读取更多数据，因为我们可能还有许多尚未匹配的词语。

YY_BUFFER_NORMAL 表示当前缓冲区为正常状态，即EOF已经出现，我们可以继续从输入源中读取数据。

此外，还定义了一个宏 YY_BUFFER_EOF_PENDING，它表示当前缓冲区为等待输入状态，即EOF尚未出现。

最后，定义了一个名为 yy_buffer 的结构体，其中包含了许多用于定义缓冲区状态的变量。


```cpp
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via pcap_restart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
```

这段代码定义了两个宏：YY_CURRENT_BUFFER 和 YY_BUFFER_POS。

YY_CURRENT_BUFFER macro定义了如何获取当前栈中缓冲器的访问状态。它通过询问栈顶（yyg->yy_buffer_stack_top）是否包含缓冲器，如果包含则返回该缓冲器，否则返回 NULL。

YYY_BUFFER_POS macro定义了如何获取栈顶缓冲器（如果存在），如果没有则返回 NULL。这个宏对于在需要更方便地访问缓冲器状态的场合使用，而不仅仅是在特定情境下使用。


```cpp
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
```

这段代码定义了一些用于pcap库的宏，包括YY_CURRENT_BUFFER_LVALUE，用于定义当前缓冲区的值，YY_FLUSH_BUFFER用于定义缓冲区中的数据是否已准备好被释放，YY_BUFFER_STATE用于定义缓冲区的状态，YY_BUFFER_CAPS、YY_BUFFER_SETTINGS和YY_BUFFER_SPACE用于定义缓冲区的缓冲区头信息。

pcap_restart函数用于在启动pcap抓包程序时初始化缓冲区，pcap__switch_to_buffer函数用于在程序中从文件中读取数据时，将数据读取到缓冲区中，pcap__create_buffer函数用于创建一个新的缓冲区并初始化缓冲区，pcap__delete_buffer函数用于释放一个已分配的缓冲区，pcap__flush_buffer函数用于向缓冲区中输出数据，pcap_push_buffer_state函数用于将当前缓冲区中的数据推入到输出缓冲区中，pcap_pop_buffer_state函数用于从输出缓冲区中弹出数据到当前缓冲区中，pcap_ensure_buffer_stack函数用于检查缓冲区栈是否已经到达栈顶，pcap__load_buffer_state函数用于将缓冲区中的数据加载到栈中，pcap__init_buffer函数用于初始化缓冲区。


```cpp
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void pcap_restart (FILE *input_file ,yyscan_t yyscanner );
void pcap__switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
YY_BUFFER_STATE pcap__create_buffer (FILE *file,int size ,yyscan_t yyscanner );
void pcap__delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
void pcap__flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
void pcap_push_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
void pcap_pop_buffer_state (yyscan_t yyscanner );

static void pcap_ensure_buffer_stack (yyscan_t yyscanner );
static void pcap__load_buffer_state (yyscan_t yyscanner );
static void pcap__init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );

#define YY_FLUSH_BUFFER pcap__flush_buffer(YY_CURRENT_BUFFER ,yyscanner)

```



该代码定义了三个函数：pcap__scan_buffer、pcap__scan_string和pcap__scan_bytes。

pcap__scan_buffer函数的作用是从给定的输入缓冲区中读取网络数据包。它将返回一个指向数据包开始头的指针。

pcap__scan_string函数的作用是将给定的输入字符串中的网络数据包读取到一个缓冲区中。它将返回一个指向数据包开始头的指针。

pcap__scan_bytes函数的作用是将给定的输入字节数组中的网络数据包读取到一个缓冲区中。它将返回一个指向数据包开始头的指针。

函数声明中定义了三个函数名，yy_new_buffer、yy_set_interactive和pcap_free。

yy_new_buffer函数的作用是创建一个新的输入缓冲区。它需要一个参数base和一个大小len，和一个YYSCANNER类型的参数yyscanner。

yy_set_interactive函数的作用是在YYSCANNER对象上设置is_interactive参数的值。它需要在YY_CURRENT_BUFFER为真时才能生效。

pcap_free函数的作用是释放给定缓冲区。它需要一个参数和一个YYSCANNER类型的参数yyscanner。

该代码的源代码如下：

```cpp
YY_BUFFER_STATE pcap__scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
YY_BUFFER_STATE pcap__scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
YY_BUFFER_STATE pcap__scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );

void *pcap_alloc (yy_size_t size,yyscan_t yyscanner );
void *pcap_realloc (void *buffer,yy_size_t size,yyscan_t yyscanner );
void pcap_free (void *buffer,yyscan_t yyscanner );

#define yy_new_buffer pcap__create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
       pcap_ensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
           pcap__create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
		} \
		YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	} \
	}
```


```cpp
YY_BUFFER_STATE pcap__scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
YY_BUFFER_STATE pcap__scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
YY_BUFFER_STATE pcap__scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );

void *pcap_alloc (yy_size_t ,yyscan_t yyscanner );
void *pcap_realloc (void *,yy_size_t ,yyscan_t yyscanner );
void pcap_free (void * ,yyscan_t yyscanner );

#define yy_new_buffer pcap__create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        pcap_ensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            pcap__create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

```



This code defines two macros, `yy_set_bol` and `YY_AT_BOL`, which are used to configure the input for a yy parser.

`yy_set_bol` takes an optional parameter `at_bol`, which is the atom type for the byte order of the input. The macro checks if a buffer is currently in use and, if not, creates one using `pcap_create_buffer` and assigns it to `YY_CURRENT_BUFFER`. It then sets the `yy_at_bol` field of the first available buffer in the stack to `at_bol`.

`YY_AT_BOL` returns the `yy_at_bol` field of the most recently allocated buffer in the stack.

The code also defines a macro `pcap_wrap`, which wraps the input according to the current byte order, meaning that it is optimized for readability and not swapped.


```cpp
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        pcap_ensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            pcap__create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define pcap_wrap(yyscanner) (/*CONSTCOND*/1)
```

这段代码定义了一系列宏和类型，起到以下作用：

1. 定义了一个名为YY_SKIP_YYWRAP的定义，表示在定义其他YY相关的符号时，不再输出 warnings。这个定义在后续代码中可能被用于某些库函数，以避免警告干扰代码的可读性。
2. 定义了一个名为YY_CHAR的类型，用于表示一个unsigned char类型的字符。
3. 定义了一个名为YY_STATE_TYPE的类型，用于表示YYtextState类型的枚举类型。YYtextState类型可能是用于解析输入文本的一种状态。
4. 定义了一个名为yytext_ptr的符号，用于表示一个YYtextState类型的指针，指向一个已经解析过的YYtextState类型的值。
5. 定义了一个名为yy_get_previous_state的函数，用于获取当前状态之前的YYtextState类型。
6. 定义了一个名为yy_try_NUL_trans的函数，用于尝试将一个NULL字符串转换为int类型。
7. 定义了一个名为yy_get_next_buffer的函数，用于获取下一个可以解析的字符数组位置。
8. 定义了一个名为yy_fatal_error的函数，用于在解析过程中出现严重错误时，输出错误信息并停止程序。

这段代码可能是一个用于解析输入文本的库函数，需要根据具体的YYtextState类型进行定义。比如，如果YYtextState类型定义为YYtextFinishedState，那么这个库函数可能负责将已经解析过的YYtextFinishedState类型的值返回给调用者。


```cpp
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
static int yy_get_next_buffer (yyscan_t yyscanner );
#if defined(__GNUC__) && __GNUC__ >= 3
__attribute__((__noreturn__))
#endif
static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );

```



这段代码是一个C语言的预处理指令，是对文本输入文件YY眩中的一种定义。预处理指令定义了两个宏定义YY_DO_BEFORE_ACTION和YY_DO_AFTER_ACTION。

YY_DO_BEFORE_ACTION定义了YY_DO_AFTER_ACTION宏之前的作用，即设置了YYtext变量为YY_BP到YY_CP之间的字符，将YY_HOLD_CHAR变量设置为当前正在读取的字符，将YY_CP指向字符串结束位置'\0'。

YY_DO_AFTER_ACTION定义了YY_DO_BEFORE_ACTION宏之后的作用，即在YY_DO_BEFORE_ACTION宏操作之前设置了YYtext变量为YY_BP到YY_CP之间的字符，将YY_HOLD_CHAR变量设置为当前正在读取的字符，将YY_CP指向字符串结束位置'\0'。

根据YY文本文件描述YY眩，这段代码的作用是定义了YY文本文件的输入规则，用于从文件中读取字符并设置YYtext变量。YY_DO_BEFORE_ACTION定义了YY_DO_AFTER_ACTION之前YY文本文件的读取规则，YY_DO_AFTER_ACTION定义了YY_DO_BEFORE_ACTION之后YY文本文件的读取规则。


```cpp
/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yyg->yytext_ptr = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	yyg->yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yyg->yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 188
#define YY_END_OF_BUFFER 189
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
```

This appears to be a CSS class selector with several properties, including the class name, which is `in-memory-optimizer`. The other properties are either the CSS properties or class names of the elements being selected.



```cpp
static yyconst flex_int16_t yy_accept[1785] =
    {   0,
        0,    0,  189,  187,  114,  114,  115,  187,  115,  115,
      124,  124,  115,  115,  115,  115,  185,  185,  187,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  115,
      118,  122,   67,    0,  185,  124,    0,  185,  185,  185,
        0,  126,  120,  117,  119,  116,  121,  185,  186,  185,
      185,  185,   20,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,    7,  185,   34,   35,

      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,   93,  185,   68,  185,  185,  185,
      185,  185,  185,   60,  185,  185,  185,  185,   87,  185,
      185,  185,  185,  185,  185,   61,  185,    4,  185,  185,
      185,  185,  185,  185,  185,   68,  122,  185,  125,  125,
      185,  124,  185,    0,  126,  124,  126,  126,  126,  185,
      185,  185,   67,    5,  185,   82,  185,  185,  185,  185,
      185,  185,  185,   55,  108,    1,    0,  185,   21,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,   36,  185,

      185,   18,   43,    0,  185,   29,  185,   25,   70,  185,
      185,   80,   37,  185,  101,  185,  185,  185,  185,  102,
      185,   46,   69,   83,  107,  185,   14,  185,    3,  185,
      185,  185,  185,  185,   95,  185,  185,   26,  185,  106,
      185,  109,   38,    2,  185,   42,  185,    9,  185,   10,
       90,  185,   89,  185,  185,    0,  185,  185,  125,  185,
      185,  185,  185,  124,    0,  185,    0,  127,  126,  126,
        0,  126,    0,  126,    0,  126,    0,   23,  185,  185,
      185,  185,   64,   16,   41,  185,   39,  185,  185,  185,
       30,  185,   99,  185,  185,  185,  112,  185,  185,  105,

      111,   45,  110,  113,   11,  185,  185,   12,   13,  185,
      185,  185,   32,   79,  185,   62,    3,  100,   47,  185,
      185,  185,   75,  185,  185,  185,  185,   48,  185,  185,
       40,  185,    6,  185,   94,  185,    8,   96,  185,  185,
        0,  185,   53,   74,   15,  185,  125,  125,  185,  125,
      125,  125,  185,  124,  185,    0,  126,  185,    0,    0,
      126,    0,  126,  127,  126,    0,    0,    0,    0,  126,
      126,  126,  126,  126,    0,  185,   56,   57,   58,   59,
      185,   22,  185,  185,  185,  185,   31,  185,  185,  185,
      103,  104,    0,   19,  185,  185,  185,  185,   88,  185,

       33,  185,   81,   28,   27,  185,  185,   84,  185,  185,
      185,   50,   17,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,    0,  185,  185,
      125,  185,  185,  185,  185,  125,  125,  185,  124,  185,
        0,    0,  126,  126,  126,    0,    0,  127,  126,  126,
      127,  126,    0,    0,  126,  126,  126,  126,  126,    0,
        0,    0,    0,  126,  126,    0,  126,    0,  126,    0,
       98,  185,  185,  185,   24,  185,  185,   78,  185,  185,
      185,  185,  185,  185,  185,  185,  185,    0,  185,  185,
      185,  185,  185,  185,   70,  185,  185,  185,  185,  185,

      185,  185,   76,   77,  185,   97,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      125,  125,  185,  125,  125,  125,  125,  185,  124,  185,
        0,  126,  126,    0,  126,    0,    0,  126,    0,  126,
      127,  126,    0,    0,    0,  126,  126,    0,  126,  127,
      126,    0,    0,    0,    0,    0,    0,    0,  126,  126,
      126,  126,  126,    0,  185,  185,  185,  185,   52,   63,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,   73,   71,  185,  185,   44,   85,

       86,  185,  185,  185,  185,   54,  181,  184,  183,  177,
      185,  179,  178,  182,  185,    0,  185,  185,  125,  185,
      185,  185,  125,  185,  124,  185,    0,    0,  126,  126,
      126,  126,  126,  126,    0,    0,  127,  126,  126,  126,
        0,    0,  126,  126,  126,  126,  126,    0,    0,    0,
        0,    0,    0,    0,  126,  126,  126,  126,  126,    0,
        0,    0,    0,    0,  126,  126,    0,  126,    0,  126,
        0,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  129,

      128,  185,  185,   72,  185,  185,  185,  180,  176,  185,
      185,  125,  125,  125,  125,  185,  124,  185,    0,  126,
      126,    0,  126,  126,    0,  126,    0,    0,  126,    0,
      126,  127,  126,    0,    0,    0,  126,  126,    0,  126,
      127,  126,    0,    0,    0,    0,    0,  126,  126,    0,
      126,  127,  126,    0,  126,  126,    0,    0,    0,    0,
        0,    0,    0,  126,  126,  126,  126,  126,    0,   65,
      185,   55,  134,  141,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  146,  145,  185,   66,

       49,  185,  185,    0,  185,  185,  185,  185,  185,  124,
      185,    0,    0,  126,  126,  126,  126,  126,  126,  126,
      126,  126,    0,    0,  127,  126,  126,  126,    0,    0,
      126,  126,  126,  126,  126,    0,    0,    0,    0,    0,
        0,    0,  126,  126,  126,  126,  126,    0,  126,  126,
        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,
      126,  126,    0,    0,    0,    0,    0,    0,  126,  126,
        0,  126,    0,  126,    0,   91,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  151,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,

      185,   51,  123,  123,  125,  125,  185,  124,  185,    0,
      126,  126,    0,  126,  126,    0,  126,  126,    0,  126,
        0,  123,  126,    0,  126,  127,  126,    0,    0,    0,
      126,  126,    0,  126,  127,  126,    0,    0,    0,    0,
        0,  126,  126,    0,  126,  127,  126,    0,    0,    0,
        0,    0,    0,  126,  126,    0,  126,  127,  126,    0,
      126,  126,  126,    0,    0,    0,    0,    0,    0,    0,
      126,  126,  126,  126,  126,    0,  185,  185,  185,  185,
      185,  185,  185,  185,  139,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,

       92,  123,  123,  125,  185,  123,  123,    0,    0,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,    0,  123,  127,  126,  126,  126,    0,    0,  126,
      126,  126,  126,  126,    0,    0,    0,    0,    0,    0,
        0,  126,  126,  126,  126,  126,    0,  126,  126,    0,
        0,    0,    0,    0,    0,    0,  126,  126,  126,  126,
      126,    0,  126,  126,  126,    0,    0,    0,    0,    0,
        0,    0,  126,  126,  126,  126,  126,    0,    0,    0,
        0,    0,    0,  126,  126,    0,  126,    0,  126,    0,
      185,  185,  185,  143,  185,  185,  185,  185,  185,  185,

      185,  131,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  125,  185,  124,    0,
      126,  126,    0,  126,  126,    0,  126,  126,    0,  126,
      126,    0,  126,    0,    0,    0,  126,    0,    0,  126,
      127,  126,    0,    0,    0,  126,  126,    0,  126,  127,
      126,    0,    0,    0,    0,    0,  126,  126,    0,  126,
      127,  126,    0,    0,    0,    0,    0,    0,  126,  126,
        0,  126,  127,  126,    0,    0,    0,    0,    0,    0,
      126,  126,    0,  126,  127,  126,    0,  126,  126,  126,
        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,

      126,  126,    0,  185,  185,  185,  185,  133,  185,  185,
      185,  137,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  123,
        0,    0,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,    0,    0,    0,
      127,    0,    0,  126,    0,    0,  126,  126,  126,    0,
        0,    0,    0,    0,    0,    0,  126,  126,  126,    0,
      126,  126,    0,    0,    0,    0,    0,    0,    0,  126,
      126,  126,    0,  126,  126,  126,    0,    0,    0,    0,
        0,    0,    0,  126,  126,  126,    0,  126,  126,  126,

        0,    0,    0,    0,    0,    0,    0,  126,  126,  126,
        0,    0,    0,    0,    0,    0,  126,  126,    0,  126,
        0,  126,    0,  130,  142,  144,  138,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  160,  185,  185,  185,  185,    0,    0,  126,
        0,  126,    0,  126,  126,    0,  126,  126,    0,  126,
      126,    0,  126,  126,    0,  126,    0,    0,    0,    0,
      126,  126,    0,  126,    0,    0,  126,  126,  126,    0,
        0,    0,    0,  126,  126,  126,    0,    0,    0,    0,
        0,  126,  126,  126,    0,    0,    0,    0,    0,  126,

      126,  126,    0,    0,    0,    0,    0,  126,  126,  126,
      126,  126,  126,    0,    0,    0,    0,    0,    0,    0,
      126,  126,  126,    0,  185,  185,  185,  185,  185,  185,
      185,  152,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,    0,    0,    0,  126,  126,
      126,  126,  126,  126,    0,    0,    0,    0,  126,  126,
        0,    0,    0,    0,  126,  126,  126,    0,    0,    0,
        0,    0,  126,  126,  126,  126,    0,    0,    0,    0,
        0,  126,  126,  126,  126,    0,    0,    0,    0,    0,
      126,  126,  126,  126,    0,    0,    0,    0,    0,  126,

        0,    0,    0,    0,    0,  126,  126,  126,  185,  185,
      185,  140,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  126,
      126,  126,  126,  126,  126,  126,  126,    0,    0,    0,
        0,  126,  126,    0,    0,  126,    0,    0,    0,  126,
        0,    0,    0,  126,    0,    0,    0,  126,    0,    0,
        0,  126,  126,  126,  126,    0,    0,    0,    0,    0,
      126,  135,  185,  132,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  161,  185,
      185,  126,    0,    0,  126,  126,    0,  126,  126,  126,

        0,  126,  126,  126,    0,  126,  126,  126,    0,  126,
      126,  126,    0,    0,    0,    0,  126,  136,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  148,
      185,  157,  185,  149,  126,  126,    0,    0,    0,    0,
        0,    0,  126,  126,  126,    0,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  156,
        0,  126,  126,  126,  126,  126,    0,  172,  185,  185,
      185,  185,  185,  185,  185,  185,  159,  185,  185,  185,
      126,  126,  171,  185,  185,  185,  185,  185,  185,  185,
      158,  185,  185,  185,  185,  185,  185,  185,  185,  185,

      185,  185,  185,  185,  150,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  147,  185,  185,  170,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  169,  185,  185,  185,  185,  185,  175,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  162,
      185,  185,  185,  185,  185,  155,  185,  185,  173,  185,
      185,  185,  185,  185,  185,  153,  185,  174,  185,  168,
      185,  185,  185,  185,  163,  185,  165,  185,  185,  167,
      164,  154,  166,    0
    } ;

```

This appears to be a simple CSS class selector with some default styles and some position: fixed; style properties.

The selector is applied to all elements with the tag "video" (with some breaking for other HTML elements). The CSS properties defined in the selector will be applied to those elements, with the values of the properties specified in the angle brackets being overridden by any local styles.

The "position: fixed"; property centers the video element horizontally and vertically within its parent container, ensuring that the video stays in its original position even when the page is scrolled.

The "z-index: 999"; property sets the video layer's z-index to 999, ensuring that it appears on top of other layers even when the page is scrolled.

Note: The z-index value is usually set to a negative number for a层叠效果. A higher z-index value means that the layer will appear on top of others when the page is scrolled. A lower z-index value means that the layer will appear on top of others when the page is scrolled, but the layer will be pushed further back into the page when the user interacts with the page (e.g., clicking on the background).


```cpp
static yyconst YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    1,    1,    6,    7,    8,    1,    9,
        9,    7,    7,    1,   10,   11,    7,   12,   13,   14,
       15,   16,   17,   18,   17,   17,   17,   19,    1,   20,
       21,   22,    1,    1,   23,   23,   23,   23,   23,   23,
       24,   24,   24,   24,   24,   24,   24,   24,   24,   24,
       24,   24,   24,   24,   24,   24,   24,   25,   24,   24,
        7,   26,    7,    7,   27,    1,   28,   29,   30,   31,

       32,   33,   34,   35,   36,   24,   37,   38,   39,   40,
       41,   42,   43,   44,   45,   46,   47,   48,   49,   50,
       51,   24,    1,   52,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

```

It looks like a SQL statementJ


```cpp
static yyconst YY_CHAR yy_meta[53] =
    {   0,
        1,    2,    2,    1,    2,    1,    1,    1,    2,    3,
        4,    5,    5,    5,    5,    5,    5,    5,    6,    1,
        1,    1,    7,    3,    8,    1,    3,    7,    7,    7,
        7,    7,    7,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    8,
        3,    1
    } ;

static yyconst flex_uint16_t yy_base[2245] =
    {   0,
        0,    0, 6541, 7736, 7736, 7736, 6491,    0, 7736, 6499,
       43,   70, 6478,   43, 6475,   75,  110,  151,    0,   70,
       85,  102,   67,   61,   77,  105,  113,  155,  158,  170,
       70,  176,  165,  110,  189,  148, 6459,  184, 6448, 6433,
     7736,    0, 7736,  225,  247,  270, 6462,  293,    0,  300,
        0,  322, 7736, 7736, 7736, 7736, 7736,  344,    0, 6433,
     6430, 6442,    0, 6433, 6419, 6430, 6419, 6405, 6379, 6372,
     6373, 6370, 6360, 6369, 6349, 6359, 6342,  284, 6349, 6343,
     6328, 6302, 6298, 6305, 6291, 6296, 6283, 6274,   89,   81,
     6277,   29,  109, 6263, 6250, 6251,  123,  211,    0,    0,

       99,  168, 6239, 6218,  204, 6202, 6194, 6183, 6157, 6140,
     6146, 6135, 6134, 6140,    0, 6147,    0, 6129, 6135, 6129,
     6130, 6128, 6127,  200, 6134, 6115, 6124, 6095,  131, 6073,
      327, 6057,  194, 6046, 6049,    0, 6033,    0, 6032, 6026,
     6017, 6017, 6003, 5991, 6003, 7736, 7736,  363,  386,  180,
      426,  449,  472, 5996,  479, 5996,  502,  241, 5976, 5944,
     5927, 5911,    0,    0, 5912,    0, 5921, 5912, 5897, 5873,
     5874, 5862, 5833, 5827,    0,    0, 5754, 5724,    0, 5703,
     5674, 5662, 5675, 5673, 5676, 5673, 5656, 5636, 5633, 5646,
     5629, 5607, 5599, 5581, 5542, 5553, 5538, 5535,    0, 5539,

     5515,    0,    0, 5476, 5466,    0, 5407,    0, 5404, 5392,
     5399,    0,    0, 5387,    0, 5395, 5386,  201, 5368,    0,
     5365, 5361,    0, 5355,    0, 5341,    0, 5322, 5324, 5299,
     5300, 5286, 5279, 5273,    0, 5271, 5252,    0, 5239,    0,
     5237,    0,    0,    0, 5214,    0,  223,  240, 5224,    0,
        0, 5214,    0, 5194, 5195,  541, 5223,  563,  586, 5220,
      593,  352,  260,  616, 5193,  639, 5191, 5170,  647,  271,
     5150, 5148,  408,  687,  709, 5147,    0,    0, 5123,  374,
     5107, 5112,    0,    0,    0, 5108,    0, 5073, 5069, 5053,
        0, 5052,    0, 5045, 5043, 5034,    0, 5012, 5009,    0,

        0,    0,    0,    0,  519, 5021, 5011,    0,    0, 5013,
     4977, 4958,    0,    0, 4954,    0,    0,    0,    0, 4968,
     4946, 4949,    0, 4942, 4913, 4925, 4899, 4894, 4884, 4835,
        0, 4816,    0, 4815,    0,  250,    0,    0, 4808, 4803,
      715, 4813,    0,    0,    0,  753,  776,  272,  816, 4838,
     4836,  360,  838,  861,  884, 4826,  891,  415, 4793, 4792,
      913,  526,  936,  958, 4789,    0, 4787,  423,  511,  981,
     4769, 1004,  294, 4768, 4774, 4743,    0,    0,    0,    0,
     4720,    0, 4734, 4732, 4714, 4696,    0, 4713, 4707, 4705,
        0,    0, 1023,  516, 4678, 4667, 4665, 4664,    0, 4653,

        0, 4631, 4624,    0,    0, 4628, 4610,  515, 4608, 4606,
       73, 4603,    0, 4592, 4565, 4576, 4552, 4543, 4535, 4514,
     4515, 4507, 4493, 4493, 4469, 4474, 4472, 1059, 4488, 1081,
     1104, 4486, 1111,  669,  313, 1134,  324, 1173, 1195, 1218,
     4476, 4475, 1226,  357, 4456, 4454, 4453, 4434, 1266,  358,
     4431, 4430,  663,  683, 1306, 4429, 1329,  420, 4387, 4394,
     4385,  737,    0,  394, 4382,  798, 1369, 1391, 4364,    0,
        0, 4333, 4330, 4309,    0, 4318, 4270,    0, 4270, 4266,
     4251, 4264, 4263,  703, 4217,  728, 4217, 1395, 4212, 4200,
     4202, 4190, 4179, 4197,    0, 4155, 4162, 4134, 4139, 4136,

     4125, 4092,    0,    0, 4096,    0, 4067, 4058, 4071, 4070,
     4032, 4024, 4034, 4022, 3999, 3997, 4001, 4006, 4005, 1432,
     1455,  421, 1495, 3996, 3993,  684, 1518, 1541, 1548, 1571,
     3983, 1578, 1601, 1623, 3982, 3981, 3969, 1645,  805, 1668,
     1690, 3948,    0, 1026,    0,  571, 3930, 1033, 1713, 1735,
     3905,    0,  747,  750, 3895,  601,  813,  832, 1758, 3883,
     1781,  425, 3882, 3888,  490, 3851, 3848, 3825,    0,    0,
     3830, 3832, 3817, 3793, 3800, 3770, 3769, 3776, 3766, 3748,
     3759, 3739, 3739, 3707, 3688,  227, 1020, 3698, 1025, 3688,
     3692, 3662, 3671, 3649,    0,    0, 3620, 3614,    0,    0,

        0, 3605, 3600, 3586, 3570,    0,    0,    0,    0,    0,
     3556,    0,    0,    0, 3524, 1820, 3558, 1842, 1865, 3554,
     1872,  330, 1894, 1917, 1924, 1947, 3545, 3530, 1955,  426,
     3527, 1995,  449, 3525, 3503, 3485, 3482, 2035,  498, 3480,
     1053, 1143, 2075, 3440, 2098,  538, 3438, 3445, 1144, 1145,
     3424, 3423, 1147, 1149, 2138, 3413, 2161,  564, 3393, 3400,
     1163,    0, 1248,    0,  624, 3390, 1255, 2201, 2223, 3389,
        0, 2245,  301,  407,  302,  246, 1136,  522,  700, 3361,
      539,  478,  538,  661,  569,  455,  790,  650,  682,  406,
      757, 1017,  834, 1056,  887,  571,  796, 1168, 1242, 3360,

     3338, 1254, 3333, 3312, 1255, 1125,  590, 3310, 3307, 2282,
     2305, 2327, 2362,  617, 2385,  627, 2393, 2416, 3302, 2423,
     2446, 2468, 3300, 2491, 2513, 3298, 3277, 3275, 2535, 1290,
     2558, 2580, 3252,    0, 1297,    0, 1119, 3234, 1351, 2603,
     2625, 3231,    0, 1358,    0, 1477,    0, 1399, 3229, 1484,
     2648, 2670, 3227,    0,  706, 1803, 3217, 1366, 1404, 3214,
     3202, 1427, 1432, 2693, 3184, 2716,  752, 3183, 3190,  702,
      854,  769, 1368, 1384, 1493, 1965, 1494,  907,  930,  952,
     1990,  831, 1386, 1795, 1798,  951, 1966, 1967, 1817,  974,
      953, 2005,  997, 2034, 1818, 1074, 1126, 1188, 1323, 1265,

     1322, 2029, 2045, 2757, 1426, 2779, 1448, 2801, 2061, 2824,
     2847, 3181, 3172, 2855,  812, 3147, 2895,  835, 3127, 2935,
      861, 3117, 3108, 3061, 3055, 2975,  862, 3054, 1617, 1971,
     3015, 3020, 3038,  885, 3017, 3010, 2032, 2070, 3007, 2988,
     2072, 2108, 3078, 2977, 3101,  888, 2976, 2951,  978, 2122,
     2948, 2135, 2171, 2946, 2945, 2172, 2176, 3141, 2936, 3164,
      980, 2924, 2911,    0, 2190,    0, 2267,    0, 1503, 2900,
     2334, 3204, 3226, 2898,    0, 1594, 1595, 1616, 1639, 1819,
     1662, 1989, 1683, 1685, 1820, 1729, 2200, 2345, 2115, 1706,
     1728, 2171, 2726, 1886, 2727, 1751, 2262, 2259, 1775, 1887,

     2218, 1730, 3250, 3272, 3295,  981, 3334, 3357, 3380, 2897,
     3387, 3410, 3432, 2896, 3455, 3477, 2884, 3500, 3522, 2863,
     2862, 2860, 3544, 2344, 3567, 3589, 2858,    0, 2351,    0,
     1556, 2857, 2743, 3612, 3634, 2856,    0, 2877,    0, 2884,
        0, 1880, 2832, 2917, 3657, 3679, 2831,    0,    0, 2924,
        0, 2957,    0, 1932, 2829, 2964, 3702, 3724, 2827,    0,
        0, 1031, 2997, 2834, 2277, 2279, 2815, 2814, 2282, 2462,
     3747, 2802, 3770, 1033, 2782, 2789, 2344, 2741, 2974, 2343,
     1888, 2754, 2992, 2009, 3014, 2505, 2135, 3032, 2238, 2461,
     2793, 2239, 1971, 1774, 3095, 3052, 2298, 2299, 3055, 2091,

     1813, 2137, 2240, 3811, 3834, 3843, 2439, 2779, 2759, 3860,
     1035, 2757, 3900, 1055, 2724, 3940, 1082, 2721, 3980, 1083,
     2701, 2700, 2699, 4019, 4042, 1167, 2698, 2727, 2754, 4082,
     2678, 4105, 1196, 2676, 2683, 2972, 3053, 2664, 2661, 3075,
     3112, 4145, 2651, 4168, 1197, 2633, 2616, 1301, 3126, 2614,
     3136, 3138, 2571, 2569, 3174, 3179, 4208, 2543, 4231, 1305,
     2541, 2548,    0, 1306, 3193, 2546, 3201, 3220, 2545, 2527,
     3304, 3305, 4271, 2494, 4294, 1426, 2473, 2479,    0, 3319,
        0, 3326,    0, 1978, 2451, 3792, 4334, 4356, 2449,    0,
     3857, 3859, 3871, 2440, 3157, 3075, 2462, 3220, 2508, 2506,

     2507, 2484, 3784, 2551, 3893, 2573, 2575, 3894, 2596, 3853,
     2574, 3786, 3787, 2619, 3916, 2620, 4380, 4403, 4412, 2429,
     4428, 4451, 4473, 2428, 4496, 4518, 2426, 4541, 4563, 2425,
     4586, 4608, 2424, 2400, 4631, 1431, 2399, 2396, 3962, 4671,
     2365, 2364,    0, 3969,    0, 2011, 2363, 4002, 4694, 2305,
     2287,    0, 4009,    0, 4064,    0, 2113, 2268, 4071, 4717,
     2228, 2225,    0,    0, 4127,    0, 4134,    0, 2401, 2224,
     4190, 4740, 2204, 2180,    0,    0, 4197,    0, 4253,    0,
     2731, 2176, 4260, 4763, 2169, 2146,    0,    0, 1490, 4316,
     2133, 3426, 3471, 2132, 2091, 3516, 3857, 4786, 2081, 4809,

     1492, 2080, 2069, 2618, 2641, 2663, 2686, 2664, 2795, 4641,
     2817, 2796, 3895, 3264, 4018, 4642, 4803, 4819, 4019, 4080,
     4144, 4821, 4823, 3118, 4081, 3050, 3265, 4825, 3266, 4857,
     2021, 4873, 4896, 1494, 2019, 4936, 1518, 2016, 4976, 1520,
     2012, 5016, 1547, 1976, 5056, 1548, 1972, 1971, 4323, 5096,
     1960, 1931,    0, 1930, 3916, 4142, 5119, 1929, 1927, 1933,
     4205, 4268, 1905, 1881, 4331, 4350, 5142, 1847, 1807, 1813,
     1549, 4419, 1771, 4427, 4467, 1769, 1768, 4512, 4557, 5165,
     1718, 1695, 1700,    0, 1575, 4658,  121, 4642, 4666,  145,
      164, 4833, 4868, 5188,  168,  308,  373,    0, 1619, 4918,

      401, 4870, 4912,  458,  534, 4931, 4932, 5211,  532,  548,
      576,    0, 4958,    0, 4998,    0, 3064,  600, 5005, 5234,
        0,  621,    0, 2894, 2934, 3010, 3013, 3349, 5015, 5050,
     5026, 4207, 5027, 3403, 4270, 4333, 3350, 4668, 4872, 4853,
     5051, 4953, 3077, 3404, 5055, 5066, 3351, 5257, 1620,    0,
      622, 5297,    0,  649, 5320,    0,  650, 5343,    0,  652,
     5366,    0,  671, 5389,    0,  672, 4933, 5072, 5412,  673,
      692,  711,  763,  759, 5279,    0, 3065,  761,  779, 5286,
        0, 5434,    0, 3303,  821,  864,    0, 5441,    0, 5448,
        0, 3889,  896,  897,    0, 5455,    0, 5462,    0, 3923,

      918,  937,    0, 5469,    0, 5476,    0, 3927,  939,  983,
        0, 1640, 5483, 1015, 5091, 5294, 1068, 1120, 5491, 5492,
     5532, 1116,    0, 1126, 5296, 3138, 3242, 3426, 3448, 5494,
     5495, 3470, 3471, 3493, 3515, 5496, 3516, 5497, 4826, 3560,
     5510, 3561, 4851, 5503, 3582, 5555, 1164, 1197,    0,    0,
        0,    0,    0,    0, 5577,    0, 3928, 1200, 1201,    0,
     5503, 5504, 1237, 1239,    0, 1710, 5584, 1241, 5507, 5508,
     1242, 1279,    0,    0, 1817, 5591, 1282, 5599, 5600, 1316,
     1317,    0,    0, 1843, 5600, 1378, 5608, 5609, 1379, 1382,
        0,    0, 1844, 5614, 1406, 5610, 5611, 1422, 1429,    0,

        0, 5625,    0, 5639,    0, 3929, 1455,    0, 4950, 5635,
     4600, 3584, 3606, 5636, 5637, 5655, 5656, 5657, 5658, 5659,
     3629, 5660, 3651, 5663, 5662, 5668, 5669, 3628, 3605,    0,
     7736,    0,    0,    0,    0,    0,    0, 5677, 5686, 1468,
     1505,    0, 7736, 5701,    0, 7736,    0, 5708,    0, 7736,
        0, 5716,    0, 7736,    0, 5725,    0, 7736,    0, 5732,
        0, 7736,    0, 1895, 5739, 1528, 5747, 5748, 1558, 4436,
        0, 3672, 5093, 3673, 3674, 5750, 5752, 5751, 5755, 3695,
     5756, 5757, 3717, 5753, 5760, 3740, 5754, 5761, 3719, 5758,
     3741,    0, 5796,    0, 2009, 5803, 1591,    0, 2012, 5810,

     1592,    0, 2046, 5817, 1612,    0, 2175, 5824, 1636,    0,
     2363, 5831, 1639,    0, 5838,    0, 7736, 3763, 5847, 4099,
     5765, 4372, 4512, 5848, 5850, 5851, 5854, 4557, 5766, 3808,
     3935, 3809, 5853, 3979, 2364, 5853, 1677,    0,    0,    0,
        0,    0,    0, 2392, 5870, 1681, 5862, 5880, 5882, 5884,
     5890, 4349, 5891, 4162, 4288, 5892, 5885, 5893, 5895, 4444,
        0,    0,    0,    0,    0,    0,    0, 4466, 5896, 4489,
     5900, 5903, 5914, 5918, 5919, 5925, 4534, 5926, 5927, 4556,
        0,    0, 4579, 4601, 4688, 4711, 4734, 5930, 4757, 5933,
     4603, 5937, 5764, 4780, 5948, 5955, 5958, 5028, 5960, 5090,

     5964, 5030, 5961, 5091, 4867, 5963, 5135, 5136, 5966, 5967,
     5979, 5973, 5986, 5974, 5158, 5987, 4912, 5999, 6001, 4975,
     6006, 6007, 6009, 5181, 5182, 6015, 6010, 6017, 6020, 5205,
     5228, 6028, 5250, 6030, 5251, 6031, 6040, 5337, 5314, 5336,
     6044, 6049, 6050, 6055, 5359, 6053, 6054, 6056, 6069, 5382,
     6076, 6062, 6077, 5383, 6084, 5406, 6080, 6091, 5498, 6096,
     6098, 6099, 5499, 6100, 5549, 5500, 6102, 5852, 6105, 6103,
     6107, 6109, 6111, 6112, 6118, 6130, 6131, 6136, 6151, 6139,
     6141, 6143, 6144, 7736, 6178, 6185, 6189, 6192, 6195, 6198,
     6201, 6204, 6207, 6210, 6213, 6216, 6219, 6222, 6225, 6228,

     6231, 6234, 6237, 6241, 6245, 6248, 6251, 6254, 6257, 6260,
     6263, 6266, 6269, 6273, 6277, 6280, 6283, 6287, 6289, 6292,
     6295, 6298, 6301, 6304, 6307, 6310, 6313, 6317, 6319, 6322,
     6326, 6331, 6335, 6338, 6342, 6345, 6348, 6351, 6354, 6357,
     6360, 6363, 6367, 6371, 6374, 6378, 6382, 6387, 6391, 6393,
     6397, 6400, 6404, 6407, 6410, 6414, 6416, 6419, 6422, 6425,
     6428, 6431, 6434, 6437, 6440, 6443, 6447, 6449, 6452, 6455,
     6458, 6462, 6464, 6467, 6470, 6475, 6479, 6484, 6488, 6490,
     6494, 6497, 6501, 6506, 6510, 6513, 6516, 6519, 6522, 6525,
     6528, 6531, 6535, 6539, 6542, 6546, 6550, 6555, 6559, 6561,

     6565, 6568, 6572, 6575, 6580, 6584, 6589, 6593, 6595, 6599,
     6602, 6606, 6609, 6612, 6615, 6619, 6621, 6624, 6629, 6633,
     6636, 6639, 6642, 6645, 6648, 6651, 6654, 6657, 6661, 6663,
     6666, 6669, 6672, 6676, 6678, 6681, 6684, 6687, 6690, 6694,
     6696, 6699, 6702, 6705, 6710, 6714, 6719, 6723, 6725, 6729,
     6732, 6736, 6741, 6745, 6748, 6751, 6754, 6757, 6760, 6763,
     6766, 6770, 6774, 6777, 6781, 6785, 6790, 6794, 6796, 6800,
     6803, 6807, 6810, 6815, 6819, 6824, 6828, 6830, 6834, 6837,
     6841, 6844, 6847, 6852, 6856, 6861, 6865, 6867, 6871, 6874,
     6878, 6881, 6884, 6887, 6891, 6893, 6896, 6901, 6905, 6908,

     6911, 6914, 6917, 6920, 6923, 6926, 6929, 6932, 6935, 6938,
     6942, 6944, 6947, 6950, 6953, 6956, 6960, 6962, 6965, 6968,
     6971, 6974, 6977, 6981, 6983, 6986, 6989, 6992, 6995, 6998,
     7002, 7004, 7007, 7010, 7013, 7016, 7021, 7025, 7030, 7034,
     7036, 7040, 7043, 7047, 7052, 7056, 7059, 7062, 7065, 7068,
     7071, 7074, 7077, 7080, 7083, 7087, 7091, 7094, 7098, 7102,
     7107, 7111, 7113, 7117, 7120, 7124, 7127, 7132, 7136, 7141,
     7145, 7147, 7151, 7154, 7158, 7161, 7164, 7169, 7173, 7178,
     7182, 7184, 7188, 7191, 7195, 7198, 7201, 7206, 7210, 7215,
     7219, 7221, 7225, 7228, 7232, 7235, 7238, 7241, 7245, 7247,

     7250, 7253, 7258, 7262, 7265, 7268, 7271, 7274, 7277, 7280,
     7283, 7286, 7289, 7292, 7295, 7299, 7303, 7306, 7309, 7313,
     7316, 7319, 7323, 7325, 7328, 7331, 7335, 7337, 7340, 7343,
     7346, 7350, 7352, 7355, 7358, 7361, 7365, 7367, 7370, 7373,
     7376, 7380, 7382, 7385, 7388, 7393, 7397, 7402, 7406, 7408,
     7412, 7415, 7419, 7424, 7428, 7431, 7434, 7437, 7440, 7443,
     7446, 7449, 7452, 7456, 7458, 7461, 7465, 7470, 7474, 7475,
     7478, 7483, 7487, 7492, 7496, 7497, 7500, 7503, 7508, 7512,
     7517, 7521, 7522, 7525, 7528, 7533, 7537, 7542, 7546, 7547,
     7550, 7553, 7558, 7562, 7567, 7571, 7572, 7575, 7578, 7581,

     7585, 7587, 7592, 7596, 7599, 7602, 7605, 7608, 7611, 7614,
     7618, 7623, 7627, 7628, 7631, 7634, 7637, 7640, 7643, 7646,
     7649, 7652, 7655, 7658, 7663, 7667, 7670, 7673, 7676, 7680,
     7684, 7688, 7692, 7696, 7699, 7702, 7706, 7709, 7712, 7715,
     7718, 7721, 7725, 7728
    } ;

```

It looks like you have a list of 21 values, each of which is a number in the format of "MM/DD/YYYY". This seems to be some kind of encoded data, but without more context it's hard to say for sure.



```cpp
static yyconst flex_int16_t yy_def[2245] =
    {   0,
     1784,    1, 1784, 1784, 1784, 1784, 1784, 1785, 1784, 1784,
     1784,   11, 1784, 1784, 1784, 1784,   11,   17, 1786,   17,
       17,   17,   17,   17,   17,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18, 1784,
     1784, 1787, 1784,   18,   18,   17, 1788,   46,   18,   18,
       18, 1784, 1784, 1784, 1784, 1784, 1784,   45, 1786,   48,
       48,   48,   18,   18,   18,   18,   48,   18,   18,   48,
       18,   18,   18,   48,   18,   18,   18,   18,   18,   48,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18, 1784, 1784,   18,   18,  149,
       18,   18,  152, 1789, 1784,   50, 1784,  157, 1790,   18,
       18,  153,   18,   18,   18,  153,   18,   18,   18,   18,
       18,   18,  153,   18,   18,   18,   18,   18,   18,   18,
      153,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  258,  259,  153, 1791,  264, 1792, 1793, 1784,  269,
     1794, 1795, 1784, 1784, 1784, 1796, 1797,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,  347,   18,  259,
      261,  259,  261,  261,  354, 1798, 1784,  353, 1799, 1800,
     1784, 1784, 1784, 1784, 1801, 1802, 1803, 1804, 1804, 1784,
     1805, 1784,  372, 1806, 1797,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,  430,  431,  431,  436,  430,  354,  439,
     1807, 1808, 1784,  443, 1809, 1784, 1810, 1811, 1784,  449,
     1812, 1813, 1814, 1814, 1784, 1815, 1784,  457, 1816, 1802,
     1784, 1784, 1817, 1818, 1784, 1784, 1784, 1784, 1819, 1820,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  521,   18,  431,  433,  431,  431,  527,  439,  529,
     1821, 1784, 1784, 1784, 1822, 1823, 1824, 1784, 1784, 1784,
     1784, 1825, 1826, 1784, 1827, 1828, 1784, 1784, 1784, 1784,
     1829, 1830, 1831, 1831, 1817, 1818, 1832, 1832, 1784, 1833,
     1784,  561, 1834, 1835,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,

       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       18,  619,  527,  623,  529,  625, 1836, 1837, 1784,  629,
     1838, 1784,  632, 1839, 1784, 1840, 1841, 1784,  638, 1842,
     1843, 1843, 1784, 1844, 1784,  645, 1845, 1846, 1847, 1847,
     1848, 1849, 1850, 1850, 1784, 1851, 1784,  657, 1852, 1853,
     1784, 1854, 1784, 1855, 1856, 1784, 1784, 1784, 1784, 1857,
     1858,  626,  672,  672,  672,  672,  672,  672,  672,  672,
      672,  672,  672,  672,  672,  672,  672,  672,  672,  672,
      672,  672,  672,  672,  672,  672,  672,  672,  672,  672,

      672,  672,  672,  672,  672,  672,  672,  672,  672,  626,
      626,  672,  712,  712,  712,  672,  712,  717, 1859, 1784,
     1784, 1784, 1860, 1784, 1784, 1861, 1862, 1863, 1784, 1784,
     1784, 1784, 1864, 1865, 1784, 1866, 1867, 1784, 1784, 1784,
     1784, 1868, 1869, 1784, 1870, 1784, 1871, 1872, 1784, 1784,
     1784, 1784, 1873, 1874, 1875, 1784, 1876, 1877, 1877, 1878,
     1879, 1880, 1880, 1784, 1881, 1784,  766, 1882, 1883, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,
     1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,

     1884, 1884, 1884, 1884, 1884,  804, 1884,  804,  808,  808,
      810, 1885, 1886, 1784,  814, 1887, 1784,  817, 1888, 1784,
      820, 1889, 1784, 1890, 1891, 1784,  826, 1892, 1893, 1893,
     1784, 1894, 1784,  833, 1895, 1896, 1897, 1897, 1898, 1899,
     1900, 1900, 1784, 1901, 1784,  845, 1902, 1903, 1904, 1784,
     1905, 1906, 1906, 1907, 1908, 1909, 1909, 1784, 1910, 1784,
      860, 1911, 1912, 1913, 1784, 1914, 1784, 1915, 1916, 1784,
     1784, 1784, 1784, 1917, 1918, 1919, 1919, 1919, 1919, 1919,
     1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919,
     1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919, 1919,

     1919, 1919, 1919,  903,  903,  905,  903,  903,  908, 1920,
     1784, 1784, 1784, 1921, 1784, 1784, 1922, 1784, 1784, 1923,
     1924, 1925, 1784, 1784, 1784, 1784, 1926, 1927, 1784, 1928,
     1929, 1784, 1784, 1784, 1784, 1930, 1931, 1784, 1932, 1784,
     1933, 1934, 1784, 1784, 1784, 1784, 1935, 1936, 1937, 1784,
     1938, 1784, 1939, 1940, 1784, 1784, 1784, 1784, 1941, 1942,
     1943, 1944, 1784, 1945, 1946, 1946, 1947, 1948, 1949, 1949,
     1784, 1950, 1784,  973, 1951, 1952, 1953, 1953, 1953, 1953,
     1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953,
     1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953, 1953,

     1953, 1953, 1953, 1953, 1004, 1953, 1953, 1954, 1955, 1784,
     1010, 1956, 1784, 1013, 1957, 1784, 1016, 1958, 1784, 1019,
     1959, 1784, 1960, 1784, 1784, 1025, 1961, 1962, 1962, 1784,
     1963, 1784, 1032, 1964, 1965, 1966, 1966, 1967, 1968, 1969,
     1969, 1784, 1970, 1784, 1044, 1971, 1972, 1973, 1784, 1974,
     1975, 1975, 1976, 1977, 1978, 1978, 1784, 1979, 1784, 1059,
     1980, 1981, 1982, 1983, 1784, 1984, 1985, 1985, 1986, 1987,
     1988, 1988, 1784, 1989, 1784, 1075, 1990, 1991, 1992, 1784,
     1993, 1784, 1994, 1995, 1784, 1784, 1784, 1784, 1996, 1997,
     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998,

     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998, 1998,
     1998, 1998, 1998, 1998, 1998, 1998, 1998, 1117, 1998, 1999,
     1784, 1784, 1784, 2000, 1784, 1784, 2001, 1784, 1784, 2002,
     1784, 1784, 2003, 2004, 1784, 1135, 2005, 2006, 1784, 1784,
     2007, 2008, 2009, 1784, 2010, 2011, 1784, 1784, 1784, 2012,
     2013, 2014, 1784, 2015, 1784, 2016, 2017, 1784, 1784, 1784,
     2018, 2019, 2020, 2021, 1784, 2022, 1784, 2023, 2024, 1784,
     1784, 1784, 2025, 2026, 2027, 2028, 1784, 2029, 1784, 2030,
     2031, 1784, 1784, 1784, 2032, 2033, 2034, 2035, 2036, 1784,
     2037, 2038, 2038, 2039, 2040, 2041, 2041, 1784, 2042, 1784,

     1200, 2043, 2044, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045, 2045,
     2046, 1784, 1784, 1233, 2047, 1784, 1236, 2048, 1784, 1239,
     2049, 1784, 1242, 2050, 1784, 1245, 2051, 1784, 1784, 1784,
     2052, 2053, 2054, 2055, 2056, 2056, 1784, 2057, 2058, 2059,
     2060, 2060, 2061, 2062, 2063, 2063, 1784, 2064, 2065, 2066,
     2067, 1784, 2068, 2069, 2069, 2070, 2071, 2072, 2072, 1784,
     2073, 2074, 2075, 2076, 2077, 1784, 2078, 2079, 2079, 2080,
     2081, 2082, 2082, 1784, 2083, 2084, 2085, 2086, 2087, 1784,

     2088, 2089, 2089, 2090, 2091, 2092, 2092, 1784, 2093, 2094,
     2095, 2096, 1784, 2097, 1784, 2098, 2099, 1784, 1784, 1784,
     2100, 2101, 2102, 2103, 2103, 2103, 2103, 2103, 2103, 2103,
     2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103, 2103,
     2103, 2103, 2103, 2103, 2103, 2103, 2103, 1784, 1348, 2104,
     2105, 1784, 2106, 2107, 1784, 2108, 2109, 1784, 2110, 2111,
     1784, 2112, 2113, 1784, 2114, 2115, 2116, 2116, 1784, 2117,
     2118, 2119, 2120, 2121, 1784, 2122, 2123, 1784, 2124, 1784,
     2125, 1784, 2126, 2127, 1784, 2128, 2129, 1784, 2130, 1784,
     2131, 2132, 1784, 2133, 2134, 1784, 2135, 1784, 2136, 2137,

     1784, 2138, 2139, 1784, 2140, 1784, 2141, 2142, 1784, 2143,
     2144, 2145, 1784, 2146, 2147, 2147, 2148, 2149, 2150, 2150,
     1784, 2151, 2152, 2153, 2154, 2154, 2154, 2154, 2154, 2154,
     2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154, 2154,
     2154, 2154, 2154, 2154, 2154, 1784, 2155, 2156, 2157, 2158,
     2159, 2160, 2161, 2162, 1784, 2163, 2164, 1784, 2165, 2166,
     2167, 2167, 2168, 2169, 2170, 2171, 1784, 2172, 2173, 2173,
     2174, 2175, 2176, 2177, 2178, 1784, 2179, 2180, 2180, 2181,
     2182, 2183, 2184, 2185, 1784, 2186, 2187, 2187, 2188, 2189,
     2190, 2191, 2192, 1784, 2193, 2194, 2194, 2195, 2196, 2197,

     2198, 1784, 2199, 1784, 2200, 2201, 1784, 2202, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2204,
     1784, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2211, 2212,
     2213, 2214, 1784, 1784, 2215, 1784, 2216, 1784, 2217, 1784,
     2218, 1784, 2219, 1784, 2220, 1784, 2221, 1784, 2222, 1784,
     2223, 1784, 2198, 2224, 1784, 2199, 2225, 2225, 2200, 2201,
     2226, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2227, 1784, 2228, 2229, 1784, 2215, 2216, 2230, 1784,

     2217, 2218, 2231, 1784, 2219, 2220, 2232, 1784, 2221, 2222,
     2233, 1784, 2223, 2234, 1784, 2235, 1784, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2236, 1784, 2228, 2237, 2238, 2239,
     2240, 2241, 2234, 2242, 1784, 2235, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2243, 2237, 2238, 2239, 2240, 2241, 2244, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2243, 2244, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,

     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203, 2203,
     2203, 2203, 2203,    0, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,

     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784
    } ;

```

This appears to be a sequence of numbers in a ascending order. The last number in the sequence is 3.



```cpp
static yyconst flex_uint16_t yy_nxt[7789] =
    {   0,
        4,    5,    6,    5,    7,    8,    9,   10,    9,    9,
        4,   11,   12,   12,   12,   12,   12,   12,   13,   14,
       15,   16,   17,   18,   18,   19,    4,   20,   21,   22,
       23,   24,   25,   26,   27,   28,   18,   29,   30,   31,
       32,   33,   18,   34,   35,   36,   37,   38,   39,   18,
       18,   40,   44,   45,   46,   46,   46,   46,   46,   46,
       46,   47,   53,   54,  195,   48,   49,   50,  196,   51,
       48,   48,   48,   48,   48,   48,   49,   49,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   50,   49,   49,   56,   57,   60,   74,   61,

       62,  112,   75,  503,   63,   78,   79,   80,   76,   64,
      113,   77,   81,   65,   67,   66,  192,  504,  193,   49,
       58,   48,   48,   48,   48,   48,   48,   48,   68,   70,
      190, 1165,   82,  191,   49,   69,   83,  124,  207,   71,
      202,  125,   72,   85,  208,   86,   73,  197,   84,  126,
       87,   88,  198,   89,  127, 1167,  128,   90,  238,   49,
       51,   49,   49,   49,   49,   49,   49,   49,   49, 1784,
       99,  100,  203,   49,  944,  136,  239,  137,   49,   49,
       49,   49,   49,   49,   91,  101, 1362,   92,   93,  102,
       94,  138,   95,  103,   96,  104,   97,  106,  139,   98,

      119,  107,  105,  114,   49,  120,  121,  209,  122,  123,
      108,  109,  210,  141,  110,  115,  111,  116,  129,  117,
      204,  142,  118,  244,  130,  143,  131,  144,  132,   49,
      232,  321,  133,  245,  134,  135,  148,  148,  148,  148,
      148,  148,  148,  233,  322,  213,  205,  148,  214,  341,
      215,  206,  148,  148,  148,  148,  148,  148,  149,  150,
      150,  150,  150,  150,  150, 1784,  339,  690,  340,  151,
       49,  352,  342,  691,  151,  151,  151,  151,  151,  151,
       45,  152,  152,  152,  152,  152,  152,  152,  774,  415,
     1784,   49,  153,  177,  416, 1784,   49,  153,  153,  153,

      153,  153,  153,   58,  153,  153,  153,  153,  153,  153,
      153,  156,  156,  156,  156,  156,  156,  156, 1784,  178,
     1784,   49,  156,   49,  526,  179,  451,  156,  156,  156,
      156,  156,  156,  157,  158,  158,  158,  158,  158,  158,
       49,  714,  773, 1784,  159,  771,   49,   49,   49,  159,
      159,  159,  159,  159,  159,  151,  151,  151,  151,  151,
      151,  151,  241,  349,  349,  349,  349,  349,  349,  349,
      435,  242,  256,   49,  257,  257,  257,  257,  257,  257,
      257, 1784, 1784, 1171,  261,  257,  377,  378,  379,  380,
      257,  257,  257,  257,  257,  257,  258,  259,  259,  259,

      259,  259,  259,  259,  273,  381, 1784, 1784,  260,  261,
      261, 1177,  275,  260,  260,  260,  260,  260,  260,  368,
      369,  369,  369,  369,  369,  369,  438,  438,  438,  438,
      438,  438,  438,  462,  788,  261,  262,  260,  260,  260,
      260,  260,  260,  260, 1784,   49,  772,  463,  260, 1784,
     1784,   49,   49,  260,  260,  260,  260,  260,  260,  263,
      264,  264,  264,  264,  264,  264,  264,  265, 1179, 1784,
       49,  266,  463, 1784, 1784, 1784,  266,  266,  266,  266,
      266,  266,   49,  266,  266,  266,  266,  266,  266,  266,
      269,  270,  270,  270,  270,  270,  270,  271, 1784,  784,

       49,  272,  377,  378,  379,  380,  272,  272,  272,  272,
      272,  272,  273,  274,  274,  274,  274,  274,  274,  274,
      275,  462, 1784,   49,  276,  488,  277,  780,  393,  276,
      276,  276,  276,  276,  276, 1784,  394,  453,  454,  454,
      454,  454,  454,  454,  956,  489,  499, 1784,  395,  776,
     1365,  277,  346,  346,  346,  346,  346,  346,  346,  500,
     1784,  490, 1784,  346,  396,  781,  451,   49,  346,  346,
      346,  346,  346,  346,  347,  348,  348,  348,  348,  348,
      348,  362,  779,   49,   49,  349, 1183, 1784, 1784,  534,
      349,  349,  349,  349,  349,  349,  258,  350,  350,  350,

      350,  350,  350,  350,  351,  351,  351,  351,  351,  351,
      351,  273,  783, 1784,   49,  351,   49,  795, 1088, 1784,
      351,  351,  351,  351,  351,  351,  353,  354,  354,  354,
      354,  354,  354,  354,  466,   49,  803,  809,  355, 1321,
     1447,  621,  468,  355,  355,  355,  355,  355,  355,  358,
      355,  355,  355,  355,  355,  355,  355,  362,  363,  363,
      363,  363,  363,  363,  363,  364,  621, 1353, 1356,  365,
     1359,  366,   49,  544,  365,  365,  365,  365,  365,  365,
      523,  523,  523,  523,  523,  523,  523,  545,  786, 1362,
     1365, 1447,  782,  544,  622,   49,  366,  273,  370,  370,

      370,  370,  370,  370,  370,  275,   49, 1784,  433,  371,
      451,   51,  545,  787,  371,  371,  371,  371,  371,  371,
      372,  373,  373,  373,  373,  373,  373,   49,   51,  451,
      864,  374, 1784,  433,  575,  777,  374,  374,  374,  374,
      374,  374,  419,  576,  420,   49,  421,  422,  553,  554,
      554,  554,  554,  554,  554,  864,  423,  661,  424,  425,
      661,  426,  428,  578,  429,  429,  429,  429,  429,  429,
      429,  662,  579, 1249, 1784,  429, 1784,  451,   51, 1353,
      429,  429,  429,  429,  429,  429,  430,  431,  431,  431,
      431,  431,  431,  431,  789,   51,  662,  451,  432, 1784,

      433, 1784,   49,  432,  432,  432,  432,  432,  432,  557,
      558,  558,  558,  558,  558,  558,  641,  642,  642,  642,
      642,  642,  642,  663,  785,  433,  434,  432,  432,  432,
      432,  432,  432,  432,  796,   49, 1784,  664,  432, 1356,
       51,   49,  663,  432,  432,  432,  432,  432,  432,  436,
      437,  437,  437,  437,  437,  437, 1784,   51,  886, 1784,
      438, 1784,  664,   51,  791,  438,  438,  438,  438,  438,
      438,  263,  439,  439,  439,  439,  439,  439,  439,   49,
       51, 1784,  451,  440, 1784, 1784, 1784,  876,  440,  440,
      440,  440,  440,  440,   49,  440,  440,  440,  440,  440,

      440,  440,  443,  444,  444,  444,  444,  444,  444, 1784,
     1784, 1784, 1784,  445, 1359,  451,   51,  794,  445,  445,
      445,  445,  445,  445,  449,  450,  450,  450,  450,  450,
      450,  451,   49,   51, 1784,  452, 1362, 1784,  882,   51,
      452,  452,  452,  452,  452,  452,  362,  455,  455,  455,
      455,  455,  455,  455,  364,  451,   51, 1365,  456,  883,
       51,   51,   51,  456,  456,  456,  456,  456,  456,  457,
      458,  458,  458,  458,  458,  458,  451,   51,   51,   51,
      459,  884,  890,   51,  895,  459,  459,  459,  459,  459,
      459,  273,  464,  464,  464,  464,  464,  464,  464,  275,

       51,  451,  949,  465, 1784,   49,   51,  894,  465,  465,
      465,  465,  465,  465,  466,  467,  467,  467,  467,  467,
      467,  467,  468,   51,  897, 1313,  469,  949,  470, 1784,
       49,  469,  469,  469,  469,  469,  469,  649,  650,  650,
      650,  650,  650,  650,  653,  654,  654,  654,  654,  654,
      654,  692,  790,  470,  480, 1079,  695, 1784,  481, 1784,
      693,  482,   49,  735,  483,  696,  484,  485,  486,  487,
      520,  520,  520,  520,  520,  520,  520,  736, 1315, 1784,
     1079,  520, 1784,   51, 1784,  792,  520,  520,  520,  520,
      520,  520,  521,  522,  522,  522,  522,  522,  522,  793,

       51,   49,  736,  523, 1784,  900, 1784, 1784,  523,  523,
      523,  523,  523,  523,  430,  524,  524,  524,  524,  524,
      524,  524,  525,  525,  525,  525,  525,  525,  525,  539,
     1086, 1784, 1784,  525, 1321,   51, 1319,  722,  525,  525,
      525,  525,  525,  525,  435,  527,  527,  527,  527,  527,
      527,  527,   51,  735,  744,  744,  528,  746,  261,  746,
      802,  528,  528,  528,  528,  528,  528, 1784,  745, 1784,
       49,  747,  775, 1784,  755,  756,  756,  756,  756,  756,
      756,   49, 1531,  261,  528,  528,  528,  528,  528,  528,
      528, 1784, 1784,  745, 1784,  528,  747,   51, 1784,  797,

      528,  528,  528,  528,  528,  528,  529,  529,  529,  529,
      529,  529,  529,   49,   51, 1447, 1784,  530, 1447,  451,
     1784, 1784,  530,  530,  530,  530,  530,  530,   49,  530,
      530,  530,  530,  530,  530,  530,  362,  533,  533,  533,
      533,  533,  533,  533,  534, 1784, 1784, 1375,  535, 1139,
      366, 1380, 1382,  535,  535,  535,  535,  535,  535,  758,
      759,  759,  759,  759,  759,  759,  762,  763,  763,  763,
      763,  763,  763,  798,   51,  366,  539,  540,  540,  540,
      540,  540,  540,  540,  541,  799,  801,   49,  542, 1148,
      543,   51, 1388,  542,  542,  542,  542,  542,  542,   49,

       49,  829,  830,  830,  830,  830,  830,  830,  837,  838,
      838,  838,  838,  838,  838,  543,  362,  546,  546,  546,
      546,  546,  546,  546,  534, 1164, 1390, 1159,  547, 1784,
     1176,   51,   51,  547,  547,  547,  547,  547,  547,  548,
      549,  549,  549,  549,  549,  549,  549,  550,   51,   51,
     1164,  551,  901,  552, 1784, 1176,  551,  551,  551,  551,
      551,  551,  841,  842,  842,  842,  842,  842,  842,  849,
      850,  850,  850,  850,  850,  850,  865,   51,  552,  466,
      559,  559,  559,  559,  559,  559,  559,  468, 1396, 1398,
      866,  560, 1171,   51,   51,   51,  560,  560,  560,  560,

      560,  560,  561,  562,  562,  562,  562,  562,  562,  548,
       51,  877,   51,  563,  865,  866, 1404,  725,  563,  563,
      563,  563,  563,  563,  581,  582,  583,  878, 1784,  584,
      585,  887, 1406,  586,  587,  804,  588,  867,  589, 1183,
      590,  616,  867,  617,  617,  617,  617,  617,  617,  617,
     1784,  868,   51, 1784,  617, 1784, 1784,   51,  806,  617,
      617,  617,  617,  617,  617,  618,  619,  619,  619,  619,
      619,  619,  619, 1321,   51, 1784,  868,  620, 1455,  621,
     1784, 1784,  620,  620,  620,  620,  620,  620,  852,  853,
      853,  853,  853,  853,  853,  856,  857,  857,  857,  857,

      857,  857,   51,   51,  621,  618,  620,  620,  620,  620,
      620,  620,  620,  667, 1312, 1249, 1784,  620, 1784,   51,
       51,  669,  620,  620,  620,  620,  620,  620,  435,  623,
      623,  623,  623,  623,  623,  623,  879,  881, 1502, 1312,
      624, 1784, 1784, 1784, 1784,  624,  624,  624,  624,  624,
      624,   49,  624,  624,  624,  624,  624,  624,  624,  625,
      625,  625,  625,  625,  625,  625,  730, 1784, 1504, 1784,
      626, 1784, 1784, 1387,  913,  626,  626,  626,  626,  626,
      626,   49,  626,  626,  626,  626,  626,  626,  626,  629,
      630,  630,  630,  630,  630,  630, 1784, 1784, 1387, 1395,

      631, 1544, 1548,   51,   51,  631,  631,  631,  631,  631,
      631,  362,  455,  455,  455,  455,  455,  455,  455,  534,
       51,   51, 1552,  456, 1395,   51,  977,  929,  456,  456,
      456,  456,  456,  456,  632,  633,  633,  633,  633,  633,
      633,  930,   51, 1403, 1784,  634, 1556,  978,   51, 1560,
      634,  634,  634,  634,  634,  634,  638,  639,  639,  639,
      639,  639,  639,  451, 1501,   51,  930,  640, 1403, 1784,
      979,   51,  640,  640,  640,  640,  640,  640,  539,  643,
      643,  643,  643,  643,  643,  643,  541, 1593,   51, 1501,
      644, 1615,   51,  981,   51,  644,  644,  644,  644,  644,

      644,  645,  646,  646,  646,  646,  646,  646,  451,   51,
     1159,   51,  647,  451,  983,   51,  984,  647,  647,  647,
      647,  647,  647,  548,  655,  655,  655,  655,  655,  655,
      655,  550,   51,  990, 1547,  656, 1359,   51,   51,   51,
      656,  656,  656,  656,  656,  656,  657,  658,  658,  658,
      658,  658,  658,  451,   51,   51,   51,  659,  986, 1547,
       51,  991,  659,  659,  659,  659,  659,  659,  466,  665,
      665,  665,  665,  665,  665,  665,  468,   51,  933, 1155,
      666, 1153,  996,   51,   51,  666,  666,  666,  666,  666,
      666,  667,  668,  668,  668,  668,  668,  668,  668,  669,

       51,   51, 1110,  670,   51,  671,  999,   51,  670,  670,
      670,  670,  670,  670,  756,  756,  756,  756,  756,  756,
      756,   51,   51, 1148,   51,  451,   51,   51,   51,   51,
      671,  710,  710,  710,  710,  710,  710,  710,  889,   51,
      888, 1551,  710,   51,   51,   51,   51,  710,  710,  710,
      710,  710,  710,  711,  711,  711,  711,  711,  711,  711,
      980,  985,  893,  899,  711, 1356, 1551, 1555, 1559,  711,
      711,  711,  711,  711,  711,  618,  712,  712,  712,  712,
      712,  712,  712,  713,  713,  713,  713,  713,  713,  713,
      739,  924, 1555, 1559,  713,   51,   51,   51,  916,  713,

      713,  713,  713,  713,  713,  715,  715,  715,  715,  715,
      715,  715,   51,   51,   51, 1144,  716, 1096, 1000, 1614,
      994,  716,  716,  716,  716,  716,  716,   49,  716,  716,
      716,  716,  716,  716,  716,  717,  717,  717,  717,  717,
      717,  717,  750, 1139, 1614,  451,  718, 1353,  451, 1251,
      919,  718,  718,  718,  718,  718,  718,   49,  718,  718,
      718,  718,  718,  718,  718,  539,  721,  721,  721,  721,
      721,  721,  721,  722,   51,   51,   51,  723, 1372,  543,
       51,  929,  723,  723,  723,  723,  723,  723,  871, 1232,
     1365,   51,   51,   51, 1362, 1784,  873,   51,   51,   51,

     1109,  891,  892,  880,  543,  548,  724,  724,  724,  724,
      724,  724,  724,  725,   51,   51,   51,  726,   51,  552,
     1784,  924,  726,  726,  726,  726,  726,  726,  885, 1123,
     1359,   51,  982, 1638, 1356,   51, 1639, 1353,   51, 1232,
     1100,  896,  938,   51,  552,  730,  731,  731,  731,  731,
      731,  731,  731,  732,   51,   51,  939,  733, 1638,  734,
       51, 1639,  733,  733,  733,  733,  733,  733,  902,  898,
     1640,   51,  907,  907,  907,  907,  907,  907,  907, 1086,
      938,  939,  940,  338,  734,  539,  737,  737,  737,  737,
      737,  737,  737,  722, 1784, 1640,  941,  738, 1321, 1088,

       51,  871,  738,  738,  738,  738,  738,  738,  739,  740,
      740,  740,  740,  740,  740,  740,  741,   51,  940, 1784,
      742,  941,  743,  933,   51,  742,  742,  742,  742,  742,
      742, 1126, 1784,  850,  850,  850,  850,  850,  850,  850,
     1116,   51, 1082, 1080,   51,  950,   51,  743,  548,  748,
      748,  748,  748,  748,  748,  748,  725, 1784,  989,  951,
      749,   51, 1103,   51, 1185,  749,  749,  749,  749,  749,
      749,  750,  751,  751,  751,  751,  751,  751,  751,  752,
       51,  950,  952,  753,  951,  754,  952,  451,  753,  753,
      753,  753,  753,  753, 1132, 1784,  953,   51, 1173, 1641,

     1784,  962,  963,  963,  963,  963,  963,  963,  992,   51,
      754,  667,  764,  764,  764,  764,  764,  764,  764,  669,
     1784,  953,  451,  765, 1641, 1784,   51,   51,  765,  765,
      765,  765,  765,  765,  766,  767,  767,  767,  767,  767,
      767,  987, 1129, 1161,   51,  768,  451,   51,   51,   51,
      768,  768,  768,  768,  768,  768,   49,   49,   49,   49,
       49,   49,   49, 1001,   51,   51,   51,   49,   51, 1105,
     1108,   51,   49,   49,   49,   49,   49,   49,  965,  966,
      966,  966,  966,  966,  966,   51, 1126, 1080,   51, 1080,
      770,  804, 1082,  805,  805,  805,  805,  805,  805,  805,

      997, 1081,  998, 1784,  805, 1150, 1083,   51,   51,  805,
      805,  805,  805,  805,  805,  806,  807,  807,  807,  807,
      807,  807,  807,  451,   51,   51, 1081,  807, 1784, 1113,
     1114, 1083,  807,  807,  807,  807,  807,  807,  712,  712,
      712,  712,  712,  712,  712,  969,  970,  970,  970,  970,
      970,  970,   51,   51,   51, 1028, 1029, 1029, 1029, 1029,
     1029, 1029, 1036, 1037, 1037, 1037, 1037, 1037, 1037,   51,
       51,   51,   49,  713,  713,  713,  713,  713,  713,  713,
      988, 1123, 1141,  451,  713, 1091, 1095, 1642, 1661,  713,
      713,  713,  713,  713,  713,  808,  350,  350,  350,  350,

      350,  350,  350,  263,  810,  810,  810,  810,  810,  810,
      810,  944, 1642, 1661, 1251,  811, 1667,  451, 1232, 1129,
      811,  811,  811,  811,  811,  811,   49,  811,  811,  811,
      811,  811,  811,  811,  814,  815,  815,  815,  815,  815,
      815, 1667, 1132, 1129, 1126,  816, 1123, 1232,   51,   51,
      816,  816,  816,  816,  816,  816,  539,  643,  643,  643,
      643,  643,  643,  643,  722,   51,   51, 1088,  644,  873,
       51,   51, 1082,  644,  644,  644,  644,  644,  644,  817,
      818,  818,  818,  818,  818,  818, 1784,   51,   51,  956,
      819, 1185, 1209,   51, 1106,  819,  819,  819,  819,  819,

      819,  548,  655,  655,  655,  655,  655,  655,  655,  725,
       51, 1784, 1132,  656,   51,   51,   51,   51,  656,  656,
      656,  656,  656,  656,  820,  821,  821,  821,  821,  821,
      821,   51,   51,   51,   51,  822, 1212,  750, 1213, 1102,
      822,  822,  822,  822,  822,  822,  826,  827,  827,  827,
      827,  827,  827,  451, 1211,  952,  950,  828,  944, 1173,
       51, 1129,  828,  828,  828,  828,  828,  828,  730,  831,
      831,  831,  831,  831,  831,  831,  732,   51, 1215,  739,
      832,  940,   51,   51,   51,  832,  832,  832,  832,  832,
      832,  833,  834,  834,  834,  834,  834,  834,  451,   51,

       51,   51,  835, 1218, 1217,   51, 1222,  835,  835,  835,
      835,  835,  835,  739,  843,  843,  843,  843,  843,  843,
      843,  741,   51, 1220,  938,  844,  933,   51,   51,   51,
      844,  844,  844,  844,  844,  844,  845,  846,  846,  846,
      846,  846,  846,  451,   51,   51,   51,  847, 1225, 1229,
       51, 1161,  847,  847,  847,  847,  847,  847,  750,  858,
      858,  858,  858,  858,  858,  858,  752,   51, 1324, 1126,
      859,  730,   51,   51,  929,  859,  859,  859,  859,  859,
      859,  860,  861,  861,  861,  861,  861,  861,  451,   51,
       51, 1325,  862,  924, 1150,   51, 1123,  862,  862,  862,

      862,  862,  862,  667,  869,  869,  869,  869,  869,  869,
      869,  669,   51, 1326, 1327,  870, 1141, 1024, 1009, 1132,
      870,  870,  870,  870,  870,  870,  871,  872,  872,  872,
      872,  872,  872,  872,  873,   51,   51, 1144,  874, 1129,
      875,  956, 1126,  874,  874,  874,  874,  874,  874, 1132,
       51, 1145,   51,   51, 1040, 1041, 1041, 1041, 1041, 1041,
     1041,  993,  995,   51, 1144,  875,   51,   51,  903,  903,
      903,  903,  903,  903,  903, 1123, 1145, 1121, 1784,  903,
       51, 1097, 1092,   51,  903,  903,  903,  903,  903,  903,
      904,  904,  904,  904,  904,  904,  904, 1009, 1098,  871,

     1088,  904,   51, 1784,   51,   51,  904,  904,  904,  904,
      904,  904,  905,  906,  906,  906,  906,  906,  906,   51,
      873,   51,   51,  907,  667,  867,   51, 1107,  907,  907,
      907,  907,  907,  907,  263,  908,  908,  908,  908,  908,
      908,  908, 1328,   51,  865,  958,  909,  919, 1330,  946,
      916,  909,  909,  909,  909,  909,  909,   49,  909,  909,
      909,  909,  909,  909,  909,  730,  912,  912,  912,  912,
      912,  912,  912,  913,  935,  913,  926,  914, 1024,  734,
     1009,  919,  914,  914,  914,  914,  914,  914, 1048, 1049,
     1049, 1049, 1049, 1049, 1049, 1051, 1052, 1052, 1052, 1052,

     1052, 1052,  916,   51,  734,  739,  915,  915,  915,  915,
      915,  915,  915,  916,  913, 1009,  873,  917,  669,  743,
       51,  750,  917,  917,  917,  917,  917,  917, 1055, 1056,
     1056, 1056, 1056, 1056, 1056, 1064, 1065, 1065, 1065, 1065,
     1065, 1065,  958,   51,  743,  750,  918,  918,  918,  918,
      918,  918,  918,  919,  919,  548,  746,  920,  744,  754,
       51,  739,  920,  920,  920,  920,  920,  920, 1067, 1068,
     1068, 1068, 1068, 1068, 1068, 1071, 1072, 1072, 1072, 1072,
     1072, 1072, 1153,   51,  754,  924,  925,  925,  925,  925,
      925,  925,  925,  926,  946,  916, 1154,  927,  539,  928,

       51,   51,  927,  927,  927,  927,  927,  927,  963,  963,
      963,  963,  963,  963,  963, 1093, 1094,  735,   51,   51,
      730, 1154,   51,   51,  928,  730,  931,  931,  931,  931,
      931,  931,  931,  913, 1099,  935,   51,  932,  913,   51,
       51,   51,  932,  932,  932,  932,  932,  932,  933,  934,
      934,  934,  934,  934,  934,  934,  935, 1101,   51,   51,
      936,   51,  937, 1153,   51,  936,  936,  936,  936,  936,
      936, 1104,  926,  923, 1086, 1139,   51, 1784,   51,  825,
     1344,   51, 1088, 1353,   51, 1155,   51,  937,  739,  942,
      942,  942,  942,  942,  942,  942,  916, 1112, 1115, 1156,

      943,   51, 1784,   51,   51,  943,  943,  943,  943,  943,
      943,  944,  945,  945,  945,  945,  945,  945,  945,  946,
     1208,   51, 1155,  947, 1156,  948,  813,   51,  947,  947,
      947,  947,  947,  947, 1111,  919, 1784, 1049, 1049, 1049,
     1049, 1049, 1049, 1049,   51,  916, 1165,   51, 1165, 1342,
      948,  750,  954,  954,  954,  954,  954,  954,  954,  919,
     1166, 1784, 1784,  955,   51,  913,   51, 1510,  955,  955,
      955,  955,  955,  955,  956,  957,  957,  957,  957,  957,
      957,  957,  958,   51, 1167, 1166,  959, 1784,  960, 1167,
      911,  959,  959,  959,  959,  959,  959, 1207, 1168,  813,

      667,  873,  669, 1784, 1065, 1065, 1065, 1065, 1065, 1065,
     1065, 1177,  466,  960,  871,  971,  971,  971,  971,  971,
      971,  971,  873, 1168,  663, 1178,  972,  661, 1784,   51,
     1177,  972,  972,  972,  972,  972,  972,  973,  974,  974,
      974,  974,  974,  974, 1784,  752,   51,  725,  975,  741,
     1178,   51,  722,  975,  975,  975,  975,  975,  975,   51,
     1210, 1002, 1002, 1002, 1002, 1002, 1002, 1002,   51, 1784,
      732, 1511, 1002,   51,   51,   51,   51, 1002, 1002, 1002,
     1002, 1002, 1002, 1003, 1003, 1003, 1003, 1003, 1003, 1003,
       51,   51,   51,  825, 1003,  813, 1345, 1347, 1332, 1003,

     1003, 1003, 1003, 1003, 1003,  622, 1004, 1004, 1004, 1004,
     1004, 1004, 1004, 1148, 1179, 1179,  725, 1005,  722,  433,
      813, 1356, 1005, 1005, 1005, 1005, 1005, 1005, 1180, 1784,
     1189, 1190, 1190, 1190, 1190, 1190, 1190, 1192, 1193, 1193,
     1193, 1193, 1193, 1193,  433, 1005, 1005, 1005, 1005, 1005,
     1005, 1005,   49, 1180, 1784,   49, 1005,   49,   51,   51,
       51, 1005, 1005, 1005, 1005, 1005, 1005,  263, 1006, 1006,
     1006, 1006, 1006, 1006, 1006,   51,   51,   51,  800, 1007,
     1425, 1435, 1445,   49, 1007, 1007, 1007, 1007, 1007, 1007,
       49, 1007, 1007, 1007, 1007, 1007, 1007, 1007, 1010, 1011,

     1011, 1011, 1011, 1011, 1011,   49,  778,  669,  468, 1012,
      548,  752,   51,   51, 1012, 1012, 1012, 1012, 1012, 1012,
      730,  831,  831,  831,  831,  831,  831,  831,  913,   51,
       51,  725,  832,  362,  544,   51, 1313,  832,  832,  832,
      832,  832,  832, 1013, 1014, 1014, 1014, 1014, 1014, 1014,
     1314, 1442,   51, 1432, 1015,  539,  741,   51,  722, 1015,
     1015, 1015, 1015, 1015, 1015,  739,  843,  843,  843,  843,
      843,  843,  843,  916,   51, 1314, 1512,  844, 1513,   51,
       51, 1313,  844,  844,  844,  844,  844,  844, 1016, 1017,
     1017, 1017, 1017, 1017, 1017, 1784,   51,   51,  732, 1018,

      729, 1516,   51,  637, 1018, 1018, 1018, 1018, 1018, 1018,
      750,  858,  858,  858,  858,  858,  858,  858,  919,   51,
     1784,  628,  859, 1517,   51,   51, 1315,  859,  859,  859,
      859,  859,  859, 1019, 1020, 1020, 1020, 1020, 1020, 1020,
     1316,   51,   51,  725, 1021,  722, 1521, 1518,  720, 1021,
     1021, 1021, 1021, 1021, 1021, 1025, 1026, 1026, 1026, 1026,
     1026, 1026,  451,  628,  618, 1316, 1027,  616,  709,   51,
       51, 1027, 1027, 1027, 1027, 1027, 1027,  924, 1030, 1030,
     1030, 1030, 1030, 1030, 1030,  926,   51,   51, 1524, 1031,
      708,   51, 1526,   51, 1031, 1031, 1031, 1031, 1031, 1031,

     1032, 1033, 1033, 1033, 1033, 1033, 1033,  451,   51,  707,
       51, 1034, 1529,  706,   51,   51, 1034, 1034, 1034, 1034,
     1034, 1034,  933, 1042, 1042, 1042, 1042, 1042, 1042, 1042,
      935,   51,   51,  705, 1043,  704, 1591,   51,   51, 1043,
     1043, 1043, 1043, 1043, 1043, 1044, 1045, 1045, 1045, 1045,
     1045, 1045,  451, 1575,   51,   51, 1046, 1590,  703,  702,
       51, 1046, 1046, 1046, 1046, 1046, 1046,  944, 1057, 1057,
     1057, 1057, 1057, 1057, 1057,  946, 1583,   51, 1585, 1058,
      701,   51,   51,   51, 1058, 1058, 1058, 1058, 1058, 1058,
     1059, 1060, 1060, 1060, 1060, 1060, 1060,  451,   51,   51,

       51, 1061,  700,  699,   51, 1619, 1061, 1061, 1061, 1061,
     1061, 1061,  956, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
      958,   51,  698,  697, 1074,  694,   51,  689,   51, 1074,
     1074, 1074, 1074, 1074, 1074, 1075, 1076, 1076, 1076, 1076,
     1076, 1076,  451,   51, 1624,   51, 1077,  688, 1627,   51,
       51, 1077, 1077, 1077, 1077, 1077, 1077,  871, 1084, 1084,
     1084, 1084, 1084, 1084, 1084,  873,   51,   51,  687, 1085,
      686, 1634,   51, 1630, 1085, 1085, 1085, 1085, 1085, 1085,
     1086, 1087, 1087, 1087, 1087, 1087, 1087, 1087, 1088,   51,
      685,  684, 1089,   51, 1090,   51,   51, 1089, 1089, 1089,

     1089, 1089, 1089, 1196, 1197, 1197, 1197, 1197, 1197, 1197,
       51,  683,   51,   51,  682,  681,  680,   51,   51, 1090,
       51,  622, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1214,
      679, 1223, 1224, 1118,   51,   51,  678,   51, 1118, 1118,
     1118, 1118, 1118, 1118,   49, 1118, 1118, 1118, 1118, 1118,
     1118, 1118,   51,  263, 1119, 1119, 1119, 1119, 1119, 1119,
     1119,  677,   51,  676,  675,  674,   51, 1315,   51,   51,
      924, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1123,   51,
       51, 1784, 1124,   51,  928,   51,  673, 1124, 1124, 1124,
     1124, 1124, 1124, 1221, 1204,  672, 1205,   51,  466, 1159,

      669,  468,   51,   51,   51,  462, 1784, 1359, 1206,  928,
      933, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1126,   51,
       51,   51, 1127,  550,  937,   51, 1375, 1127, 1127, 1127,
     1127, 1127, 1127, 1171, 1216, 1219, 1331, 1183, 1249, 1319,
     1376, 1362,   51, 1226,   51, 1365, 1447, 1321,  534,  937,
      944, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1129, 1227,
     1228,   51, 1130, 1659,  948, 1376,  541, 1130, 1130, 1130,
     1130, 1130, 1130, 1255, 1256, 1256, 1256, 1256, 1256, 1256,
     1261, 1262, 1262, 1262, 1262, 1262, 1262,  637,   51,  948,
      956, 1131, 1131, 1131, 1131, 1131, 1131, 1131, 1132,  628,

      534,  628, 1133,  622,  960,   51,  622, 1133, 1133, 1133,
     1133, 1133, 1133, 1265, 1266, 1266, 1266, 1266, 1266, 1266,
     1271, 1272, 1272, 1272, 1272, 1272, 1272,   51,   51,  960,
     1135, 1136, 1136, 1136, 1136, 1136, 1136, 1137,  615,  614,
      613, 1138,  612,  611,   51,   51, 1138, 1138, 1138, 1138,
     1138, 1138, 1139, 1140, 1140, 1140, 1140, 1140, 1140, 1140,
     1141,  610, 1337, 1333, 1142,  609, 1143,  608,  607, 1142,
     1142, 1142, 1142, 1142, 1142, 1274, 1275, 1275, 1275, 1275,
     1275, 1275, 1278, 1279, 1279, 1279, 1279, 1279, 1279,   51,
       51, 1143,  924, 1146, 1146, 1146, 1146, 1146, 1146, 1146,

     1123,  606,  605,  335, 1147,  235,   51,   51,   51, 1147,
     1147, 1147, 1147, 1147, 1147, 1148, 1149, 1149, 1149, 1149,
     1149, 1149, 1149, 1150, 1338,   51, 1343, 1151, 1648, 1152,
      604,  603, 1151, 1151, 1151, 1151, 1151, 1151, 1285, 1286,
     1286, 1286, 1286, 1286, 1286, 1288, 1289, 1289, 1289, 1289,
     1289, 1289, 1375,   51, 1152,  933, 1157, 1157, 1157, 1157,
     1157, 1157, 1157, 1126,  602,  601, 1784, 1158,  600,  599,
       51,   51, 1158, 1158, 1158, 1158, 1158, 1158, 1159, 1160,
     1160, 1160, 1160, 1160, 1160, 1160, 1161, 1339,   51,  598,
     1162, 1784, 1163, 1675,  597, 1162, 1162, 1162, 1162, 1162,

     1162, 1292, 1293, 1293, 1293, 1293, 1293, 1293, 1299, 1300,
     1300, 1300, 1300, 1300, 1300, 1380,   51, 1163,  944, 1169,
     1169, 1169, 1169, 1169, 1169, 1169, 1129,  596,  595, 1381,
     1170,  594,  593,   51, 1429, 1170, 1170, 1170, 1170, 1170,
     1170, 1171, 1172, 1172, 1172, 1172, 1172, 1172, 1172, 1173,
      592, 1430,  591, 1174, 1381, 1175,  580,  577, 1174, 1174,
     1174, 1174, 1174, 1174, 1302, 1303, 1303, 1303, 1303, 1303,
     1303, 1306, 1307, 1307, 1307, 1307, 1307, 1307, 1380,   51,
     1175,  956, 1181, 1181, 1181, 1181, 1181, 1181, 1181, 1132,
      574,  573, 1784, 1182,  572,  571,   51,   51, 1182, 1182,

     1182, 1182, 1182, 1182, 1183, 1184, 1184, 1184, 1184, 1184,
     1184, 1184, 1185,  570,   51, 1433, 1186, 1784, 1187, 1676,
      569, 1186, 1186, 1186, 1186, 1186, 1186, 1190, 1190, 1190,
     1190, 1190, 1190, 1190, 1367, 1368, 1368, 1368, 1368, 1368,
     1368, 1382,   51, 1187, 1086, 1198, 1198, 1198, 1198, 1198,
     1198, 1198, 1088,  568,  567, 1383, 1199,  566,   51,   51,
     1382, 1199, 1199, 1199, 1199, 1199, 1199, 1200, 1201, 1201,
     1201, 1201, 1201, 1201, 1784,   51, 1434,  565, 1202, 1673,
     1383,   51,  468, 1202, 1202, 1202, 1202, 1202, 1202,   51,
      622, 1230, 1230, 1230, 1230, 1230, 1230, 1230,   51, 1784,

      275, 1650, 1007,  451,  362,  550,   51, 1007, 1007, 1007,
     1007, 1007, 1007,   49, 1007, 1007, 1007, 1007, 1007, 1007,
     1007,   51,  263, 1119, 1119, 1119, 1119, 1119, 1119, 1119,
     1272, 1272, 1272, 1272, 1272, 1272, 1272, 1388,   51, 1233,
     1234, 1234, 1234, 1234, 1234, 1234, 1319,  534,  541,  451,
     1235, 1389,  538,   51, 1784, 1235, 1235, 1235, 1235, 1235,
     1235,  924, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1123,
       51,  448,  442, 1031,  534,   51, 1389, 1388, 1031, 1031,
     1031, 1031, 1031, 1031, 1236, 1237, 1237, 1237, 1237, 1237,
     1237, 1784,   51,  532,  442, 1238,  434,  428,   51,  519,

     1238, 1238, 1238, 1238, 1238, 1238,  933, 1042, 1042, 1042,
     1042, 1042, 1042, 1042, 1126,   51, 1784,  518, 1043,  517,
     1684,   51, 1390, 1043, 1043, 1043, 1043, 1043, 1043, 1239,
     1240, 1240, 1240, 1240, 1240, 1240, 1391,  516,   51,  515,
     1241, 1651,  514,   51,  513, 1241, 1241, 1241, 1241, 1241,
     1241,  944, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1129,
       51, 1391,  512, 1058,  511,   51,   51, 1390, 1058, 1058,
     1058, 1058, 1058, 1058, 1242, 1243, 1243, 1243, 1243, 1243,
     1243, 1784,   51,   51,  510, 1244, 1657, 1693,   51,  509,
     1244, 1244, 1244, 1244, 1244, 1244,  956, 1073, 1073, 1073,

     1073, 1073, 1073, 1073, 1132,   51, 1784,  508, 1074,   51,
       51,  507,   51, 1074, 1074, 1074, 1074, 1074, 1074, 1245,
     1246, 1246, 1246, 1246, 1246, 1246,   51,   51, 1694,   51,
     1247,  506,  505,  502, 1574, 1247, 1247, 1247, 1247, 1247,
     1247, 1249, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1251,
       51,   51, 1396, 1252,  501, 1253,  498,  497, 1252, 1252,
     1252, 1252, 1252, 1252,  496,  495, 1397,   51,   51, 1286,
     1286, 1286, 1286, 1286, 1286, 1286, 1396,   51, 1329, 1334,
     1253, 1139, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1141,
     1784, 1397,  494, 1258,   51,  115,  493,   51, 1258, 1258,

     1258, 1258, 1258, 1258, 1148, 1267, 1267, 1267, 1267, 1267,
     1267, 1267, 1150, 1436,   51, 1784, 1268,  492,  491, 1695,
       51, 1268, 1268, 1268, 1268, 1268, 1268, 1159, 1280, 1280,
     1280, 1280, 1280, 1280, 1280, 1161,  479,   51,  478, 1281,
      477,  476, 1696,   51, 1281, 1281, 1281, 1281, 1281, 1281,
     1171, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1173,  475,
       51,  474, 1295,  473,  472, 1697,   51, 1295, 1295, 1295,
     1295, 1295, 1295, 1183, 1308, 1308, 1308, 1308, 1308, 1308,
     1308, 1185,  471,   51,  273, 1309,  468,  275, 1699,   51,
     1309, 1309, 1309, 1309, 1309, 1309, 1086, 1317, 1317, 1317,

     1317, 1317, 1317, 1317, 1088,  451,   51,  364, 1318, 1706,
      448,  442,   51, 1318, 1318, 1318, 1318, 1318, 1318, 1319,
     1320, 1320, 1320, 1320, 1320, 1320, 1320, 1321,   51,   51,
       51, 1322,   51, 1323,   51,   51, 1322, 1322, 1322, 1322,
     1322, 1322, 1335, 1398,  442,   51,  435,   51,  435,   51,
      427,   51,   51,  418,  417,  414,  413, 1399, 1323, 1336,
       51, 1340,   51, 1341, 1523, 1346,   51,  622,  524,  524,
      524,  524,  524,  524,  524,  412,   51,   51, 1398,   51,
     1404,   51, 1399,   51, 1348, 1349, 1349, 1349, 1349, 1349,
     1349, 1350, 1784,   51, 1405, 1351, 1439, 1527,   51, 1437,

     1351, 1351, 1351, 1351, 1351, 1351, 1139, 1352, 1352, 1352,
     1352, 1352, 1352, 1352, 1353,  411, 1438, 1784, 1354, 1405,
     1143,   51, 1404, 1354, 1354, 1354, 1354, 1354, 1354, 1300,
     1300, 1300, 1300, 1300, 1300, 1300, 1784,  410,   51,  409,
      408, 1406, 1406, 1455,  407, 1143, 1148, 1355, 1355, 1355,
     1355, 1355, 1355, 1355, 1356, 1407, 1784, 1456, 1357,   51,
     1152, 1784,   51, 1357, 1357, 1357, 1357, 1357, 1357, 1412,
     1413, 1413, 1413, 1413, 1413, 1413,   51,  406,  405,   51,
     1407, 1784, 1456,  404,   51, 1152, 1159, 1358, 1358, 1358,
     1358, 1358, 1358, 1358, 1359, 1572, 1441,  403, 1360,  402,

     1163,   51,  401, 1360, 1360, 1360, 1360, 1360, 1360, 1415,
     1416, 1416, 1416, 1416, 1416, 1416, 1419, 1420, 1420, 1420,
     1420, 1420, 1420,  400,   51, 1163, 1171, 1361, 1361, 1361,
     1361, 1361, 1361, 1361, 1362,   51,   51,   51, 1363,   51,
     1175,   51,  399, 1363, 1363, 1363, 1363, 1363, 1363,  398,
     1426,  397,   51,   51,   51,  392,   51, 1710,  391,   51,
       51, 1714, 1431, 1428,   51, 1175, 1183, 1364, 1364, 1364,
     1364, 1364, 1364, 1364, 1365,   51,   51,   51, 1366,  390,
     1187,   51, 1455, 1366, 1366, 1366, 1366, 1366, 1366, 1427,
      389, 1440,   51,  388, 1443,  317, 1784,  387,  386,   51,

       51, 1502,   51, 1444,  385, 1187, 1249, 1369, 1369, 1369,
     1369, 1369, 1369, 1369, 1251, 1503,   51,   51, 1370,   51,
     1712, 1784, 1716, 1370, 1370, 1370, 1370, 1370, 1370, 1139,
     1377, 1377, 1377, 1377, 1377, 1377, 1377, 1353, 1618,  384,
     1503, 1378,  383,  382,   51,   51, 1378, 1378, 1378, 1378,
     1378, 1378, 1148, 1384, 1384, 1384, 1384, 1384, 1384, 1384,
     1356,   51,   51,  376, 1385,  275,  364,   51,  271, 1385,
     1385, 1385, 1385, 1385, 1385, 1159, 1392, 1392, 1392, 1392,
     1392, 1392, 1392, 1359,   51, 1718, 1719, 1393,  361, 1728,
       51,   51, 1393, 1393, 1393, 1393, 1393, 1393, 1171, 1400,

     1400, 1400, 1400, 1400, 1400, 1400, 1362,   51,   51,  268,
     1401,  357, 1736, 1737,   51, 1401, 1401, 1401, 1401, 1401,
     1401, 1183, 1408, 1408, 1408, 1408, 1408, 1408, 1408, 1365,
      262,   51,  256, 1409,  138,  345, 1742,   51, 1409, 1409,
     1409, 1409, 1409, 1409, 1319, 1421, 1421, 1421, 1421, 1421,
     1421, 1421, 1321,  344,   51,  343, 1422,  338, 1743,   51,
       51, 1422, 1422, 1422, 1422, 1422, 1422, 1249, 1446, 1446,
     1446, 1446, 1446, 1446, 1446, 1447,   51,   51,  317, 1448,
      337, 1253, 1746,  336, 1448, 1448, 1448, 1448, 1448, 1448,
     1461, 1462, 1462, 1462, 1462, 1462, 1462, 1466, 1467, 1467,

     1467, 1467, 1467, 1467, 1502,   51, 1253, 1139, 1257, 1257,
     1257, 1257, 1257, 1257, 1257, 1353,  335,  334, 1784, 1258,
      333,  332,   51,   51, 1258, 1258, 1258, 1258, 1258, 1258,
     1148, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1356, 1509,
       51,  331, 1268, 1784,  330,   51,   51, 1268, 1268, 1268,
     1268, 1268, 1268, 1159, 1280, 1280, 1280, 1280, 1280, 1280,
     1280, 1359,   51,   51,  329, 1281, 1749,  328,   51,  327,
     1281, 1281, 1281, 1281, 1281, 1281, 1171, 1294, 1294, 1294,
     1294, 1294, 1294, 1294, 1362,   51, 1750,  326, 1295,  325,
     1756,   51,   51, 1295, 1295, 1295, 1295, 1295, 1295, 1183,

     1308, 1308, 1308, 1308, 1308, 1308, 1308, 1365,   51,   51,
      324, 1309,  323,  320, 1764,   51, 1309, 1309, 1309, 1309,
     1309, 1309, 1249, 1457, 1457, 1457, 1457, 1457, 1457, 1457,
     1447,  319,   51,  318, 1458,  317,  316,  315,  314, 1458,
     1458, 1458, 1458, 1458, 1458, 1469, 1470, 1470, 1470, 1470,
     1470, 1470, 1475, 1476, 1476, 1476, 1476, 1476, 1476, 1478,
     1479, 1479, 1479, 1479, 1479, 1479, 1484, 1485, 1485, 1485,
     1485, 1485, 1485, 1487, 1488, 1488, 1488, 1488, 1488, 1488,
     1493, 1494, 1494, 1494, 1494, 1494, 1494, 1496, 1497, 1497,
     1497, 1497, 1497, 1497, 1413, 1413, 1413, 1413, 1413, 1413,

     1413, 1504, 1504,   51,   51,   51,   51,   51,   51,   51,
      313,  312,   51, 1544, 1544, 1505, 1784, 1548, 1548,   51,
       51,   51,   51,   51,   51,   51,   51, 1545, 1784,   51,
     1771, 1549, 1784, 1519, 1514, 1515,   51, 1522, 1528, 1520,
     1505, 1784, 1319, 1506, 1506, 1506, 1506, 1506, 1506, 1506,
     1321, 1525, 1545, 1784, 1507,  311, 1549, 1784,   51, 1507,
     1507, 1507, 1507, 1507, 1507, 1249, 1369, 1369, 1369, 1369,
     1369, 1369, 1369, 1447,  310,   51,  309, 1370, 1773,  308,
      307,  306, 1370, 1370, 1370, 1370, 1370, 1370, 1538, 1539,
     1539, 1539, 1539, 1539, 1539, 1467, 1467, 1467, 1467, 1467,

     1467, 1467, 1476, 1476, 1476, 1476, 1476, 1476, 1476, 1552,
     1552, 1485, 1485, 1485, 1485, 1485, 1485, 1485, 1556, 1556,
     1560, 1560,  305, 1553, 1784, 1494, 1494, 1494, 1494, 1494,
     1494, 1494, 1557, 1784, 1561, 1784, 1564, 1565, 1565, 1565,
     1565, 1565, 1565,  304,   51,   51,   51,  303, 1553, 1784,
     1567, 1568, 1568, 1568, 1568, 1568, 1568, 1557, 1784, 1561,
     1784,   51,   51,   51,   51,   51,   51,   51,   51,   51,
     1573,   51,   51, 1576,  302,  301, 1577,   51,   51,  300,
      299,   51,   51,   51,   51,   51,   51, 1593,   51,   51,
     1578, 1579, 1580, 1581,   51,   51, 1593, 1584, 1586, 1582,

      298, 1594,  297,  296,  295, 1587,  294, 1589,  293,  138,
     1784, 1588, 1595, 1596, 1596, 1596, 1596, 1596, 1596, 1599,
     1600, 1600, 1600, 1600, 1600, 1600, 1594, 1603, 1604, 1604,
     1604, 1604, 1604, 1604,  292, 1784, 1607, 1608, 1608, 1608,
     1608, 1608, 1608, 1611, 1612, 1612, 1612, 1612, 1612, 1612,
     1565, 1565, 1565, 1565, 1565, 1565, 1565, 1615, 1615,   51,
       51,   51,   51,   51,   51,   51,   51,   51,  291,   51,
       51, 1616, 1784,   51,   51,   51,   51,   51,   51,   51,
       51,   51,   51,   51,   51, 1620,   51,   51, 1628,  290,
       51,   51,   51, 1633, 1631, 1622, 1616, 1784, 1621, 1623,

     1625, 1658, 1705, 1626, 1649, 1629, 1632, 1635, 1636, 1636,
     1636, 1636, 1636, 1636, 1596, 1596, 1596, 1596, 1596, 1596,
     1596, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1604, 1604,
     1604, 1604, 1604, 1604, 1604, 1608, 1608, 1608, 1608, 1608,
     1608, 1608, 1612, 1612, 1612, 1612, 1612, 1612, 1612, 1644,
     1645, 1645, 1645, 1645, 1645, 1645,   51,   51,  289,   51,
       51,   51,   51,   51, 1636, 1636, 1636, 1636, 1636, 1636,
     1636,   51,  288,   51,   51, 1652,   51,   51,   51,   51,
       51, 1645, 1645, 1645, 1645, 1645, 1645, 1645,   51,   51,
     1647,   51, 1653,   51,   51, 1654, 1655, 1656, 1660,   51,

       51,   51,   51,  287,   51,   51,   51, 1668,   51,   51,
       51,   51,   51,  286,  285, 1669,   51,   51,   51,   51,
     1678,   51,   51,   51, 1671, 1670,   51,   51,   51,   51,
     1672, 1674, 1680, 1679,   51,   51,   51, 1677,  284,   51,
       51, 1683,   51,  283,   51,   51,   51, 1685,  282,  281,
     1686,   51,   51,   51,  280, 1688,   51,   51, 1689,   51,
     1700, 1687,  279,   51,   51, 1698, 1692,   51, 1690,   51,
       51, 1691,   51,   51,   51,   51,   51, 1701, 1702, 1703,
     1704,   51,   51,   51,   51,  278,   51,   51,   51,   51,
       51, 1707,   51,   51,  275,   51,   51, 1717, 1708,   51,

       51, 1709, 1721, 1711, 1713,   51,  263, 1715,   51, 1722,
       51, 1720,   51,   51,  268,   51,   51, 1727,   51,   51,
     1725, 1723, 1724, 1726,   51,   51,   51,   51, 1731,   51,
      255, 1729,   51,   51,  254,   51,   51,   51,  253,   51,
       51,   51, 1730,   51,  252, 1732,   51, 1734, 1739,   51,
     1738, 1733,  251,   51,   51, 1735,   51,   51,   51,   51,
     1740, 1741,   51,   51,   51,   51,   51,  250, 1744, 1745,
       51,   51, 1747,  249,  248,   51,   51,  247,   51,   51,
       51,   51,   51, 1748, 1751,   51,   51,  246,   51,   51,
     1752, 1753, 1755,   51, 1758,   51, 1757, 1754,  243, 1762,

       51, 1759,   51,   51, 1760,   51,   51,   51,   51,   51,
       51,   51,   51,  240,   51, 1761,   51,   51,   51, 1765,
       51,   51,   51, 1763,   51,   51,   51,   51,   51,   51,
     1766,   51,  237,   51, 1767,   51, 1775,   51,   51,   51,
       51, 1768, 1769, 1772,   51,   51, 1778, 1774,   51, 1770,
       51, 1776,   51,   51, 1777,  236,   51,   51,  235, 1779,
       51,  234,   51, 1782, 1783,   51,  231,   51,  230,   51,
       51,  229,  228,  227,  226, 1780,  225,   51,  224,  223,
      222, 1781,   42,  221,   42,   59,  220,   59,   59,   59,
       59,   59,   59,  147,  219,  147,  154,  154,  154,  267,

      267,  267,  276,  276,  276,  356,  356,  356,  359,  359,
      359,  360,  360,  360,  367,  367,  367,  365,  365,  365,
      371,  371,  371,  375,  218,  375,  441,  441,  441,  446,
      446,  446,  447,  447,  447,  456,  456,  456,  460,  217,
      460,  461,  461,  461,  369,  369,  216,  212,  369,  465,
      465,  465,  469,  469,  469,  359,  359,  359,  531,  531,
      531,  535,  535,  535,  536,  536,  536,  537,  537,  537,
      367,  367,  367,  542,  542,  542,  454,  454,  211,  201,
      454,  547,  547,  547,  551,  551,  551,  555,  200,  555,
      556,  556,  556,  560,  560,  560,  564,  199,  564,  627,

      627,  627,  456,  456,  456,  635,  635,  635,  636,  636,
      636,  644,  644,  644,  648,  194,  648,  651,  189,  651,
      652,  652,  652,  656,  656,  656,  660,  188,  660,  554,
      554,  187,  186,  554,  558,  558,  185,  184,  558,  666,
      666,  666,  670,  670,  670,  564,  564,  183,  564,  536,
      536,  536,  719,  719,  719,  723,  723,  723,  726,  726,
      726,  727,  727,  727,  728,  728,  728,  733,  733,  733,
      642,  642,  182,  181,  642,  738,  738,  738,  742,  742,
      742,  648,  648,  180,  648,  650,  650,  176,  175,  650,
      651,  651,  174,  651,  652,  652,  654,  654,  173,  172,

      654,  749,  749,  749,  753,  753,  753,  660,  660,  171,
      660,  757,  170,  757,  760,  169,  760,  761,  761,  761,
      765,  765,  765,  769,  168,  769,  812,  812,  812,  644,
      644,  644,  656,  656,  656,  823,  823,  823,  824,  824,
      824,  832,  832,  832,  836,  167,  836,  839,  166,  839,
      840,  840,  840,  844,  844,  844,  848,  165,  848,  851,
      164,  851,  854,  163,  854,  855,  855,  855,  859,  859,
      859,  863,  162,  863,  756,  161,  160,  756,  757,  757,
      155,  757,  759,  759,  146,  145,  759,  760,  760,  140,
      760,  761,  761,  763,  763,   55,   52,  763,  870,  870,

      870,  874,  874,  874,  769,  769,   43,  769,   49,   49,
       49,   41,   49,   49,  727,  727,  727,  910,  910,  910,
      914,  914,  914,  917,  917,  917,  920,  920,  920,  921,
      921,  921,  922,  922,  922,  927,  927,  927,  830,  830,
     1784, 1784,  830,  932,  932,  932,  936,  936,  936,  836,
      836, 1784,  836,  838,  838, 1784, 1784,  838,  839,  839,
     1784,  839,  840,  840,  842,  842, 1784, 1784,  842,  943,
      943,  943,  947,  947,  947,  848,  848, 1784,  848,  850,
     1784, 1784,  850,  851,  851, 1784,  851,  853,  853, 1784,
     1784,  853,  854,  854, 1784,  854,  855,  855,  857,  857,

     1784, 1784,  857,  955,  955,  955,  959,  959,  959,  863,
      863, 1784,  863,  961, 1784,  961,  964, 1784,  964,  967,
     1784,  967,  968,  968,  968,  972,  972,  972,  976, 1784,
      976,   49,   49,   49, 1784,   49,   49, 1008, 1008, 1008,
      832,  832,  832,  844,  844,  844,  859,  859,  859, 1022,
     1022, 1022, 1023, 1023, 1023, 1031, 1031, 1031, 1035, 1784,
     1035, 1038, 1784, 1038, 1039, 1039, 1039, 1043, 1043, 1043,
     1047, 1784, 1047, 1050, 1784, 1050, 1053, 1784, 1053, 1054,
     1054, 1054, 1058, 1058, 1058, 1062, 1784, 1062, 1063, 1784,
     1063, 1066, 1784, 1066, 1069, 1784, 1069, 1070, 1070, 1070,

     1074, 1074, 1074, 1078, 1784, 1078,  961, 1784,  961,  963,
     1784, 1784,  963,  964,  964, 1784,  964,  966,  966, 1784,
     1784,  966,  967,  967, 1784,  967,  968,  968,  970,  970,
     1784, 1784,  970, 1085, 1085, 1085, 1089, 1089, 1089,  976,
      976, 1784,  976,   49,   49,   49, 1784,   49,   49,  921,
      921,  921, 1120, 1120, 1120, 1124, 1124, 1124, 1127, 1127,
     1127, 1130, 1130, 1130, 1133, 1133, 1133, 1134, 1134, 1134,
     1142, 1142, 1142, 1029, 1029, 1784, 1784, 1029, 1147, 1147,
     1147, 1151, 1151, 1151, 1035, 1035, 1784, 1035, 1037, 1037,
     1784, 1784, 1037, 1038, 1038, 1784, 1038, 1039, 1039, 1041,

     1041, 1784, 1784, 1041, 1158, 1158, 1158, 1162, 1162, 1162,
     1047, 1047, 1784, 1047, 1049, 1784, 1784, 1049, 1050, 1050,
     1784, 1050, 1052, 1052, 1784, 1784, 1052, 1053, 1053, 1784,
     1053, 1054, 1054, 1056, 1056, 1784, 1784, 1056, 1170, 1170,
     1170, 1174, 1174, 1174, 1062, 1062, 1784, 1062, 1063, 1784,
     1063, 1065, 1784, 1784, 1065, 1066, 1066, 1784, 1066, 1068,
     1068, 1784, 1784, 1068, 1069, 1069, 1784, 1069, 1070, 1070,
     1072, 1072, 1784, 1784, 1072, 1182, 1182, 1182, 1186, 1186,
     1186, 1078, 1078, 1784, 1078, 1188, 1784, 1188, 1191, 1784,
     1191, 1194, 1784, 1194, 1195, 1195, 1195, 1199, 1199, 1199,

     1203, 1784, 1203,   49,   49,   49, 1784,   49,   49, 1231,
     1231, 1231, 1031, 1031, 1031, 1043, 1043, 1043, 1058, 1058,
     1058, 1074, 1074, 1074, 1248, 1248, 1248, 1254, 1254, 1254,
     1252, 1252, 1252, 1259, 1259, 1259, 1258, 1258, 1258, 1260,
     1784, 1260, 1263, 1784, 1263, 1264, 1264, 1264, 1269, 1269,
     1269, 1268, 1268, 1268, 1270, 1784, 1270, 1273, 1784, 1273,
     1276, 1784, 1276, 1277, 1277, 1277, 1282, 1282, 1282, 1281,
     1281, 1281, 1283, 1784, 1283, 1284, 1784, 1284, 1287, 1784,
     1287, 1290, 1784, 1290, 1291, 1291, 1291, 1296, 1296, 1296,
     1295, 1295, 1295, 1297, 1784, 1297, 1298, 1784, 1298, 1301,

     1784, 1301, 1304, 1784, 1304, 1305, 1305, 1305, 1310, 1310,
     1310, 1309, 1309, 1309, 1311, 1784, 1311, 1188, 1784, 1188,
     1190, 1784, 1784, 1190, 1191, 1191, 1784, 1191, 1193, 1193,
     1784, 1784, 1193, 1194, 1194, 1784, 1194, 1195, 1195, 1197,
     1197, 1784, 1784, 1197, 1318, 1318, 1318, 1322, 1322, 1322,
     1203, 1203, 1784, 1203,   49,   49,   49, 1784,   49,   49,
     1134, 1134, 1134, 1354, 1354, 1354, 1357, 1357, 1357, 1360,
     1360, 1360, 1363, 1363, 1363, 1366, 1366, 1366, 1371, 1371,
     1371, 1370, 1370, 1370, 1373, 1784, 1373, 1374, 1374, 1374,
     1256, 1256, 1784, 1784, 1256, 1378, 1378, 1378, 1379, 1379,

     1379, 1260, 1260, 1784, 1260, 1262, 1262, 1784, 1784, 1262,
     1263, 1263, 1784, 1263, 1264, 1264, 1266, 1266, 1784, 1784,
     1266, 1385, 1385, 1385, 1386, 1386, 1386, 1270, 1270, 1784,
     1270, 1272, 1784, 1784, 1272, 1273, 1273, 1784, 1273, 1275,
     1275, 1784, 1784, 1275, 1276, 1276, 1784, 1276, 1277, 1277,
     1279, 1279, 1784, 1784, 1279, 1393, 1393, 1393, 1394, 1394,
     1394, 1283, 1283, 1784, 1283, 1284, 1784, 1284, 1286, 1784,
     1784, 1286, 1287, 1287, 1784, 1287, 1289, 1289, 1784, 1784,
     1289, 1290, 1290, 1784, 1290, 1291, 1291, 1293, 1293, 1784,
     1784, 1293, 1401, 1401, 1401, 1402, 1402, 1402, 1297, 1297,

     1784, 1297, 1298, 1784, 1298, 1300, 1784, 1784, 1300, 1301,
     1301, 1784, 1301, 1303, 1303, 1784, 1784, 1303, 1304, 1304,
     1784, 1304, 1305, 1305, 1307, 1307, 1784, 1784, 1307, 1409,
     1409, 1409, 1410, 1410, 1410, 1311, 1311, 1784, 1311, 1411,
     1784, 1411, 1414, 1784, 1414, 1417, 1784, 1417, 1418, 1418,
     1418, 1423, 1784, 1423, 1422, 1422, 1422, 1424, 1784, 1424,
       49,   49,   49, 1784,   49,   49, 1449, 1784, 1449, 1448,
     1448, 1448, 1450, 1784, 1450, 1258, 1258, 1258, 1451, 1784,
     1451, 1268, 1268, 1268, 1452, 1784, 1452, 1281, 1281, 1281,
     1453, 1784, 1453, 1295, 1295, 1295, 1454, 1784, 1454, 1309,

     1309, 1309, 1368, 1368, 1784, 1784, 1368, 1458, 1458, 1458,
     1459, 1459, 1459,  367,  367,  367, 1373, 1373, 1784, 1373,
     1460, 1460, 1460, 1463, 1784, 1463, 1464, 1464, 1464, 1465,
     1465, 1465, 1468, 1784, 1468, 1471, 1784, 1471, 1472, 1472,
     1472, 1473, 1473, 1473, 1474, 1784, 1474, 1477, 1784, 1477,
     1480, 1784, 1480, 1481, 1481, 1481, 1482, 1482, 1482, 1483,
     1784, 1483, 1486, 1784, 1486, 1489, 1784, 1489, 1490, 1490,
     1490, 1491, 1491, 1491, 1492, 1784, 1492, 1495, 1784, 1495,
     1498, 1784, 1498, 1499, 1499, 1499, 1500, 1500, 1500, 1411,
     1784, 1411, 1413, 1784, 1784, 1413, 1414, 1414, 1784, 1414,

     1416, 1416, 1784, 1784, 1416, 1417, 1417, 1784, 1417, 1418,
     1418, 1420, 1420, 1784, 1784, 1420, 1507, 1507, 1507, 1508,
     1784, 1508, 1424, 1424, 1784, 1424,   49,   49,   49, 1784,
       49,   49, 1530, 1530, 1530, 1370, 1370, 1370, 1532, 1784,
     1532, 1533, 1784, 1533, 1534, 1784, 1534, 1535, 1784, 1535,
     1536, 1784, 1536, 1537, 1784, 1537, 1540, 1784, 1540, 1541,
     1541, 1541, 1542, 1542, 1542, 1543, 1784, 1543, 1462, 1462,
     1784, 1784, 1462, 1463, 1463, 1784, 1463, 1464, 1464, 1546,
     1784, 1546, 1467, 1784, 1784, 1467, 1468, 1468, 1784, 1468,
     1470, 1470, 1784, 1784, 1470, 1471, 1471, 1784, 1471, 1472,

     1472, 1550, 1784, 1550, 1474, 1784, 1474, 1476, 1784, 1784,
     1476, 1477, 1477, 1784, 1477, 1479, 1479, 1784, 1784, 1479,
     1480, 1480, 1784, 1480, 1481, 1481, 1554, 1784, 1554, 1483,
     1784, 1483, 1485, 1784, 1784, 1485, 1486, 1486, 1784, 1486,
     1488, 1488, 1784, 1784, 1488, 1489, 1489, 1784, 1489, 1490,
     1490, 1558, 1784, 1558, 1492, 1784, 1492, 1494, 1784, 1784,
     1494, 1495, 1495, 1784, 1495, 1497, 1497, 1784, 1784, 1497,
     1498, 1498, 1784, 1498, 1499, 1499, 1562, 1784, 1562, 1563,
     1784, 1563, 1566, 1784, 1566, 1569, 1784, 1569, 1570, 1570,
     1570, 1571, 1784, 1571,   49,   49,   49, 1784,   49,   49,

     1592, 1784, 1592, 1460, 1784, 1460, 1465, 1784, 1465, 1473,
     1784, 1473, 1482, 1784, 1482, 1491, 1784, 1491, 1500, 1784,
     1500, 1539, 1539, 1784, 1784, 1539, 1540, 1540, 1784, 1540,
     1541, 1541, 1531, 1784, 1531, 1597, 1784, 1597, 1598, 1784,
     1598, 1601, 1784, 1601, 1602, 1784, 1602, 1605, 1784, 1605,
     1606, 1784, 1606, 1609, 1784, 1609, 1610, 1784, 1610, 1613,
     1784, 1613, 1565, 1784, 1784, 1565, 1568, 1568, 1784, 1784,
     1568, 1617, 1784, 1617, 1542, 1784, 1542, 1637, 1784, 1637,
     1596, 1784, 1784, 1596, 1600, 1784, 1784, 1600, 1604, 1784,
     1784, 1604, 1608, 1784, 1784, 1608, 1612, 1784, 1784, 1612,

     1643, 1784, 1643, 1646, 1784, 1646, 1636, 1784, 1784, 1636,
     1662, 1784, 1662, 1663, 1784, 1663, 1664, 1784, 1664, 1665,
     1784, 1665, 1666, 1784, 1666, 1645, 1784, 1784, 1645, 1681,
     1784, 1681, 1682, 1784, 1682,    3, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784
    } ;

```

This is a Wxgz7x platform available enclosure design for housing various components such as IP panels，冬冷夏暖煤化工风格药液柜，立可提料输送带，提升机，急速卷扬机，斗式提升机，输送机，带式输送机，刮板输送机，斗式刮板输送机，天车，吊车，行车，指环，千斤顶，固定式升降机，电动液压升降机，柴油发电机，内燃机，电动机，空压机，泵，电磁感应炉，单面电泳烘箱，双面电泳烘箱，立式真空干燥机，立式喷漆机，排铁机，电磁继电器，控制面板，传感器，执行器，按钮，启动器，保护器，PLC控制器，变频器，驱动器，PLC软件，单片机，LCD显示器，触摸屏，KES3800 Basic Program,KES3840 Control System,KES3880 Drive Connection,KES3890 Configuration Diagram,KES4860 System服务等。  此记录单元梦幻城娱乐平台




```cpp
static yyconst flex_int16_t yy_chk[7789] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   14,   14,   92,   11,   11,   11,   92,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   12,   16,   16,   20,   23,   20,

       20,   31,   23,  411,   20,   24,   24,   25,   23,   20,
       31,   23,   25,   20,   21,   20,   90,  411,   90,   12,
       17,   17,   17,   17,   17,   17,   17,   17,   21,   22,
       89, 1287,   26,   89,   17,   21,   26,   34,  101,   22,
       97,   34,   22,   27,  101,   27,   22,   93,   26,   34,
       27,   27,   93,   27,   34, 1290,   34,   27,  129,   17,
       18,   18,   18,   18,   18,   18,   18,   18,   18,   18,
       29,   29,   97,   18, 1291,   36,  129,   36,   18,   18,
       18,   18,   18,   18,   28,   29, 1295,   28,   28,   29,
       28,   36,   28,   29,   28,   29,   28,   30,   36,   28,

       33,   30,   29,   32,  150,   33,   33,  102,   33,   33,
       30,   30,  102,   38,   30,   32,   30,   32,   35,   32,
       98,   38,   32,  133,   35,   38,   35,   38,   35,  150,
      124,  218,   35,  133,   35,   35,   44,   44,   44,   44,
       44,   44,   44,  124,  218,  105,   98,   44,  105,  248,
      105,   98,   44,   44,   44,   44,   44,   44,   45,   45,
       45,   45,   45,   45,   45,  158,  247,  586,  247,   45,
      263,  263,  248,  586,   45,   45,   45,   45,   45,   45,
       46,   46,   46,   46,   46,   46,   46,   46,  676,  336,
      158,  676,   46,   78,  336,  270,  348,   46,   46,   46,

       46,   46,   46,   48,   48,   48,   48,   48,   48,   48,
       48,   50,   50,   50,   50,   50,   50,   50,  373,   78,
      270,  348,   50,  435,  435,   78, 1296,   50,   50,   50,
       50,   50,   50,   52,   52,   52,   52,   52,   52,   52,
      622,  622,  675,  373,   52,  673,  673,  675,  437,   52,
       52,   52,   52,   52,   52,   58,   58,   58,   58,   58,
       58,   58,  131,  262,  262,  262,  262,  262,  262,  262,
      352,  131,  148,  437,  148,  148,  148,  148,  148,  148,
      148,  444,  450, 1297,  352,  148,  280,  280,  280,  280,
      148,  148,  148,  148,  148,  148,  149,  149,  149,  149,

      149,  149,  149,  149,  464,  280,  444,  450,  149,  352,
      149, 1301,  464,  149,  149,  149,  149,  149,  149,  273,
      273,  273,  273,  273,  273,  273,  358,  358,  358,  358,
      358,  358,  358,  368,  690,  149,  151,  151,  151,  151,
      151,  151,  151,  151,  458,  522,  674,  368,  151,  562,
      630,  690,  674,  151,  151,  151,  151,  151,  151,  152,
      152,  152,  152,  152,  152,  152,  152,  152, 1304,  458,
      522,  152,  368,  633,  562,  630,  152,  152,  152,  152,
      152,  152,  153,  153,  153,  153,  153,  153,  153,  153,
      155,  155,  155,  155,  155,  155,  155,  155,  633,  686,

      686,  155,  565,  565,  565,  565,  155,  155,  155,  155,
      155,  155,  157,  157,  157,  157,  157,  157,  157,  157,
      157,  369,  639,  682,  157,  394,  157,  682,  305,  157,
      157,  157,  157,  157,  157,  369,  305,  362,  362,  362,
      362,  362,  362,  362, 1305,  394,  408,  639,  305,  678,
     1309,  157,  256,  256,  256,  256,  256,  256,  256,  408,
      369,  394,  646,  256,  305,  683, 1310,  678,  256,  256,
      256,  256,  256,  256,  258,  258,  258,  258,  258,  258,
      258,  546,  681,  683,  681,  258, 1311,  646,  658,  546,
      258,  258,  258,  258,  258,  258,  259,  259,  259,  259,

      259,  259,  259,  259,  261,  261,  261,  261,  261,  261,
      261,  556,  685,  658,  685,  261,  696,  696, 1318,  556,
      261,  261,  261,  261,  261,  261,  264,  264,  264,  264,
      264,  264,  264,  264,  665,  707,  707,  716,  264, 1322,
     1351,  714,  665,  264,  264,  264,  264,  264,  264,  266,
      266,  266,  266,  266,  266,  266,  266,  269,  269,  269,
      269,  269,  269,  269,  269,  269,  714, 1354, 1357,  269,
     1360,  269,  716,  453,  269,  269,  269,  269,  269,  269,
      434,  434,  434,  434,  434,  434,  434,  453,  688, 1363,
     1366, 1370,  684,  454,  526,  688,  269,  274,  274,  274,

      274,  274,  274,  274,  274,  274,  684,  454,  526,  274,
     1371,  770,  453,  689,  274,  274,  274,  274,  274,  274,
      275,  275,  275,  275,  275,  275,  275,  689,  770, 1372,
      755,  275,  454,  526,  484,  679,  275,  275,  275,  275,
      275,  275,  341,  484,  341,  679,  341,  341,  462,  462,
      462,  462,  462,  462,  462,  755,  341,  553,  341,  341,
      554,  341,  346,  486,  346,  346,  346,  346,  346,  346,
      346,  553,  486, 1373,  554,  346,  767, 1374,  772, 1378,
      346,  346,  346,  346,  346,  346,  347,  347,  347,  347,
      347,  347,  347,  347,  691,  772,  553, 1379,  347,  554,

      347,  767,  691,  347,  347,  347,  347,  347,  347,  466,
      466,  466,  466,  466,  466,  466,  539,  539,  539,  539,
      539,  539,  539,  557,  687,  347,  349,  349,  349,  349,
      349,  349,  349,  349,  697,  687,  815,  557,  349, 1385,
      782,  697,  558,  349,  349,  349,  349,  349,  349,  353,
      353,  353,  353,  353,  353,  353,  558,  782,  782,  818,
      353,  815,  557,  771,  693,  353,  353,  353,  353,  353,
      353,  354,  354,  354,  354,  354,  354,  354,  354,  693,
      771,  558, 1386,  354,  818,  821,  827,  771,  354,  354,
      354,  354,  354,  354,  355,  355,  355,  355,  355,  355,

      355,  355,  357,  357,  357,  357,  357,  357,  357,  834,
      821,  827,  846,  357, 1393, 1394,  778,  695,  357,  357,
      357,  357,  357,  357,  361,  361,  361,  361,  361,  361,
      361,  361,  695,  778,  834,  361, 1401,  846,  778,  779,
      361,  361,  361,  361,  361,  361,  363,  363,  363,  363,
      363,  363,  363,  363,  363, 1402,  779, 1409,  363,  779,
      786,  780,  791,  363,  363,  363,  363,  363,  363,  364,
      364,  364,  364,  364,  364,  364,  364,  786,  780,  791,
      364,  780,  786,  790,  791,  364,  364,  364,  364,  364,
      364,  370,  370,  370,  370,  370,  370,  370,  370,  370,

      790, 1410,  849,  370,  861,  906,  793,  790,  370,  370,
      370,  370,  370,  370,  372,  372,  372,  372,  372,  372,
      372,  372,  372,  793,  793, 1414,  372,  849,  372,  861,
      906,  372,  372,  372,  372,  372,  372,  544,  544,  544,
      544,  544,  544,  544,  548,  548,  548,  548,  548,  548,
      548,  587,  692,  372,  393,  962,  589,  974,  393, 1011,
      587,  393,  692,  641,  393,  589,  393,  393,  393,  393,
      428,  428,  428,  428,  428,  428,  428,  641, 1417, 1014,
      962,  428,  974,  796, 1011,  694,  428,  428,  428,  428,
      428,  428,  430,  430,  430,  430,  430,  430,  430,  694,

      796,  694,  641,  430, 1014,  796, 1017, 1020,  430,  430,
      430,  430,  430,  430,  431,  431,  431,  431,  431,  431,
      431,  431,  433,  433,  433,  433,  433,  433,  433,  737,
     1418, 1017, 1020,  433, 1422,  797, 1424,  737,  433,  433,
      433,  433,  433,  433,  436,  436,  436,  436,  436,  436,
      436,  436,  797,  642,  649,  650,  436,  653,  436,  654,
      706,  436,  436,  436,  436,  436,  436,  642,  649,  650,
      706,  653,  677,  654,  661,  661,  661,  661,  661,  661,
      661,  677, 1447,  436,  438,  438,  438,  438,  438,  438,
      438, 1026,  642,  649,  650,  438,  653,  798,  654,  698,

      438,  438,  438,  438,  438,  438,  439,  439,  439,  439,
      439,  439,  439,  698,  798, 1448, 1026,  439, 1458, 1459,
     1033, 1045,  439,  439,  439,  439,  439,  439,  440,  440,
      440,  440,  440,  440,  440,  440,  443,  443,  443,  443,
      443,  443,  443,  443,  443, 1033, 1045, 1463,  443, 1464,
      443, 1468, 1471,  443,  443,  443,  443,  443,  443,  663,
      663,  663,  663,  663,  663,  663,  667,  667,  667,  667,
      667,  667,  667,  699,  800,  443,  449,  449,  449,  449,
      449,  449,  449,  449,  449,  702,  705,  699,  449, 1472,
      449,  800, 1477,  449,  449,  449,  449,  449,  449,  702,

      705,  730,  730,  730,  730,  730,  730,  730,  735,  735,
      735,  735,  735,  735,  735,  449,  455,  455,  455,  455,
      455,  455,  455,  455,  455, 1048, 1480, 1481,  455, 1060,
     1064,  801,  799,  455,  455,  455,  455,  455,  455,  457,
      457,  457,  457,  457,  457,  457,  457,  457,  801,  799,
     1048,  457,  799,  457, 1060, 1064,  457,  457,  457,  457,
      457,  457,  739,  739,  739,  739,  739,  739,  739,  744,
      744,  744,  744,  744,  744,  744,  758,  773,  457,  467,
      467,  467,  467,  467,  467,  467,  467,  467, 1486, 1489,
      758,  467, 1490,  774,  773,  783,  467,  467,  467,  467,

      467,  467,  468,  468,  468,  468,  468,  468,  468,  748,
      774,  773,  783,  468,  759,  758, 1495,  748,  468,  468,
      468,  468,  468,  468,  488,  488,  488,  774,  759,  488,
      488,  783, 1498,  488,  488,  805,  488,  762,  488, 1499,
      488,  520,  763,  520,  520,  520,  520,  520,  520,  520,
     1076,  762,  805,  759,  520, 1136,  763,  807,  807,  520,
      520,  520,  520,  520,  520,  521,  521,  521,  521,  521,
      521,  521,  521, 1507,  807, 1076,  762,  521, 1540,  521,
     1136,  763,  521,  521,  521,  521,  521,  521,  746,  746,
      746,  746,  746,  746,  746,  750,  750,  750,  750,  750,

      750,  750,  775,  777,  521,  523,  523,  523,  523,  523,
      523,  523,  523,  869, 1189, 1541, 1201,  523, 1234,  775,
      777,  869,  523,  523,  523,  523,  523,  523,  527,  527,
      527,  527,  527,  527,  527,  527,  775,  777, 1566, 1189,
      527, 1201, 1237, 1234, 1240,  527,  527,  527,  527,  527,
      527,  528,  528,  528,  528,  528,  528,  528,  528,  529,
      529,  529,  529,  529,  529,  529,  931, 1237, 1569, 1240,
      529, 1243, 1246, 1271,  931,  529,  529,  529,  529,  529,
      529,  530,  530,  530,  530,  530,  530,  530,  530,  532,
      532,  532,  532,  532,  532,  532, 1243, 1246, 1271, 1285,

      532, 1597, 1601,  876,  877,  532,  532,  532,  532,  532,
      532,  533,  533,  533,  533,  533,  533,  533,  533,  533,
      876,  877, 1605,  533, 1285,  878,  877,  829,  533,  533,
      533,  533,  533,  533,  534,  534,  534,  534,  534,  534,
      534,  829,  878, 1299, 1349,  534, 1609,  878,  879, 1613,
      534,  534,  534,  534,  534,  534,  538,  538,  538,  538,
      538,  538,  538,  538, 1412,  879,  829,  538, 1299, 1349,
      879,  881,  538,  538,  538,  538,  538,  538,  540,  540,
      540,  540,  540,  540,  540,  540,  540, 1637,  881, 1412,
      540, 1646,  883,  881,  884,  540,  540,  540,  540,  540,

      540,  541,  541,  541,  541,  541,  541,  541,  541,  883,
     1283,  884,  541, 1282,  883,  890,  884,  541,  541,  541,
      541,  541,  541,  549,  549,  549,  549,  549,  549,  549,
      549,  549,  890,  890, 1466,  549, 1281,  891,  886,  902,
      549,  549,  549,  549,  549,  549,  550,  550,  550,  550,
      550,  550,  550,  550,  891,  886,  902,  550,  886, 1466,
      896,  891,  550,  550,  550,  550,  550,  550,  559,  559,
      559,  559,  559,  559,  559,  559,  559,  896, 1277, 1276,
      559, 1273,  896,  994,  899,  559,  559,  559,  559,  559,
      559,  561,  561,  561,  561,  561,  561,  561,  561,  561,

      994,  899,  994,  561,  784,  561,  899,  785,  561,  561,
      561,  561,  561,  561,  756,  756,  756,  756,  756,  756,
      756,  784, 1001, 1270,  785, 1269,  789,  795,  880,  885,
      561,  616,  616,  616,  616,  616,  616,  616,  785, 1001,
      784, 1475,  616,  789,  795,  880,  885,  616,  616,  616,
      616,  616,  616,  618,  618,  618,  618,  618,  618,  618,
      880,  885,  789,  795,  618, 1268, 1475, 1484, 1493,  618,
      618,  618,  618,  618,  618,  619,  619,  619,  619,  619,
      619,  619,  619,  621,  621,  621,  621,  621,  621,  621,
      942, 1264, 1484, 1493,  621,  894,  900,  981,  942,  621,

      621,  621,  621,  621,  621,  623,  623,  623,  623,  623,
      623,  623,  894,  900,  981, 1263,  623,  981,  900, 1564,
      894,  623,  623,  623,  623,  623,  623,  624,  624,  624,
      624,  624,  624,  624,  624,  625,  625,  625,  625,  625,
      625,  625,  954, 1260, 1564, 1259,  625, 1258, 1254, 1252,
      954,  625,  625,  625,  625,  625,  625,  626,  626,  626,
      626,  626,  626,  626,  626,  629,  629,  629,  629,  629,
      629,  629,  629,  629,  776,  787,  788,  629, 1251,  629,
      993,  830,  629,  629,  629,  629,  629,  629, 1084, 1248,
     1247,  776,  787,  788, 1244,  830, 1084,  993,  882,  781,

      993,  787,  788,  776,  629,  632,  632,  632,  632,  632,
      632,  632,  632,  632,  792,  882,  781,  632,  984,  632,
      830, 1146,  632,  632,  632,  632,  632,  632,  781, 1146,
     1241,  792,  882, 1595, 1238,  984, 1599, 1235,  802, 1231,
      984,  792,  837,  794,  632,  638,  638,  638,  638,  638,
      638,  638,  638,  638,  803,  802,  837,  638, 1595,  638,
      794, 1599,  638,  638,  638,  638,  638,  638,  802,  794,
     1603,  803,  809,  809,  809,  809,  809,  809,  809, 1203,
      838,  837,  841,  803,  638,  643,  643,  643,  643,  643,
      643,  643,  643,  643,  838, 1603,  841,  643, 1202, 1199,

     1000, 1195,  643,  643,  643,  643,  643,  643,  645,  645,
      645,  645,  645,  645,  645,  645,  645, 1000,  842,  838,
      645,  841,  645, 1157,  889,  645,  645,  645,  645,  645,
      645, 1157,  842,  850,  850,  850,  850,  850,  850,  850,
     1000,  889, 1194, 1191,  987,  852, 1002,  645,  655,  655,
      655,  655,  655,  655,  655,  655,  655,  842,  889,  852,
      655,  987,  987, 1002, 1186,  655,  655,  655,  655,  655,
      655,  657,  657,  657,  657,  657,  657,  657,  657,  657,
      892,  853,  856,  657,  852,  657,  857, 1185,  657,  657,
      657,  657,  657,  657, 1182,  853,  856,  892, 1174, 1607,

      857,  865,  865,  865,  865,  865,  865,  865,  892,  887,
      657,  668,  668,  668,  668,  668,  668,  668,  668,  668,
      853,  856, 1173,  668, 1607,  857,  887,  901,  668,  668,
      668,  668,  668,  668,  669,  669,  669,  669,  669,  669,
      669,  887, 1170, 1162,  901,  669, 1161,  989,  992, 1003,
      669,  669,  669,  669,  669,  669,  672,  672,  672,  672,
      672,  672,  672,  901,  989,  992, 1003,  672,  898,  989,
      992,  897,  672,  672,  672,  672,  672,  672,  867,  867,
      867,  867,  867,  867,  867,  898, 1158,  965,  897,  966,
      672,  710,  969,  710,  710,  710,  710,  710,  710,  710,

      897,  965,  898,  966,  710, 1151,  969,  997,  998,  710,
      710,  710,  710,  710,  710,  711,  711,  711,  711,  711,
      711,  711,  711, 1150,  997,  998,  965,  711,  966,  997,
      998,  969,  711,  711,  711,  711,  711,  711,  712,  712,
      712,  712,  712,  712,  712,  871,  871,  871,  871,  871,
      871,  871,  980,  977,  888,  924,  924,  924,  924,  924,
      924,  924,  929,  929,  929,  929,  929,  929,  929,  980,
      977,  888,  712,  713,  713,  713,  713,  713,  713,  713,
      888, 1147, 1142, 1141,  713,  977,  980, 1611, 1635,  713,
      713,  713,  713,  713,  713,  715,  715,  715,  715,  715,

      715,  715,  715,  717,  717,  717,  717,  717,  717,  717,
      717, 1169, 1611, 1635, 1138,  717, 1644, 1137, 1134, 1169,
      717,  717,  717,  717,  717,  717,  718,  718,  718,  718,
      718,  718,  718,  718,  720,  720,  720,  720,  720,  720,
      720, 1644, 1133, 1130, 1127,  720, 1124, 1120, 1007, 1094,
      720,  720,  720,  720,  720,  720,  721,  721,  721,  721,
      721,  721,  721,  721,  721, 1007, 1094, 1089,  721, 1085,
      990, 1097,  970,  721,  721,  721,  721,  721,  721,  722,
      722,  722,  722,  722,  722,  722,  970,  990, 1097, 1078,
      722, 1077, 1097, 1102,  990,  722,  722,  722,  722,  722,

      722,  724,  724,  724,  724,  724,  724,  724,  724,  724,
     1102,  970, 1074,  724,  986, 1100, 1101, 1099,  724,  724,
      724,  724,  724,  724,  725,  725,  725,  725,  725,  725,
      725,  986, 1100, 1101, 1099,  725, 1100, 1070, 1101,  986,
      725,  725,  725,  725,  725,  725,  729,  729,  729,  729,
      729,  729,  729,  729, 1099, 1069, 1066,  729, 1062, 1061,
     1104, 1058,  729,  729,  729,  729,  729,  729,  731,  731,
      731,  731,  731,  731,  731,  731,  731, 1104, 1104, 1054,
      731, 1053, 1106, 1111, 1107,  731,  731,  731,  731,  731,
      731,  732,  732,  732,  732,  732,  732,  732,  732, 1106,

     1111, 1107,  732, 1107, 1106, 1109, 1111,  732,  732,  732,
      732,  732,  732,  740,  740,  740,  740,  740,  740,  740,
      740,  740, 1109, 1109, 1050,  740, 1047, 1204, 1114, 1116,
      740,  740,  740,  740,  740,  740,  741,  741,  741,  741,
      741,  741,  741,  741, 1204, 1114, 1116,  741, 1114, 1116,
     1205, 1046,  741,  741,  741,  741,  741,  741,  751,  751,
      751,  751,  751,  751,  751,  751,  751, 1205, 1204, 1043,
      751, 1039, 1206, 1208, 1038,  751,  751,  751,  751,  751,
      751,  752,  752,  752,  752,  752,  752,  752,  752, 1206,
     1208, 1205,  752, 1035, 1034, 1207, 1031,  752,  752,  752,

      752,  752,  752,  764,  764,  764,  764,  764,  764,  764,
      764,  764, 1207, 1206, 1207,  764, 1027, 1023, 1022, 1021,
      764,  764,  764,  764,  764,  764,  766,  766,  766,  766,
      766,  766,  766,  766,  766,  893,  895, 1028,  766, 1018,
      766, 1181, 1015,  766,  766,  766,  766,  766,  766, 1181,
      978, 1028,  893,  895,  933,  933,  933,  933,  933,  933,
      933,  893,  895,  982, 1029,  766,  804,  978,  804,  804,
      804,  804,  804,  804,  804, 1012, 1028, 1009, 1029,  804,
      982,  982,  978,  804,  804,  804,  804,  804,  804,  804,
      806,  806,  806,  806,  806,  806,  806, 1008,  982,  976,

      975,  806,  991, 1029, 1209, 1212,  806,  806,  806,  806,
      806,  806,  808,  808,  808,  808,  808,  808,  808,  991,
      972, 1209, 1212,  808,  968,  967, 1211,  991,  808,  808,
      808,  808,  808,  808,  810,  810,  810,  810,  810,  810,
      810,  810, 1209, 1211,  964,  959,  810,  955, 1211,  947,
      943,  810,  810,  810,  810,  810,  810,  811,  811,  811,
      811,  811,  811,  811,  811,  814,  814,  814,  814,  814,
      814,  814,  814,  814,  936,  932,  927,  814,  922,  814,
      921,  920,  814,  814,  814,  814,  814,  814,  938,  938,
      938,  938,  938,  938,  938,  940,  940,  940,  940,  940,

      940,  940,  917, 1324,  814,  817,  817,  817,  817,  817,
      817,  817,  817,  817,  914,  910,  874,  817,  870,  817,
     1324,  863,  817,  817,  817,  817,  817,  817,  944,  944,
      944,  944,  944,  944,  944,  950,  950,  950,  950,  950,
      950,  950,  862, 1325,  817,  820,  820,  820,  820,  820,
      820,  820,  820,  820,  859,  855,  854,  820,  851,  820,
     1325,  848,  820,  820,  820,  820,  820,  820,  952,  952,
      952,  952,  952,  952,  952,  956,  956,  956,  956,  956,
      956,  956, 1036,  979,  820,  826,  826,  826,  826,  826,
      826,  826,  826,  826,  847,  844, 1036,  826,  840,  826,

      979,  983,  826,  826,  826,  826,  826,  826,  963,  963,
      963,  963,  963,  963,  963,  979,  979,  839,  983, 1326,
      836, 1036, 1327,  985,  826,  831,  831,  831,  831,  831,
      831,  831,  831,  831,  983,  835, 1326,  831,  832, 1327,
      985,  988,  831,  831,  831,  831,  831,  831,  833,  833,
      833,  833,  833,  833,  833,  833,  833,  985,  988, 1226,
      833,  996,  833, 1037,  999,  833,  833,  833,  833,  833,
      833,  988,  828,  825, 1317, 1377, 1226, 1037,  996,  824,
     1226,  999, 1317, 1377, 1096, 1040, 1343,  833,  843,  843,
      843,  843,  843,  843,  843,  843,  843,  996,  999, 1040,

      843, 1096, 1037, 1343,  995,  843,  843,  843,  843,  843,
      843,  845,  845,  845,  845,  845,  845,  845,  845,  845,
     1096,  995, 1041,  845, 1040,  845,  823, 1224,  845,  845,
      845,  845,  845,  845,  995,  822, 1041, 1049, 1049, 1049,
     1049, 1049, 1049, 1049, 1224,  819, 1051, 1426, 1052, 1224,
      845,  858,  858,  858,  858,  858,  858,  858,  858,  858,
     1051, 1041, 1052,  858, 1426,  816, 1095, 1426,  858,  858,
      858,  858,  858,  858,  860,  860,  860,  860,  860,  860,
      860,  860,  860, 1095, 1055, 1051,  860, 1052,  860, 1056,
      813,  860,  860,  860,  860,  860,  860, 1095, 1055,  812,

      769,  768,  765, 1056, 1065, 1065, 1065, 1065, 1065, 1065,
     1065, 1067,  761,  860,  872,  872,  872,  872,  872,  872,
      872,  872,  872, 1055,  760, 1067,  872,  757, 1056, 1098,
     1068,  872,  872,  872,  872,  872,  872,  873,  873,  873,
      873,  873,  873,  873, 1068,  753, 1098,  749,  873,  742,
     1067, 1427,  738,  873,  873,  873,  873,  873,  873,  903,
     1098,  903,  903,  903,  903,  903,  903,  903, 1427, 1068,
      733, 1427,  903, 1214, 1227, 1229,  903,  903,  903,  903,
      903,  903,  903,  904,  904,  904,  904,  904,  904,  904,
     1214, 1227, 1229,  728,  904,  727, 1227, 1229, 1214,  904,

      904,  904,  904,  904,  904,  905,  905,  905,  905,  905,
      905,  905,  905, 1384, 1071, 1072,  726,  905,  723,  905,
      719, 1384,  905,  905,  905,  905,  905,  905, 1071, 1072,
     1080, 1080, 1080, 1080, 1080, 1080, 1080, 1082, 1082, 1082,
     1082, 1082, 1082, 1082,  905,  907,  907,  907,  907,  907,
      907,  907,  709, 1071, 1072,  708,  907,  704, 1328, 1337,
     1347,  907,  907,  907,  907,  907,  907,  908,  908,  908,
      908,  908,  908,  908,  908, 1328, 1337, 1347,  703,  908,
     1328, 1337, 1347,  701,  908,  908,  908,  908,  908,  908,
      909,  909,  909,  909,  909,  909,  909,  909,  911,  911,

      911,  911,  911,  911,  911,  700,  680,  670,  666,  911,
      660,  659, 1334, 1344,  911,  911,  911,  911,  911,  911,
      912,  912,  912,  912,  912,  912,  912,  912,  912, 1334,
     1344,  656,  912,  652,  651, 1428, 1192,  912,  912,  912,
      912,  912,  912,  913,  913,  913,  913,  913,  913,  913,
     1192, 1344, 1428, 1334,  913,  648,  647, 1429,  644,  913,
      913,  913,  913,  913,  913,  915,  915,  915,  915,  915,
      915,  915,  915,  915, 1429, 1192, 1428,  915, 1429, 1432,
     1433, 1193,  915,  915,  915,  915,  915,  915,  916,  916,
      916,  916,  916,  916,  916, 1193, 1432, 1433,  640,  916,

      637, 1433, 1434,  636,  916,  916,  916,  916,  916,  916,
      918,  918,  918,  918,  918,  918,  918,  918,  918, 1434,
     1193,  635,  918, 1434, 1435, 1437, 1196,  918,  918,  918,
      918,  918,  918,  919,  919,  919,  919,  919,  919,  919,
     1196, 1435, 1437,  634,  919,  631, 1437, 1435,  628,  919,
      919,  919,  919,  919,  919,  923,  923,  923,  923,  923,
      923,  923,  923,  627,  620, 1196,  923,  617,  615, 1440,
     1442,  923,  923,  923,  923,  923,  923,  925,  925,  925,
      925,  925,  925,  925,  925,  925, 1440, 1442, 1440,  925,
      611, 1445, 1442, 1512,  925,  925,  925,  925,  925,  925,

      926,  926,  926,  926,  926,  926,  926,  926, 1445,  605,
     1512,  926, 1445,  604, 1529, 1513,  926,  926,  926,  926,
      926,  926,  934,  934,  934,  934,  934,  934,  934,  934,
      934, 1529, 1513,  603,  934,  602, 1529, 1528, 1521,  934,
      934,  934,  934,  934,  934,  935,  935,  935,  935,  935,
      935,  935,  935, 1513, 1528, 1521,  935, 1528,  598,  597,
     1523,  935,  935,  935,  935,  935,  935,  945,  945,  945,
      945,  945,  945,  945,  945,  945, 1521, 1523, 1523,  945,
      594, 1572, 1574, 1575,  945,  945,  945,  945,  945,  945,
      946,  946,  946,  946,  946,  946,  946,  946, 1572, 1574,

     1575,  946,  593,  592, 1580, 1575,  946,  946,  946,  946,
      946,  946,  957,  957,  957,  957,  957,  957,  957,  957,
      957, 1580,  591,  590,  957,  588, 1583,  585, 1589,  957,
      957,  957,  957,  957,  957,  958,  958,  958,  958,  958,
      958,  958,  958, 1583, 1580, 1589,  958,  584, 1583, 1586,
     1591,  958,  958,  958,  958,  958,  958,  971,  971,  971,
      971,  971,  971,  971,  971,  971, 1586, 1591,  583,  971,
      582, 1591, 1618, 1586,  971,  971,  971,  971,  971,  971,
      973,  973,  973,  973,  973,  973,  973,  973,  973, 1618,
      581,  580,  973, 1103,  973, 1112, 1113,  973,  973,  973,

      973,  973,  973, 1086, 1086, 1086, 1086, 1086, 1086, 1086,
     1103,  579, 1112, 1113,  578,  577,  576, 1630, 1632,  973,
     1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1004, 1103,
      575, 1112, 1113, 1004, 1630, 1632,  574, 1004, 1004, 1004,
     1004, 1004, 1004, 1004, 1005, 1005, 1005, 1005, 1005, 1005,
     1005, 1005, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006,
     1006,  573, 1110,  572,  571,  568, 1091, 1197, 1092, 1006,
     1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1110,
     1093, 1197, 1010, 1091, 1010, 1092,  567, 1010, 1010, 1010,
     1010, 1010, 1010, 1110, 1091,  566, 1092, 1093,  564, 1392,

      563,  560, 1105, 1108, 1213,  555, 1197, 1392, 1093, 1010,
     1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1105,
     1108, 1213, 1013,  551, 1013, 1115, 1255, 1013, 1013, 1013,
     1013, 1013, 1013, 1400, 1105, 1108, 1213, 1408, 1457, 1506,
     1255, 1400, 1115, 1115, 1631, 1408, 1457, 1506,  547, 1013,
     1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1115,
     1115, 1631, 1016, 1631, 1016, 1255,  542, 1016, 1016, 1016,
     1016, 1016, 1016, 1139, 1139, 1139, 1139, 1139, 1139, 1139,
     1144, 1144, 1144, 1144, 1144, 1144, 1144,  537, 1634, 1016,
     1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019,  536,

      535,  531, 1019,  525, 1019, 1634,  524, 1019, 1019, 1019,
     1019, 1019, 1019, 1148, 1148, 1148, 1148, 1148, 1148, 1148,
     1153, 1153, 1153, 1153, 1153, 1153, 1153, 1215, 1219, 1019,
     1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,  519,  518,
      517, 1024,  516,  515, 1215, 1219, 1024, 1024, 1024, 1024,
     1024, 1024, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
     1025,  514, 1219, 1215, 1025,  513, 1025,  512,  511, 1025,
     1025, 1025, 1025, 1025, 1025, 1155, 1155, 1155, 1155, 1155,
     1155, 1155, 1159, 1159, 1159, 1159, 1159, 1159, 1159, 1220,
     1225, 1025, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030,

     1030,  510,  509,  508, 1030,  507, 1220, 1225, 1620, 1030,
     1030, 1030, 1030, 1030, 1030, 1032, 1032, 1032, 1032, 1032,
     1032, 1032, 1032, 1032, 1220, 1620, 1225, 1032, 1620, 1032,
      505,  502, 1032, 1032, 1032, 1032, 1032, 1032, 1165, 1165,
     1165, 1165, 1165, 1165, 1165, 1167, 1167, 1167, 1167, 1167,
     1167, 1167, 1256, 1221, 1032, 1042, 1042, 1042, 1042, 1042,
     1042, 1042, 1042, 1042,  501,  500, 1256, 1042,  499,  498,
     1221, 1654, 1042, 1042, 1042, 1042, 1042, 1042, 1044, 1044,
     1044, 1044, 1044, 1044, 1044, 1044, 1044, 1221, 1654,  497,
     1044, 1256, 1044, 1654,  496, 1044, 1044, 1044, 1044, 1044,

     1044, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1177, 1177,
     1177, 1177, 1177, 1177, 1177, 1261, 1332, 1044, 1057, 1057,
     1057, 1057, 1057, 1057, 1057, 1057, 1057,  494,  493, 1261,
     1057,  492,  491, 1332, 1332, 1057, 1057, 1057, 1057, 1057,
     1057, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059,
      490, 1332,  489, 1059, 1261, 1059,  487,  485, 1059, 1059,
     1059, 1059, 1059, 1059, 1179, 1179, 1179, 1179, 1179, 1179,
     1179, 1183, 1183, 1183, 1183, 1183, 1183, 1183, 1262, 1335,
     1059, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073, 1073,
      483,  482, 1262, 1073,  481,  480, 1335, 1655, 1073, 1073,

     1073, 1073, 1073, 1073, 1075, 1075, 1075, 1075, 1075, 1075,
     1075, 1075, 1075,  479, 1655, 1335, 1075, 1262, 1075, 1655,
      477, 1075, 1075, 1075, 1075, 1075, 1075, 1190, 1190, 1190,
     1190, 1190, 1190, 1190, 1249, 1249, 1249, 1249, 1249, 1249,
     1249, 1265, 1336, 1075, 1087, 1087, 1087, 1087, 1087, 1087,
     1087, 1087, 1087,  476,  474, 1265, 1087,  473, 1652, 1336,
     1266, 1087, 1087, 1087, 1087, 1087, 1087, 1088, 1088, 1088,
     1088, 1088, 1088, 1088, 1266, 1652, 1336,  472, 1088, 1652,
     1265, 1622,  469, 1088, 1088, 1088, 1088, 1088, 1088, 1117,
     1117, 1117, 1117, 1117, 1117, 1117, 1117, 1117, 1622, 1266,

      465, 1622, 1117,  461,  460,  459, 1117, 1117, 1117, 1117,
     1117, 1117, 1117, 1118, 1118, 1118, 1118, 1118, 1118, 1118,
     1118, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119, 1119,
     1272, 1272, 1272, 1272, 1272, 1272, 1272, 1274, 1119, 1121,
     1121, 1121, 1121, 1121, 1121, 1121, 1570,  456,  452,  451,
     1121, 1274,  448, 1660, 1570, 1121, 1121, 1121, 1121, 1121,
     1121, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1122, 1122,
     1660,  447,  446, 1122,  445, 1668, 1274, 1275, 1122, 1122,
     1122, 1122, 1122, 1122, 1123, 1123, 1123, 1123, 1123, 1123,
     1123, 1275, 1668,  442,  441, 1123,  432,  429, 1670,  427,

     1123, 1123, 1123, 1123, 1123, 1123, 1125, 1125, 1125, 1125,
     1125, 1125, 1125, 1125, 1125, 1670, 1275,  426, 1125,  425,
     1670, 1623, 1278, 1125, 1125, 1125, 1125, 1125, 1125, 1126,
     1126, 1126, 1126, 1126, 1126, 1126, 1278,  424, 1623,  423,
     1126, 1623,  422, 1677,  421, 1126, 1126, 1126, 1126, 1126,
     1126, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1128, 1128,
     1677, 1278,  420, 1128,  419, 1680, 1628, 1279, 1128, 1128,
     1128, 1128, 1128, 1128, 1129, 1129, 1129, 1129, 1129, 1129,
     1129, 1279, 1680, 1628,  418, 1129, 1628, 1680, 1683,  417,
     1129, 1129, 1129, 1129, 1129, 1129, 1131, 1131, 1131, 1131,

     1131, 1131, 1131, 1131, 1131, 1683, 1279,  416, 1131, 1511,
     1684,  415, 1691, 1131, 1131, 1131, 1131, 1131, 1131, 1132,
     1132, 1132, 1132, 1132, 1132, 1132, 1511, 1684, 1684, 1691,
     1132,  414,  412,  410, 1511, 1132, 1132, 1132, 1132, 1132,
     1132, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135, 1135,
     1210, 1216, 1288, 1135,  409, 1135,  407,  406, 1135, 1135,
     1135, 1135, 1135, 1135,  403,  402, 1288, 1210, 1216, 1286,
     1286, 1286, 1286, 1286, 1286, 1286, 1289, 1338, 1210, 1216,
     1135, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 1140,
     1289, 1288,  400, 1140, 1338,  398,  397, 1685, 1140, 1140,

     1140, 1140, 1140, 1140, 1149, 1149, 1149, 1149, 1149, 1149,
     1149, 1149, 1149, 1338, 1685, 1289, 1149,  396,  395, 1685,
     1686, 1149, 1149, 1149, 1149, 1149, 1149, 1160, 1160, 1160,
     1160, 1160, 1160, 1160, 1160, 1160,  390, 1686,  389, 1160,
      388,  386, 1686, 1687, 1160, 1160, 1160, 1160, 1160, 1160,
     1172, 1172, 1172, 1172, 1172, 1172, 1172, 1172, 1172,  385,
     1687,  384, 1172,  383,  381, 1687, 1689, 1172, 1172, 1172,
     1172, 1172, 1172, 1184, 1184, 1184, 1184, 1184, 1184, 1184,
     1184, 1184,  376, 1689,  375, 1184,  374,  371, 1689, 1694,
     1184, 1184, 1184, 1184, 1184, 1184, 1198, 1198, 1198, 1198,

     1198, 1198, 1198, 1198, 1198,  367, 1694,  365, 1198, 1694,
      360,  359, 1217, 1198, 1198, 1198, 1198, 1198, 1198, 1200,
     1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1218, 1217,
     1222, 1200, 1223, 1200, 1228, 1439, 1200, 1200, 1200, 1200,
     1200, 1200, 1217, 1292,  356, 1218,  351, 1222,  350, 1223,
      342, 1228, 1439,  340,  339,  334,  332, 1292, 1200, 1218,
     1443, 1222, 1340, 1223, 1439, 1228, 1230, 1230, 1230, 1230,
     1230, 1230, 1230, 1230, 1230,  330, 1705, 1443, 1293, 1340,
     1302, 1339, 1292, 1230, 1232, 1232, 1232, 1232, 1232, 1232,
     1232, 1232, 1293, 1705, 1302, 1232, 1340, 1443, 1339, 1339,

     1232, 1232, 1232, 1232, 1232, 1232, 1233, 1233, 1233, 1233,
     1233, 1233, 1233, 1233, 1233,  329, 1339, 1293, 1233, 1302,
     1233, 1717, 1303, 1233, 1233, 1233, 1233, 1233, 1233, 1300,
     1300, 1300, 1300, 1300, 1300, 1300, 1303,  328, 1717,  327,
      326, 1306, 1307, 1367,  325, 1233, 1236, 1236, 1236, 1236,
     1236, 1236, 1236, 1236, 1236, 1306, 1307, 1367, 1236, 1509,
     1236, 1303, 1342, 1236, 1236, 1236, 1236, 1236, 1236, 1313,
     1313, 1313, 1313, 1313, 1313, 1313, 1509,  324,  322, 1342,
     1306, 1307, 1367,  321, 1720, 1236, 1239, 1239, 1239, 1239,
     1239, 1239, 1239, 1239, 1239, 1509, 1342,  320, 1239,  315,

     1239, 1720,  312, 1239, 1239, 1239, 1239, 1239, 1239, 1315,
     1315, 1315, 1315, 1315, 1315, 1315, 1319, 1319, 1319, 1319,
     1319, 1319, 1319,  311, 1329, 1239, 1242, 1242, 1242, 1242,
     1242, 1242, 1242, 1242, 1242, 1331, 1333, 1698, 1242, 1702,
     1242, 1329,  310, 1242, 1242, 1242, 1242, 1242, 1242,  307,
     1329,  306, 1331, 1333, 1698,  299, 1702, 1698,  298, 1330,
     1341, 1702, 1333, 1331, 1345, 1242, 1245, 1245, 1245, 1245,
     1245, 1245, 1245, 1245, 1245, 1346, 1330, 1341, 1245,  296,
     1245, 1345, 1368, 1245, 1245, 1245, 1245, 1245, 1245, 1330,
      295, 1341, 1346,  294, 1345,  292, 1368,  290,  289, 1700,

     1704, 1415, 1573, 1346,  288, 1245, 1250, 1250, 1250, 1250,
     1250, 1250, 1250, 1250, 1250, 1415, 1700, 1704, 1250, 1573,
     1700, 1368, 1704, 1250, 1250, 1250, 1250, 1250, 1250, 1257,
     1257, 1257, 1257, 1257, 1257, 1257, 1257, 1257, 1573,  286,
     1415, 1257,  282,  281, 1707, 1708, 1257, 1257, 1257, 1257,
     1257, 1257, 1267, 1267, 1267, 1267, 1267, 1267, 1267, 1267,
     1267, 1707, 1708,  279, 1267,  276,  272, 1715,  271, 1267,
     1267, 1267, 1267, 1267, 1267, 1280, 1280, 1280, 1280, 1280,
     1280, 1280, 1280, 1280, 1715, 1707, 1708, 1280,  268, 1715,
     1724, 1725, 1280, 1280, 1280, 1280, 1280, 1280, 1294, 1294,

     1294, 1294, 1294, 1294, 1294, 1294, 1294, 1724, 1725,  267,
     1294,  265, 1724, 1725, 1730, 1294, 1294, 1294, 1294, 1294,
     1294, 1308, 1308, 1308, 1308, 1308, 1308, 1308, 1308, 1308,
      260, 1730,  257, 1308,  255,  254, 1730, 1731, 1308, 1308,
     1308, 1308, 1308, 1308, 1320, 1320, 1320, 1320, 1320, 1320,
     1320, 1320, 1320,  252, 1731,  249, 1320,  245, 1731, 1733,
     1735, 1320, 1320, 1320, 1320, 1320, 1320, 1348, 1348, 1348,
     1348, 1348, 1348, 1348, 1348, 1348, 1733, 1735,  241, 1348,
      239, 1348, 1735,  237, 1348, 1348, 1348, 1348, 1348, 1348,
     1375, 1375, 1375, 1375, 1375, 1375, 1375, 1380, 1380, 1380,

     1380, 1380, 1380, 1380, 1416, 1425, 1348, 1352, 1352, 1352,
     1352, 1352, 1352, 1352, 1352, 1352,  236,  234, 1416, 1352,
      233,  232, 1425, 1739, 1352, 1352, 1352, 1352, 1352, 1352,
     1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1355, 1425,
     1739,  231, 1355, 1416,  230, 1740, 1738, 1355, 1355, 1355,
     1355, 1355, 1355, 1358, 1358, 1358, 1358, 1358, 1358, 1358,
     1358, 1358, 1740, 1738,  229, 1358, 1738,  228, 1745,  226,
     1358, 1358, 1358, 1358, 1358, 1358, 1361, 1361, 1361, 1361,
     1361, 1361, 1361, 1361, 1361, 1745, 1740,  224, 1361,  222,
     1745, 1750, 1754, 1361, 1361, 1361, 1361, 1361, 1361, 1364,

     1364, 1364, 1364, 1364, 1364, 1364, 1364, 1364, 1750, 1754,
      221, 1364,  219,  217, 1754, 1756, 1364, 1364, 1364, 1364,
     1364, 1364, 1369, 1369, 1369, 1369, 1369, 1369, 1369, 1369,
     1369,  216, 1756,  214, 1369,  211,  210,  209,  207, 1369,
     1369, 1369, 1369, 1369, 1369, 1382, 1382, 1382, 1382, 1382,
     1382, 1382, 1388, 1388, 1388, 1388, 1388, 1388, 1388, 1390,
     1390, 1390, 1390, 1390, 1390, 1390, 1396, 1396, 1396, 1396,
     1396, 1396, 1396, 1398, 1398, 1398, 1398, 1398, 1398, 1398,
     1404, 1404, 1404, 1404, 1404, 1404, 1404, 1406, 1406, 1406,
     1406, 1406, 1406, 1406, 1413, 1413, 1413, 1413, 1413, 1413,

     1413, 1419, 1420, 1430, 1431, 1436, 1438, 1759, 1763, 1766,
      205,  204, 1444, 1461, 1462, 1419, 1420, 1469, 1470, 1441,
     1430, 1431, 1436, 1438, 1759, 1763, 1766, 1461, 1462, 1444,
     1763, 1469, 1470, 1436, 1430, 1431, 1441, 1438, 1444, 1436,
     1419, 1420, 1421, 1421, 1421, 1421, 1421, 1421, 1421, 1421,
     1421, 1441, 1461, 1462, 1421,  201, 1469, 1470, 1765, 1421,
     1421, 1421, 1421, 1421, 1421, 1446, 1446, 1446, 1446, 1446,
     1446, 1446, 1446, 1446,  200, 1765,  198, 1446, 1765,  197,
      196,  195, 1446, 1446, 1446, 1446, 1446, 1446, 1455, 1455,
     1455, 1455, 1455, 1455, 1455, 1467, 1467, 1467, 1467, 1467,

     1467, 1467, 1476, 1476, 1476, 1476, 1476, 1476, 1476, 1478,
     1479, 1485, 1485, 1485, 1485, 1485, 1485, 1485, 1487, 1488,
     1496, 1497,  194, 1478, 1479, 1494, 1494, 1494, 1494, 1494,
     1494, 1494, 1487, 1488, 1496, 1497, 1502, 1502, 1502, 1502,
     1502, 1502, 1502,  193, 1510, 1514, 1515,  192, 1478, 1479,
     1504, 1504, 1504, 1504, 1504, 1504, 1504, 1487, 1488, 1496,
     1497, 1510, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1522,
     1510, 1525, 1524, 1514,  191,  190, 1515, 1526, 1527,  189,
      188, 1516, 1517, 1518, 1519, 1520, 1522, 1538, 1525, 1524,
     1516, 1517, 1518, 1519, 1526, 1527, 1539, 1522, 1524, 1520,

      187, 1538,  186,  185,  184, 1525,  183, 1527,  182,  181,
     1539, 1526, 1544, 1544, 1544, 1544, 1544, 1544, 1544, 1548,
     1548, 1548, 1548, 1548, 1548, 1548, 1538, 1552, 1552, 1552,
     1552, 1552, 1552, 1552,  180, 1539, 1556, 1556, 1556, 1556,
     1556, 1556, 1556, 1560, 1560, 1560, 1560, 1560, 1560, 1560,
     1565, 1565, 1565, 1565, 1565, 1565, 1565, 1567, 1568, 1576,
     1578, 1577, 1584, 1587, 1579, 1581, 1582, 1590,  178, 1585,
     1588, 1567, 1568, 1693, 1621, 1629, 1576, 1578, 1577, 1584,
     1587, 1579, 1581, 1582, 1590, 1576, 1585, 1588, 1584,  177,
     1693, 1621, 1629, 1590, 1587, 1578, 1567, 1568, 1577, 1579,

     1581, 1629, 1693, 1582, 1621, 1585, 1588, 1593, 1593, 1593,
     1593, 1593, 1593, 1593, 1596, 1596, 1596, 1596, 1596, 1596,
     1596, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1604, 1604,
     1604, 1604, 1604, 1604, 1604, 1608, 1608, 1608, 1608, 1608,
     1608, 1608, 1612, 1612, 1612, 1612, 1612, 1612, 1612, 1615,
     1615, 1615, 1615, 1615, 1615, 1615, 1619, 1624,  174, 1625,
     1626, 1768, 1633, 1627, 1636, 1636, 1636, 1636, 1636, 1636,
     1636, 1647,  173, 1619, 1624, 1624, 1625, 1626, 1768, 1633,
     1627, 1645, 1645, 1645, 1645, 1645, 1645, 1645, 1647, 1648,
     1619, 1649, 1624, 1650, 1657, 1625, 1626, 1627, 1633, 1651,

     1653, 1656, 1658,  172, 1659, 1669, 1648, 1647, 1649, 1671,
     1650, 1657, 1672,  171,  170, 1648, 1651, 1653, 1656, 1658,
     1657, 1659, 1669, 1673, 1650, 1649, 1671, 1674, 1675, 1672,
     1651, 1653, 1659, 1658, 1676, 1678, 1679, 1656,  169, 1688,
     1673, 1669, 1690,  168, 1674, 1675, 1692, 1671,  167,  165,
     1672, 1676, 1678, 1679,  162, 1674, 1688, 1695, 1675, 1690,
     1690, 1673,  161, 1692, 1696, 1688, 1679, 1697, 1676, 1699,
     1703, 1678, 1706, 1701, 1695, 1709, 1710, 1690, 1690, 1692,
     1692, 1696, 1712, 1714, 1697,  160, 1699, 1703, 1711, 1706,
     1701, 1695, 1709, 1710,  159, 1713, 1716, 1706, 1696, 1712,

     1714, 1697, 1710, 1699, 1701, 1711,  156, 1703, 1718, 1711,
     1719, 1709, 1713, 1716,  154, 1721, 1722, 1714, 1723, 1727,
     1712, 1711, 1711, 1713, 1726, 1718, 1728, 1719, 1719, 1729,
      145, 1716, 1721, 1722,  144, 1723, 1727, 1732,  143, 1734,
     1736, 1726, 1718, 1728,  142, 1719, 1729, 1722, 1727, 1737,
     1726, 1721,  141, 1741, 1732, 1723, 1734, 1736, 1742, 1743,
     1728, 1729, 1746, 1747, 1744, 1748, 1737,  140, 1732, 1734,
     1741, 1752, 1736,  139,  137, 1742, 1743,  135, 1749, 1746,
     1747, 1744, 1748, 1737, 1741, 1751, 1753,  134, 1752, 1757,
     1742, 1742, 1744, 1755, 1747, 1749, 1746, 1743,  132, 1752,

     1758, 1748, 1751, 1753, 1749, 1760, 1757, 1761, 1762, 1764,
     1755, 1767, 1770,  130, 1769, 1751, 1771, 1758, 1772, 1755,
     1773, 1774, 1760, 1753, 1761, 1762, 1764, 1775, 1767, 1770,
     1757, 1769,  128, 1771, 1758, 1772, 1769, 1773, 1774, 1776,
     1777, 1760, 1761, 1764, 1775, 1778, 1773, 1767, 1780, 1762,
     1781, 1771, 1782, 1783, 1772,  127, 1776, 1777,  126, 1774,
     1779,  125, 1778, 1779, 1779, 1780,  123, 1781,  122, 1782,
     1783,  121,  120,  119,  118, 1776,  116, 1779,  114,  113,
      112, 1778, 1785,  111, 1785, 1786,  110, 1786, 1786, 1786,
     1786, 1786, 1786, 1787,  109, 1787, 1788, 1788, 1788, 1789,

     1789, 1789, 1790, 1790, 1790, 1791, 1791, 1791, 1792, 1792,
     1792, 1793, 1793, 1793, 1794, 1794, 1794, 1795, 1795, 1795,
     1796, 1796, 1796, 1797,  108, 1797, 1798, 1798, 1798, 1799,
     1799, 1799, 1800, 1800, 1800, 1801, 1801, 1801, 1802,  107,
     1802, 1803, 1803, 1803, 1804, 1804,  106,  104, 1804, 1805,
     1805, 1805, 1806, 1806, 1806, 1807, 1807, 1807, 1808, 1808,
     1808, 1809, 1809, 1809, 1810, 1810, 1810, 1811, 1811, 1811,
     1812, 1812, 1812, 1813, 1813, 1813, 1814, 1814,  103,   96,
     1814, 1815, 1815, 1815, 1816, 1816, 1816, 1817,   95, 1817,
     1818, 1818, 1818, 1819, 1819, 1819, 1820,   94, 1820, 1821,

     1821, 1821, 1822, 1822, 1822, 1823, 1823, 1823, 1824, 1824,
     1824, 1825, 1825, 1825, 1826,   91, 1826, 1827,   88, 1827,
     1828, 1828, 1828, 1829, 1829, 1829, 1830,   87, 1830, 1831,
     1831,   86,   85, 1831, 1832, 1832,   84,   83, 1832, 1833,
     1833, 1833, 1834, 1834, 1834, 1835, 1835,   82, 1835, 1836,
     1836, 1836, 1837, 1837, 1837, 1838, 1838, 1838, 1839, 1839,
     1839, 1840, 1840, 1840, 1841, 1841, 1841, 1842, 1842, 1842,
     1843, 1843,   81,   80, 1843, 1844, 1844, 1844, 1845, 1845,
     1845, 1846, 1846,   79, 1846, 1847, 1847,   77,   76, 1847,
     1848, 1848,   75, 1848, 1849, 1849, 1850, 1850,   74,   73,

     1850, 1851, 1851, 1851, 1852, 1852, 1852, 1853, 1853,   72,
     1853, 1854,   71, 1854, 1855,   70, 1855, 1856, 1856, 1856,
     1857, 1857, 1857, 1858,   69, 1858, 1859, 1859, 1859, 1860,
     1860, 1860, 1861, 1861, 1861, 1862, 1862, 1862, 1863, 1863,
     1863, 1864, 1864, 1864, 1865,   68, 1865, 1866,   67, 1866,
     1867, 1867, 1867, 1868, 1868, 1868, 1869,   66, 1869, 1870,
       65, 1870, 1871,   64, 1871, 1872, 1872, 1872, 1873, 1873,
     1873, 1874,   62, 1874, 1875,   61,   60, 1875, 1876, 1876,
       47, 1876, 1877, 1877,   40,   39, 1877, 1878, 1878,   37,
     1878, 1879, 1879, 1880, 1880,   15,   13, 1880, 1881, 1881,

     1881, 1882, 1882, 1882, 1883, 1883,   10, 1883, 1884, 1884,
     1884,    7, 1884, 1884, 1885, 1885, 1885, 1886, 1886, 1886,
     1887, 1887, 1887, 1888, 1888, 1888, 1889, 1889, 1889, 1890,
     1890, 1890, 1891, 1891, 1891, 1892, 1892, 1892, 1893, 1893,
        3,    0, 1893, 1894, 1894, 1894, 1895, 1895, 1895, 1896,
     1896,    0, 1896, 1897, 1897,    0,    0, 1897, 1898, 1898,
        0, 1898, 1899, 1899, 1900, 1900,    0,    0, 1900, 1901,
     1901, 1901, 1902, 1902, 1902, 1903, 1903,    0, 1903, 1904,
        0,    0, 1904, 1905, 1905,    0, 1905, 1906, 1906,    0,
        0, 1906, 1907, 1907,    0, 1907, 1908, 1908, 1909, 1909,

        0,    0, 1909, 1910, 1910, 1910, 1911, 1911, 1911, 1912,
     1912,    0, 1912, 1913,    0, 1913, 1914,    0, 1914, 1915,
        0, 1915, 1916, 1916, 1916, 1917, 1917, 1917, 1918,    0,
     1918, 1919, 1919, 1919,    0, 1919, 1919, 1920, 1920, 1920,
     1921, 1921, 1921, 1922, 1922, 1922, 1923, 1923, 1923, 1924,
     1924, 1924, 1925, 1925, 1925, 1926, 1926, 1926, 1927,    0,
     1927, 1928,    0, 1928, 1929, 1929, 1929, 1930, 1930, 1930,
     1931,    0, 1931, 1932,    0, 1932, 1933,    0, 1933, 1934,
     1934, 1934, 1935, 1935, 1935, 1936,    0, 1936, 1937,    0,
     1937, 1938,    0, 1938, 1939,    0, 1939, 1940, 1940, 1940,

     1941, 1941, 1941, 1942,    0, 1942, 1943,    0, 1943, 1944,
        0,    0, 1944, 1945, 1945,    0, 1945, 1946, 1946,    0,
        0, 1946, 1947, 1947,    0, 1947, 1948, 1948, 1949, 1949,
        0,    0, 1949, 1950, 1950, 1950, 1951, 1951, 1951, 1952,
     1952,    0, 1952, 1953, 1953, 1953,    0, 1953, 1953, 1954,
     1954, 1954, 1955, 1955, 1955, 1956, 1956, 1956, 1957, 1957,
     1957, 1958, 1958, 1958, 1959, 1959, 1959, 1960, 1960, 1960,
     1961, 1961, 1961, 1962, 1962,    0,    0, 1962, 1963, 1963,
     1963, 1964, 1964, 1964, 1965, 1965,    0, 1965, 1966, 1966,
        0,    0, 1966, 1967, 1967,    0, 1967, 1968, 1968, 1969,

     1969,    0,    0, 1969, 1970, 1970, 1970, 1971, 1971, 1971,
     1972, 1972,    0, 1972, 1973,    0,    0, 1973, 1974, 1974,
        0, 1974, 1975, 1975,    0,    0, 1975, 1976, 1976,    0,
     1976, 1977, 1977, 1978, 1978,    0,    0, 1978, 1979, 1979,
     1979, 1980, 1980, 1980, 1981, 1981,    0, 1981, 1982,    0,
     1982, 1983,    0,    0, 1983, 1984, 1984,    0, 1984, 1985,
     1985,    0,    0, 1985, 1986, 1986,    0, 1986, 1987, 1987,
     1988, 1988,    0,    0, 1988, 1989, 1989, 1989, 1990, 1990,
     1990, 1991, 1991,    0, 1991, 1992,    0, 1992, 1993,    0,
     1993, 1994,    0, 1994, 1995, 1995, 1995, 1996, 1996, 1996,

     1997,    0, 1997, 1998, 1998, 1998,    0, 1998, 1998, 1999,
     1999, 1999, 2000, 2000, 2000, 2001, 2001, 2001, 2002, 2002,
     2002, 2003, 2003, 2003, 2004, 2004, 2004, 2005, 2005, 2005,
     2006, 2006, 2006, 2007, 2007, 2007, 2008, 2008, 2008, 2009,
        0, 2009, 2010,    0, 2010, 2011, 2011, 2011, 2012, 2012,
     2012, 2013, 2013, 2013, 2014,    0, 2014, 2015,    0, 2015,
     2016,    0, 2016, 2017, 2017, 2017, 2018, 2018, 2018, 2019,
     2019, 2019, 2020,    0, 2020, 2021,    0, 2021, 2022,    0,
     2022, 2023,    0, 2023, 2024, 2024, 2024, 2025, 2025, 2025,
     2026, 2026, 2026, 2027,    0, 2027, 2028,    0, 2028, 2029,

        0, 2029, 2030,    0, 2030, 2031, 2031, 2031, 2032, 2032,
     2032, 2033, 2033, 2033, 2034,    0, 2034, 2035,    0, 2035,
     2036,    0,    0, 2036, 2037, 2037,    0, 2037, 2038, 2038,
        0,    0, 2038, 2039, 2039,    0, 2039, 2040, 2040, 2041,
     2041,    0,    0, 2041, 2042, 2042, 2042, 2043, 2043, 2043,
     2044, 2044,    0, 2044, 2045, 2045, 2045,    0, 2045, 2045,
     2046, 2046, 2046, 2047, 2047, 2047, 2048, 2048, 2048, 2049,
     2049, 2049, 2050, 2050, 2050, 2051, 2051, 2051, 2052, 2052,
     2052, 2053, 2053, 2053, 2054,    0, 2054, 2055, 2055, 2055,
     2056, 2056,    0,    0, 2056, 2057, 2057, 2057, 2058, 2058,

     2058, 2059, 2059,    0, 2059, 2060, 2060,    0,    0, 2060,
     2061, 2061,    0, 2061, 2062, 2062, 2063, 2063,    0,    0,
     2063, 2064, 2064, 2064, 2065, 2065, 2065, 2066, 2066,    0,
     2066, 2067,    0,    0, 2067, 2068, 2068,    0, 2068, 2069,
     2069,    0,    0, 2069, 2070, 2070,    0, 2070, 2071, 2071,
     2072, 2072,    0,    0, 2072, 2073, 2073, 2073, 2074, 2074,
     2074, 2075, 2075,    0, 2075, 2076,    0, 2076, 2077,    0,
        0, 2077, 2078, 2078,    0, 2078, 2079, 2079,    0,    0,
     2079, 2080, 2080,    0, 2080, 2081, 2081, 2082, 2082,    0,
        0, 2082, 2083, 2083, 2083, 2084, 2084, 2084, 2085, 2085,

        0, 2085, 2086,    0, 2086, 2087,    0,    0, 2087, 2088,
     2088,    0, 2088, 2089, 2089,    0,    0, 2089, 2090, 2090,
        0, 2090, 2091, 2091, 2092, 2092,    0,    0, 2092, 2093,
     2093, 2093, 2094, 2094, 2094, 2095, 2095,    0, 2095, 2096,
        0, 2096, 2097,    0, 2097, 2098,    0, 2098, 2099, 2099,
     2099, 2100,    0, 2100, 2101, 2101, 2101, 2102,    0, 2102,
     2103, 2103, 2103,    0, 2103, 2103, 2104,    0, 2104, 2105,
     2105, 2105, 2106,    0, 2106, 2107, 2107, 2107, 2108,    0,
     2108, 2109, 2109, 2109, 2110,    0, 2110, 2111, 2111, 2111,
     2112,    0, 2112, 2113, 2113, 2113, 2114,    0, 2114, 2115,

     2115, 2115, 2116, 2116,    0,    0, 2116, 2117, 2117, 2117,
     2118, 2118, 2118, 2119, 2119, 2119, 2120, 2120,    0, 2120,
     2121, 2121, 2121, 2122,    0, 2122, 2123, 2123, 2123, 2124,
     2124, 2124, 2125,    0, 2125, 2126,    0, 2126, 2127, 2127,
     2127, 2128, 2128, 2128, 2129,    0, 2129, 2130,    0, 2130,
     2131,    0, 2131, 2132, 2132, 2132, 2133, 2133, 2133, 2134,
        0, 2134, 2135,    0, 2135, 2136,    0, 2136, 2137, 2137,
     2137, 2138, 2138, 2138, 2139,    0, 2139, 2140,    0, 2140,
     2141,    0, 2141, 2142, 2142, 2142, 2143, 2143, 2143, 2144,
        0, 2144, 2145,    0,    0, 2145, 2146, 2146,    0, 2146,

     2147, 2147,    0,    0, 2147, 2148, 2148,    0, 2148, 2149,
     2149, 2150, 2150,    0,    0, 2150, 2151, 2151, 2151, 2152,
        0, 2152, 2153, 2153,    0, 2153, 2154, 2154, 2154,    0,
     2154, 2154, 2155, 2155, 2155, 2156, 2156, 2156, 2157,    0,
     2157, 2158,    0, 2158, 2159,    0, 2159, 2160,    0, 2160,
     2161,    0, 2161, 2162,    0, 2162, 2163,    0, 2163, 2164,
     2164, 2164, 2165, 2165, 2165, 2166,    0, 2166, 2167, 2167,
        0,    0, 2167, 2168, 2168,    0, 2168, 2169, 2169, 2170,
        0, 2170, 2171,    0,    0, 2171, 2172, 2172,    0, 2172,
     2173, 2173,    0,    0, 2173, 2174, 2174,    0, 2174, 2175,

     2175, 2176,    0, 2176, 2177,    0, 2177, 2178,    0,    0,
     2178, 2179, 2179,    0, 2179, 2180, 2180,    0,    0, 2180,
     2181, 2181,    0, 2181, 2182, 2182, 2183,    0, 2183, 2184,
        0, 2184, 2185,    0,    0, 2185, 2186, 2186,    0, 2186,
     2187, 2187,    0,    0, 2187, 2188, 2188,    0, 2188, 2189,
     2189, 2190,    0, 2190, 2191,    0, 2191, 2192,    0,    0,
     2192, 2193, 2193,    0, 2193, 2194, 2194,    0,    0, 2194,
     2195, 2195,    0, 2195, 2196, 2196, 2197,    0, 2197, 2198,
        0, 2198, 2199,    0, 2199, 2200,    0, 2200, 2201, 2201,
     2201, 2202,    0, 2202, 2203, 2203, 2203,    0, 2203, 2203,

     2204,    0, 2204, 2205,    0, 2205, 2206,    0, 2206, 2207,
        0, 2207, 2208,    0, 2208, 2209,    0, 2209, 2210,    0,
     2210, 2211, 2211,    0,    0, 2211, 2212, 2212,    0, 2212,
     2213, 2213, 2214,    0, 2214, 2215,    0, 2215, 2216,    0,
     2216, 2217,    0, 2217, 2218,    0, 2218, 2219,    0, 2219,
     2220,    0, 2220, 2221,    0, 2221, 2222,    0, 2222, 2223,
        0, 2223, 2224,    0,    0, 2224, 2225, 2225,    0,    0,
     2225, 2226,    0, 2226, 2227,    0, 2227, 2228,    0, 2228,
     2229,    0,    0, 2229, 2230,    0,    0, 2230, 2231,    0,
        0, 2231, 2232,    0,    0, 2232, 2233,    0,    0, 2233,

     2234,    0, 2234, 2235,    0, 2235, 2236,    0,    0, 2236,
     2237,    0, 2237, 2238,    0, 2238, 2239,    0, 2239, 2240,
        0, 2240, 2241,    0, 2241, 2242,    0,    0, 2242, 2243,
        0, 2243, 2244,    0, 2244, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784, 1784, 1784, 1784
    } ;

```

这段代码定义了一个名为“reject_used_but_not_detected”的宏，旨在捕捉到使用REJECT时可能会漏检的情况。接下来定义了一个名为“yyymore”的宏，用于报告YY/YY*辅助定义中未被使用的REJECT定义。最后定义了一个名为“YY_MORE_ADJ”的宏，用于报告YY/YY*辅助定义中未被使用的REJECT定义的数量。

通过这两行定义，可以推断出此代码是一个用于报告未被使用但确实存在的REJECT定义的工具链，用于在编译时捕捉可能出现的错误。同时，还会捕获使用REJECT时flex可能忽略的定义。


```cpp
/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "scanner.l"

/*
 * We want a reentrant scanner.
 */
/*
 * And we need to pass the compiler state to the scanner.
 */
```

这段代码定义了三个宏：YY_NO_INPUT，YY_NO_UNPUT和YY_NO_TERMIN。

YY_NO_INPUT 是一个宏定义，表示我们不会处理输入，因此不会生成代码。

YY_NO_UNPUT 也是一个宏定义，表示我们不会处理输出，因此不会生成代码。

YY_NO_TERMIN 是一个宏定义，表示我们希望在达到输入的末尾时停止处理，因此不会生成代码。

此外，还定义了一个常量YY_NO_INPUT，其值为 1。


```cpp
/*
 * We don't use input, so don't generate code for it.
 */
#define YY_NO_INPUT 1
/*
 * We don't use unput, so don't generate code for it.
 */
/*
 * We don't read from the terminal.
 */
/*
 * We want to stop processing when we get to the end of the input.
 */
/*
 * We want to generate code that can be used by a reentrant parser
 * generated by Bison or Berkeley YACC.
 */
```

这段代码是一个C语言的程序，它定义了一个名为“scanner.l”的文件。这个文件是一个头文件，它包含了scanner.h文件的定义。

通过阅读代码，我们可以看到这个头文件被用来定义了一些函数，以及一些数据类型的声明。其中包括：

1. 定义了一个printf函数，用于输出从 scanner.h 中定义的函数的参数和返回值。
2. 定义了一个int类型的变量，名为“ch”，用于存储从 scanner.h 中定义的函数的返回值类型。
3. 定义了一个名为“my_printf”的函数，它使用了printf函数，并将其参数和返回值与scanner.h中的函数名称做了匹配。
4. 定义了一个名为“my_int”的函数，它接收一个int类型的参数，并在函数内部对传入的参数进行了一些处理，然后将其返回。
5. 定义了一个名为“my_printf_array”的函数，它与printf函数相似，但只对一个整数类型的数组进行输出。
6. 定义了一个名为“my_scanf_array”的函数，它与scanf函数相似，但只对一个整数类型的数组进行输入。
7. 定义了一个名为“my_puts”的函数，它用于将一个字符串输出到屏幕上。
8. 定义了一个名为“my_gets”的函数，它用于从标准输入中读取一行字符串，并将其存储在“ch”变量的值为整数的情况下返回。

此外，还定义了一些数据类型的声明，如int、double、char等等。


```cpp
#line 74 "scanner.l"
/*
 * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

```

这段代码是一个用于从winsock2库中获取TCP连接中column的程序。

具体来说，代码中通过引入了<string.h>头文件，用来在函数声明中包含对字符串操作的支持。

接着，代码中引入了"pcap-int.h"头文件，以及定义了两个函数pcap_get_column和pcap_set_column。

这两个函数的具体实现没有在代码中给出，但根据函数名和C库名称可以猜测它们可能是用于从TCP连接中读取或修改column的函数。

最后，代码中使用了#ifdef INET6和#ifdef _WIN32两个条件编译指令，用于在不同的操作系统上编译。其中，#ifdef INET6表示编译到支持IPv6的系统上，而#ifdef _WIN32则表示编译到Windows系统上。


```cpp
#include <string.h>

#include "pcap-int.h"

/*
 * Earlier versions of Flex don't declare these, so we declare them
 * ourselves to squelch warnings.
 */
int pcap_get_column(yyscan_t);
void pcap_set_column(int, yyscan_t);

#ifdef INET6

#ifdef _WIN32
#include <winsock2.h>
```

这段代码是一个C语言程序，它引入了`<ws2tcpip.h>`头文件，以使用在`ws2tcpip.h`中定义的`getaddrinfo()`函数。

根据MSDN的文档，`getaddrinfo()`函数在Windows XP和更早版本中并不支持。因此，为了在较旧的Windows平台上运行需要使用这个函数的应用程序，需要包括`Ws2tcpip.h`和`Wspiapi.h`头文件。

由于`Ws2tcpip.h`本身并没有包含`getaddrinfo()`函数，因此`Wspiapi.h`头文件中包含的`getaddrinfo()`函数是在`Wspiapi.h`头文件中定义的。当`Ws2tcpip.h`或`Wship6.dll`（包含在`Wspiapi.h`中）本身不包含`getaddrinfo()`函数时，`Wspiapi.h`头文件中的`getaddrinfo()`函数将用基于`Wspiapi.h`头文件中的代码实现，这是对较旧Windows平台上无法支持`getaddrinfo()`函数的补充。


```cpp
#include <ws2tcpip.h>
/*
 * To quote the MSDN page for getaddrinfo() at
 *
 *    https://msdn.microsoft.com/en-us/library/windows/desktop/ms738520(v=vs.85).aspx
 *
 * "Support for getaddrinfo on Windows 2000 and older versions
 * The getaddrinfo function was added to the Ws2_32.dll on Windows XP and
 * later. To execute an application that uses this function on earlier
 * versions of Windows, then you need to include the Ws2tcpip.h and
 * Wspiapi.h files. When the Wspiapi.h include file is added, the
 * getaddrinfo function is defined to the WspiapiGetAddrInfo inline
 * function in the Wspiapi.h file. At runtime, the WspiapiGetAddrInfo
 * function is implemented in such a way that if the Ws2_32.dll or the
 * Wship6.dll (the file containing getaddrinfo in the IPv6 Technology
 * Preview for Windows 2000) does not include getaddrinfo, then a
 * version of getaddrinfo is implemented inline based on code in the
 * Wspiapi.h header file. This inline code will be used on older Windows
 * platforms that do not natively support the getaddrinfo function."
 *
 * We use getaddrinfo(), so we include Wspiapi.h here.
 */
```

这段代码是一个网络编程的代码，它主要实现了两个目标：

1. 如果用户在一个 AIX 4.3 或更高版本的操作系统上，则引入了 Windows 系统头文件，包含了 "wspiapi.h" 头文件，用于支持在 AIX 4.3 或更高版本的命令行工具中使用命名管道（named pipe）。
2. 如果用户在一个 AIX 4.3 或更高版本的操作系统上，但是 AIX 4.3 安装了一些软件，如 SysDM 或者 SysVEX，则通过引入 "sys/socket.h" 和 "netdb.h" 头文件，实现了对 Windows 系统进行命名管道编程的功能。
3. 如果用户正在使用 Inet6 协议，则通过引入 "INET6" 头文件，支持 Inet6 协议。
4. 最后，定义了一个名为 "ai_numeroichost" 的宏，用于将 AIX 4.3 系统设置中的 "AI_NUMERICHOST" 字段设置为 0x04。


```cpp
#include <wspiapi.h>
#else /* _WIN32 */
#include <sys/socket.h>	/* for "struct sockaddr" in "struct addrinfo" */
#include <netdb.h>	/* for "struct addrinfo" */
#endif /* _WIN32 */

/* Workaround for AIX 4.3 */
#if !defined(AI_NUMERICHOST)
#define AI_NUMERICHOST 0x04
#endif

#endif /*INET6*/

#include <pcap/namedb.h>
#include "grammar.h"

```

这段代码是一个C语言代码片段，定义了一个名为“stou”的函数，它的作用是打印输出。注意，该函数仅在包含“os_proto.h”头文件的情况下可以被调用。

具体来说，这段代码检查当前编译器是否支持“os_proto.h”头文件。如果不支持，函数代码将不包含在输出中。否则，函数代码将继续执行，并将输入的字符串和传递给它的一个指向“YYSTYPE”类型的变量的指针作为参数。函数内部使用了一个名为“stou”的函数，该函数接受两个参数：一个字符串和一个指向“YYSTYPE”类型的指针。函数内部将输入的字符串与传递给它的“YYSTYPE”类型的指针的值进行比较，然后打印或输出该字符串。

此外，该代码定义了一个名为“INITIAL”的宏，其值为0。


```cpp
#ifdef HAVE_OS_PROTO_H
#include "os-proto.h"
#endif

static int stou(char *, YYSTYPE *, compiler_state_t *);

/*
 * Disable diagnostics in the code generated by Flex.
 */
DIAG_OFF_FLEX

#line 2990 "scanner.c"

#define INITIAL 0

```

这段代码定义了一个名为YYGUTS的 struct 类型，该类型包含了一个编译器状态变量YY_EXTRA_TYPE，以及一些与 flex 无关的函数。

首先，定义了一个头文件《YY_NO_UNISTD_H》，该文件包含一个特殊的 case 处理，用于非 ANSI 标准库的 unistd.h 文件。通过 include 该文件，我们使得用户在定义变量时，有可能会覆盖这个文件中的定义。

接着，定义了一个名为 YYYUPPER 的新类型，该类型继承自 compiler_state_t，用于保存整个 yy 解析器的状态。

然后，定义了一系列与 flex 无关的函数，如 file 类型的 yyin 和 yyout 函数，yy 缓冲区栈中的 top、max 和 buffer 函数，以及一些与 yy 初始化、转换相关的函数。

最后，通过 yy 函数定义了一个 YYYUPPER 类型的变量，该变量包含上述函数的定义，以及一些与 flex 无关的变量和与 yy 解析器状态相关的时间变量。


```cpp
#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE compiler_state_t *

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top; /**< index of top of stack. */
    size_t yy_buffer_stack_max; /**< capacity of stack. */
    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    yy_size_t yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char* yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    YYSTYPE * yylval_r;

    }; /* end struct yyguts_t */

```



该代码定义了两个名为"yyy_init_globals"和"pcap_lex_init"的函数，以及两个名为"YYSTYPE"和"YYLTYPE"的常量。

"yyy_init_globals"函数是一个静态函数，用于初始化YYSTYPE和YYLTYPE。它的实参是一个YYSCANNER类型的参数。

"pcap_lex_init"函数是一个静态函数，用于初始化pcap_lex_scanner类型的变量。它的实参是一个YYSCANNER类型的参数，以及一个YY_EXTRA_TYPE类型的参数，用于指定用户定义的扫描器类型。

"YYSTYPE"是一个定义了YYSTYPE类型的常量。它表示YYSTYPE是YY_TYPE族的一个成员。

"YYLTYPE"是一个定义了YYLTYPE类型的常量。它表示YYLTYPE是YY_TYPE族的一个成员。

"yyy_init_globals"函数的实现中包含了一个YY_GLOBAL_HEADER类型的定义。它列出了YY_STYPE和YYLTYPE的成员变量，以及它们的默认值。这些成员变量和默认值在后续的代码中被初始化。

"pcap_lex_init_extra"函数的实现中包含了一个YY_EXTRA_TYPE类型的定义。它列出了YY_STYPE和YYLTYPE的成员变量，以及它们的默认值。这些成员变量和默认值在后续的代码中被初始化。


```cpp
static int yy_init_globals (yyscan_t yyscanner );

    /* This must go here because YYSTYPE and YYLTYPE are included
     * from bison output in section 1.*/
    #    define yylval yyg->yylval_r
    
int pcap_lex_init (yyscan_t* scanner);

int pcap_lex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int pcap_lex_destroy (yyscan_t yyscanner );

```



这是一段用于获取和设置 pcap 库中的调试信息的 C 语言代码。

`pcap_get_debug`函数用于获取当前 pcap 库的调试标志，并将它存储在 `debug_flag` 变量中。

`pcap_set_debug`函数用于设置或取消 pcap 库的调试标志。它接受一个整数参数 `debug_flag` 和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_get_extra`函数用于获取 pcap 库中的额外信息，并将它存储在一个 `YY_EXTRA_TYPE` 中。它接受一个 `YY_EXTRA_TYPE` 类型的输入参数 `user_defined` 和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_set_extra`函数用于设置 pcap 库中的额外信息。它接受一个 `YY_EXTRA_TYPE` 类型的用户定义的额外信息，和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_get_in`函数用于从输入文件中读取数据。它接受一个 `FILE` 类型的输入文件名和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_set_in`函数用于将输入文件中的数据写入到输出文件中。它接受一个 `FILE` 类型的输出文件名和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_get_out`函数用于从输出文件中读取数据。它接受一个 `FILE` 类型的输入文件名和一个 `yyscan_t` 类型的输入参数 `yyscanner`。

`pcap_set_out`函数用于将数据写入到输出文件中。它接受一个 `FILE` 类型的输出文件名和一个 `yyscan_t` 类型的输入参数 `yyscanner`。


```cpp
int pcap_get_debug (yyscan_t yyscanner );

void pcap_set_debug (int debug_flag ,yyscan_t yyscanner );

YY_EXTRA_TYPE pcap_get_extra (yyscan_t yyscanner );

void pcap_set_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );

FILE *pcap_get_in (yyscan_t yyscanner );

void pcap_set_in  (FILE * _in_str ,yyscan_t yyscanner );

FILE *pcap_get_out (yyscan_t yyscanner );

void pcap_set_out  (FILE * _out_str ,yyscan_t yyscanner );

```



这个代码是关于yy_size_t类型的pcap_get_leng,pcap_get_text,pcap_get_lineno,pcap_set_lineno和pcap_set_column的封装函数。

pcap_get_leng函数接收一个yyscanner类型的参数，并返回一个YYSTYPE类型的变量。它用于获取当前行号。

pcap_get_text函数接收一个yyscanner类型的参数，并返回一个char类型的变量。它用于获取文本中当前行的内容。

pcap_get_lineno函数接收一个yyscanner类型的参数，并返回一个int类型的变量。它用于获取当前行在文本中的行号。

pcap_set_lineno函数接收一个int类型的参数和一个yyscanner类型的参数，并将当前行在文本中的行号设置为指定的行号。

pcap_set_column函数接收一个int类型的参数和一个yyscanner类型的参数，并将当前行在文本中的列号设置为指定的列号。

pcap_get_lval函数接收一个yyscanner类型的参数，并返回一个YYSTYPE类型的变量。它用于获取当前行在文本中的值。

pcap_set_lval函数接收一个YYSTYPE类型的参数和一个yyscanner类型的参数，并将当前行在文本中的值设置为指定的值。


```cpp
yy_size_t pcap_get_leng (yyscan_t yyscanner );

char *pcap_get_text (yyscan_t yyscanner );

int pcap_get_lineno (yyscan_t yyscanner );

void pcap_set_lineno (int _line_number ,yyscan_t yyscanner );

int pcap_get_column  (yyscan_t yyscanner );

void pcap_set_column (int _column_no ,yyscan_t yyscanner );

YYSTYPE * pcap_get_lval (yyscan_t yyscanner );

void pcap_set_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );

```

这是一个 C 语言的代码，定义了一些宏，用于定义和输出。以下是对这些宏的解释：

1. `YY_SKIP_YYWRAP`：这是一个宏，告诉编译器不要从代码中跳过 YY 解析器的输出。这个宏通常是用于在与 YY 解析器交互时，某些输出可以被用户自定义。
2. `YY_NO_UNPUT`：这是一个宏，告诉编译器不要输出 YY 解析器的输入。这个宏可能是用于某些代码编辑器或 IDE 中，需要隐藏 YY 解析器的输入。
3. `YY_RPROTOCOL`：这是一个宏，定义了 YY 协议的结构。这个宏可能是用于在代码中使用 YY 协议进行通信时。
4. `YY_SCANNER_CPU`：这是一个宏，定义了 YY 扫描器的输出类型。这个宏可能是用于在与 YY 扫描器交互时，需要将 YY 扫描器的输出类型与特定功能进行匹配。
5. `YY_SCANNER_NET`：这是一个宏，定义了 YY 扫描器的输出类型。这个宏可能是用于在与 YY 扫描器交互时，需要将 YY 扫描器的输出类型与特定网络通信进行匹配。

注意：这些宏定义了一个名为 "YY_SKIP_YYWRAP" 的变量，它告诉编译器不要从代码中跳过 YY 解析器的输出。如果没有这个宏，则编译器会生成一个名为 "YY_SKIP_YYWRAP_YYSCANNER_CPU" 的函数，它的输出是 0。


```cpp
/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int pcap_wrap (yyscan_t yyscanner );
#else
extern int pcap_wrap (yyscan_t yyscanner );
#endif
#endif

#ifndef YY_NO_UNPUT
    
#endif

```

这是一个C语言源代码，定义了三个函数：yy_flex_strncpy，yy_flex_strlen和yyinput。

1. yy_flex_strncpy函数：这是一个静态函数，用于在yyconst char *类型的变量中复制一个yyconst char *类型的字符串，并将其复制到yy_flex_strncpy函数中。它的参数包括一个yyconst char *类型的目标字符串，一个int类型的源字符数，和一个yyscan_t类型的参数表示输入的扫描器。这个函数的作用是帮助我们在需要复制一个字符串时，避免数组越界等错误。

2. yy_flex_strlen函数：这也是一个静态函数，用于计算一个yyconst char *类型的字符串的长度，并将其存储在yyconst char *类型的变量中。它的参数包括一个yyconst char *类型的目标字符串，一个yyscan_t类型的参数表示输入的扫描器。这个函数的作用是帮助我们在需要获取字符串长度时，避免输入参数为NULL等错误。

3. yyinput函数：这是一个默认实现的输入函数，用于在yyconst char *类型的变量中读取一行字符并将其存储在yyconst char *类型的变量中。它的参数包括一个yyconst char *类型的目标变量，一个yyscan_t类型的参数表示输入的扫描器。这个函数的作用是帮助我们在不需要指定输入来源时，读取一行字符串。

另外，还有一句代码#ifdef __cplusplus，如果在__cplusplus这个预处理器定义了这个函数，则这个函数不会被输出。


```cpp
#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (yyscan_t yyscanner );
#else
static int input (yyscan_t yyscanner );
#endif

```

这段代码包含两个部分，需要分别解释。

1. #endif 是一个预处理指令，它告诉编译器在编译之前不需要考虑头文件中的某些指令或定义。这个指令可以出现在头文件中，也可以出现在函数内。

2. 下面的代码定义了一个名为YY_READ_BUF_SIZE的宏，它定义了要一次性吸收多少信息。这个宏有两种实现方式，一种是针对IA-64架构，将缓冲区大小定义为16K；另一种是针对任何架构，将缓冲区大小定义为8K。如果没有定义这个宏，则按照默认值8K来执行。

3. 下面的代码是一个注释，它告诉编译器不要输出任何预处理指令或者定义。


```cpp
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
```

这段代码是一个预处理指令，用于定义一个名为“echo”的函数。这个函数接收两个参数“buf”和“result”，并返回一个名为“YY_INPUT”的函数。

“YY_INPUT”函数的作用是读取用户输入的输入，并将其存储在“buf”数组中。如果没有从用户读取任何输入，函数会返回一个名为“YY_INPUT”的默认函数，该函数会设置“result”为 0。

“echo”函数的作用是在不成功读取用户输入的情况下，在控制台输出一条消息并返回 0。它使用了`fwrite`函数来将字符串“fancy”写入到“yyout”文件中，其中`yyin`是输入文件，“yyout”是输出文件。`fwrite`函数的第一个参数是目标文件描述符，第二个参数是字符串，“fancy”是一个字符串，表示要写入的输出。`fwrite`函数使用了LF换行符作为字符串结束符，并在字符串结束时提交所有缓冲。

总的来说，“echo”函数是一个辅助函数，用于在用户输入为空时，在控制台上输出一条消息并返回 0，以便开发者在读取输入时知道发生了什么。


```cpp
#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
```

这段代码定义了一个名为“yyterminate”的宏，它的含义是返回一个名为“YYY_NULL”的常量，该常量的值可以是任何合法的Ast类型。

接下来的注释解释了为什么在函数中使用“yyterminate()”而不是“yyterminate”来声明函数返回值。这是因为，如果使用“yyterminate”作为函数返回值，则某些编译器会因为函数没有返回语句而产生警告，说函数返回了未定义的类型。

接着定义了一个名为“YYY_START_STACK_INCR”的宏，它的值为25，表示 start-condition 栈可以最多有25个 entries。


```cpp
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
```

这段代码是一个C语言中的预处理指令，它主要作用是在编译时检查源代码文件是否符合某些特定的定义。这里的#if和#define后面跟着的是两个条件判断，如果条件成立，那么定义中的代码块将会被编译。

具体来说，如果满足YY_FATAL_ERROR定义中的条件，那么将会编译一个名为YY_FATAL_ERROR的函数，该函数将抛出一个msg类型的致命错误，并使用yyscanner参数获取该错误信息。如果满足YY_DECL定义中的条件，那么将会定义一个名为YY_DECL的函数，该函数将会报告该源文件是自己的定义。

因此，这段代码的作用是定义了一些预处理指令，用于检查源代码文件是否符合特定的定义，如果不符合定义，将会抛出相应的错误信息。


```cpp
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

```

这段代码定义了一个名为“pcap_lex”的函数，其参数为“YYSTYPE”类型指针和“yyscan_t”类型指针，表示两个整型变量。该函数的作用是返回一个指向下一个产生包搜索器（yyscanner）的指针。它被定义为“YY_DECL”函数，如果该函数没有被定义，则可以使用“extern”关键字声明。

在这段注释中，它描述了一个函数，说明了一个外部函数“pcap_lex”，其输入参数为“YYSTYPE”指针和“yyscan_t”指针，而返回类型为“int”。

函数的作用是在规则的开始和结束时，根据定义的YY_USER_ACTION分支执行相应的操作。如果YY_USER_ACTION没有被定义，则默认规则行为会被执行。


```cpp
extern int pcap_lex \
               (YYSTYPE * yylval_param ,yyscan_t yyscanner);

#define YY_DECL int pcap_lex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
```

这段代码定义了一个名为YY_BREAK的预处理指令，会在源代码中包含一个名为YY_RULE_SETUP的定义。这个预处理指令告诉编译器在定义YY_RULE_SETUP函数或者使用这个定义之前，要先定义YY_BREAK指令，否则不会编译通过。

YY_RULE_SETUP定义了一个名为YY_DECL的函数，这个函数表示这个定义的作用，即YY_RULE_SETUP函数或定义中的代码块是YY_SCANNER程序的一部分。这个函数被定义为YY_DECL。

YY_DECL函数中定义了一个名为yy_current_state的变量，表示扫描当前代码块的状态。还定义了一个名为yy_cp的变量，表示当前扫描到的字符的下一个编码点处的位置，以及一个名为yy_bp的变量，表示当前扫描到的字符的下一个编码点处的下一个位置。最后定义了一个名为yy_act的变量，表示当前扫描到的字符的下一个编码点处是否是可扫描字符。

另外，还定义了一个名为yyg的指向struct yyguts_t类型的变量，表示当前扫描到的字符的下一个编码点处是否是可扫描字符。

最后，在这段代码的最后，通过函数指针 yyscanner，给yyscanner一个输出，这个输出就是上面定义的YY_RULE_SETUP函数。


```cpp
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yylval = yylval_param;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

```

这段代码是一个 C 语言程序，用于读取来自用户输入的 YY 形式的数据，将其存储到缓冲区中，并输出到屏幕上。以下是程序的概述：

1. 定义了一些预处理指令，包括 #ifdef YY_USER_INIT，用于定义程序是否已经加载了用户定义的数据，如果没有，则执行一些简单的任务。

2. 如果 #ifdef YY_USER_INIT 为真，则执行以下任务：

  a. 初始化 YY 引擎，包括开启校验和启用自动完成。

  b. 如果 #ifdef YY_USER_INIT 为真，则执行以下任务：

   i. 如果当前缓冲区为空，则将标准输入赋值给当前缓冲区的起始位置。

   ii. 如果 #ifdef YY_USER_INIT 为真，则执行以下任务：

      i. 如果当前缓冲区不为空，则执行以下操作：

        a. 从缓冲区中加载数据。

        b. 将加载的数据存储到当前缓冲区。

        c. 如果当前缓冲区为空，则将起始位置设置为标准输入。

        d. 设置 #YY_CURRENT_BUFFER 为 1，以便下一次加载数据时可以创建一个新的缓冲区。

3. 如果 #ifdef YY_USER_INIT 为真，则执行以下任务：

  a. 从缓冲区中加载数据。

  b. 输出数据到屏幕上。

  c. 如果当前缓冲区为空，则创建一个新的缓冲区并将其用于下一次加载数据。


```cpp
#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			pcap_ensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				pcap__create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		pcap__load_buffer_state(yyscanner );
		}

	{
```

这段代码是一个 C 语言程序，定义了一个名为 "scanner.l" 的文件头信息，然后定义了一个名为 "scanner.c" 的文件头信息。接着定义了一个名为 "scanner" 的程序计数器，并使用 while 循环语句在文件结束前重复执行该循环。

循环的条件是判断文件是否结束，如果文件已结束，则循环结束。在每次循环中，程序将 "scanner.l" 中的内容读取到 "yyg" 结构体中的 "yy_c_buf_p" 成员，并将其值赋给 "yy_cp" 成员。由于 "yy_cp" 是 "yyg" 结构体中的一个成员，它保存了当前行中的内容，因此可以通过 "yy_cp" 访问到该成员。

接下来，程序将 "yy_bp" 成员的值设置为当前行中的内容在 "yy_ch_buf" 中的位置。然后程序将 "yy_current_state" 成员的值设置为当前行中的起始状态。

最后，程序使用 "yy_cp" 和 "yy_current_state" 成员的值来执行循环体内的一系列操作，这些操作主要是读取并复制当前行中的内容，直到文件结束。


```cpp
#line 255 "scanner.l"

#line 3263 "scanner.c"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
```

这段代码是一个递归函数，用于处理YY语言描述符（YY_D）中的匹配项。它的作用是检查给定的YY_D是否与YY_T中的匹配项匹配，如果匹配成功，则更新YY_C的元数据，并将YY_C的当前状态记录在YY_g的数据结构中。如果匹配失败，则遍历YY_D的当前状态，直到找到第一个不匹配的YY_C位置，然后继续遍历。

具体来说，代码首先定义了一个YY_CHAR类型的变量yy_c，用于存储当前正在比较的YY_D中的一个字符。然后，代码判断给定的YY_D是否与YY_T中的匹配项匹配，如果匹配成功，则执行以下操作：

1. 将YY_C的元数据设置为当前状态的YY_T中的匹配项的YY_C值。
2. 将YY_C的当前状态记录在YY_g的数据结构中，以便在后续遍历中使用。
3. 如果当前遍历到的YY_C位置与当前状态不匹配，则执行以下操作：

a. 更新当前状态为YY_def[current_state]中对应YY_C位置的值。
b. 如果当前状态大于等于1785，则将YY_C的元数据设置为YY_meta[(unsigned int) current_YY_C]中的值。
c. 移动当前遍历到的YY_C位置。
d. 增加当前遍历到的YY_C位置。

然后，代码会继续遍历YY_D，直到当前状态不等于1784为止。


```cpp
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1785 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 1784 );
		yy_cp = yyg->yy_last_accepting_cpos;
		yy_current_state = yyg->yy_last_accepting_state;

```

这段代码的作用是执行一个行动(action)，其中当前状态为current_state。如果当前状态需要执行的行动是DO_BEFORE_ACTION，则会跳转到do_action标签开始执行这个行动。

具体来说，代码会先定义一个名为act的变量，然后进入一个do_action标签。在这个标签内部，使用switch语句根据act的值来执行相应的操作。如果act的值为0，则会执行一个名为YY_DO_BEFORE_ACTION的函数。

如果执行的action不是0，则会先执行一个名为yyg的变量的get动作，并将get动作的返回值存储为当前action的参数。然后，将当前action的参数替换为yyg->yy_hold_char，将last_accepting_cpos存储为当前action的last_accepting_state，最后跳转到执行action标签中的代码开始执行这个行动。

如果当前状态需要执行DO_BEFORE_ACTION，则会执行其中的代码，并跳转到执行action标签中的代码开始执行这个行动。


```cpp
yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

```

这段代码是一个C语言程序，它定义了三个case，用于处理不同输入类型的规则。这些case用于定义输入源文件（src）和目标文件（DST）之间的关系。

具体来说，这些case定义了输入文件中每一行的内容应该属于哪个源文件或目标文件。根据输入文件的类型，这个程序会执行相应的YY_RULE_SETUP函数来设置这些文件的关系。然后，它会输出一条相应的YY_BREAK。

例如，当输入文件是src文件时，case 1会执行YY_RULE_SETUP函数，并将DST设置为src文件的下一个行。如果DST不存在，该程序会输出YY_BREAK。

当输入文件是link文件时，case 3会执行YY_RULE_SETUP函数，并将LINK设置为link文件的下一个行。如果LINK不存在，该程序会输出YY_BREAK。

YY_RULE_SETUP函数的作用是设置输入文件和目标文件之间的关系。具体实现方式是YY_BREAK，意味着如果输入文件和目标文件不存在，该程序不会输出任何东西。


```cpp
case 1:
YY_RULE_SETUP
#line 256 "scanner.l"
return DST;
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 257 "scanner.l"
return SRC;
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 259 "scanner.l"
return LINK;
	YY_BREAK
```

这段代码是一个C语言程序，它定义了三个case，用于处理输入数据。这些case分别对应了输入数据类型为整型、字符型和浮点型的情况。

YY_RULE_SETUP是设置输入流规则的函数，它定义了输入流从何处开始读取数据，以及每个数据类型的输入最大长度。

YY_BREAK是一个汇编代码，用于输出一个警告，当程序在运行时遇到条件不满足的断点时，它会在屏幕上输出一个警告。

以下是代码的主要部分：

```cpp
YY_RULE_SETUP(INPUT_TYPE)
   YY_BREAK
```

其中，INPUT_TYPE是输入数据类型，这些case定义了输入流规则。例如，对于INPUT_TYPE为整型的情况，程序从输入流中读取最大长度为512的整数。

yy_rule_setup函数定义了输入流从文件开始读取以及每个数据类型的最大长度。

yy_break函数用于在程序运行时断开当前函数和条件，以允许程序在以后重新执行这些代码。


```cpp
case 4:
YY_RULE_SETUP
#line 260 "scanner.l"
return LINK;
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 261 "scanner.l"
return ARP;
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 262 "scanner.l"
return RARP;
	YY_BREAK
```

这段代码是一个 YY 工具链中的源代码，定义了三个 case 标签，对应不同的 TCP/IP 协议。这些标签用于设置规则。

具体来说，这段代码的作用是根据传入的协议，选择适当的 YY 规则。对于给定的协议，选择相应的类（如 IP、TCP 或 UDP），然后设置规则。这些规则会在扫描器中应用，用于对输入数据包进行匹配和处理。


```cpp
case 7:
YY_RULE_SETUP
#line 263 "scanner.l"
return IP;
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 264 "scanner.l"
return SCTP;
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 265 "scanner.l"
return TCP;
	YY_BREAK
```

这段代码是一个C语言程序，它定义了三个case，用于处理不同类型的输入数据。

1. 在case 10的下面，定义了一个返回类型为UDP的函数，这意味着这个函数接收一个IP数据报，并将其转发到目标IP地址。

2. 在case 11的下面，定义了一个返回类型为ICMP的函数，这意味着这个函数接收一个IP数据报，并将其发送回目标IP地址。

3. 在case 12的下面，定义了一个返回类型为IGMP的函数，这意味着这个函数接收一个IP数据报，并检查它是否属于一个IGMP协议的成员。

此外，还有一行代码设置了程序的输入来源为scanner.l文件。


```cpp
case 10:
YY_RULE_SETUP
#line 266 "scanner.l"
return UDP;
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 267 "scanner.l"
return ICMP;
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 268 "scanner.l"
return IGMP;
	YY_BREAK
```

这段代码是一个 YY 工具类，它定义了 13 个case 语句，用于定义不同情况下的 default 行为。这些 case 语句处理了不同类型的 "scanner.l" 文件中的规则集，包括 IGRP、PIM 和 VRRP。

具体来说，这段代码的作用是定义了三个 default 行为，分别为：

- 当扫描器文件包含 IGRP 规则集时，输出 "YY_RULE_SETUP IGRP"。
- 当扫描器文件包含 PIM 规则集时，输出 "YY_RULE_SETUP PIM"。
- 当扫描器文件包含 VRRP 规则集时，输出 "YY_RULE_SETUP VRRP"。

这些 default 行为将作为 "scanner.l" 文件的默认行为，除非 explicitly 地设置了其他规则集。


```cpp
case 13:
YY_RULE_SETUP
#line 269 "scanner.l"
return IGRP;
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 270 "scanner.l"
return PIM;
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 271 "scanner.l"
return VRRP;
	YY_BREAK
```

这段代码是一个 YY 工具条，用于在 C++17 中定义不同情况下的输出。这个工具条包含了三个 case 块，用于定义不同情况下的输出。

具体来说，这段代码的作用是定义了三个输出变量，分别是 CARP、RADIO 和 IPv6。这些输出变量可能在程序的其他部分中被用来进行初始化。


```cpp
case 16:
YY_RULE_SETUP
#line 272 "scanner.l"
return CARP;
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 273 "scanner.l"
return RADIO;
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 275 "scanner.l"
return IPV6;
	YY_BREAK
```

这段代码是一个 C 语言编写的典范输出库函数，它定义了三个 case 块，每个 case 块内部都有一个井井有条的排列好的整数 a[]。

这段代码的作用是输出给定的三个整数 a[] 中的最后一个元素，即变量 esp 的值。通过调用不同 case 中的函数，并根据不同输入设置不同的输出策略，实现了一个多路分摊器的设计。


```cpp
case 19:
YY_RULE_SETUP
#line 276 "scanner.l"
return ICMPV6;
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 277 "scanner.l"
return AH;
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 278 "scanner.l"
return ESP;
	YY_BREAK
```

这段代码是一个 YY 工具类，它定义了 24 个case 语句，用于定义输入文件中的规则。每个 case 语句定义了一个输入文件行的输入规则。

具体来说，这段代码的作用是定义了 24 个输入文件行的输入规则，用于识别输入文件中的文本模式。这些规则将在程序运行时被扫描，并根据输入文件的行数对应地执行相应的规则。


```cpp
case 22:
YY_RULE_SETUP
#line 280 "scanner.l"
return ATALK;
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 281 "scanner.l"
return AARP;
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 282 "scanner.l"
return DECNET;
	YY_BREAK
```

这段代码是一个ycode文件中的一个规则，可以被分为三个case子句。

这段代码的作用是定义了三个变量LAT、SCA和MOPRC，并根据它们设置了一个YY_RULE_SETUP和YY_BREAK计数器。每个case子句中的代码块都会被执行一次，即如果设置了计数器，计数器中的值将会被设置为该case子句在文件中的行号。

YY_RULE_SETUP和YY_BREAK是两个头文件，可能是用于定义或输出某种规则的说明。具体的作用取决于上下文，无法确定。


```cpp
case 25:
YY_RULE_SETUP
#line 283 "scanner.l"
return LAT;
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 284 "scanner.l"
return SCA;
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 285 "scanner.l"
return MOPRC;
	YY_BREAK
```

这段代码是一个三入一出的条件分支，用于在不同的输入条件下选择不同的输出模式。

具体来说，代码会读取三个输入值，并根据这些输入值来选择要输出的模式。如果输入值为28，则输出模式为MOPDL；如果输入值为29或30，则输出模式为ISO或ESIS，而不是之前设置的模式。在输出模式选择后，代码会通过YY_BREAK断开当前分支和控制流，确保只会进入下一个分支中。


```cpp
case 28:
YY_RULE_SETUP
#line 286 "scanner.l"
return MOPDL;
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 288 "scanner.l"
return ISO;
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 289 "scanner.l"
return ESIS;
	YY_BREAK
```

这段代码是一个三路进制的switch语句，用于在扫描器准备好输入数据时，根据输入数据选择相应的输出文件。

具体来说，当扫描器准备好输入数据后，它将依次读取输入数据，并尝试根据输入数据选择ESIS、ISIS或YY_RULE_SETUP中的一个。如果成功选择了ESIS，输出YY_RULE_SETUP；如果成功选择了ISIS，输出YY_RULE_SETUP；如果成功选择了YY_RULE_SETUP，则不执行输出语句，继续读取输入数据。

这个代码的作用是，在扫描器准备好输入数据时，根据输入数据选择相应的输出文件，以便于后续处理。


```cpp
case 31:
YY_RULE_SETUP
#line 290 "scanner.l"
return ESIS;
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 291 "scanner.l"
return ISIS;
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 292 "scanner.l"
return ISIS;
	YY_BREAK
```

这段代码是一个C语言程序，它定义了三个case语句，用于处理不同输入类型的token。

第一个case语句定义了一个名为34的case块，它的作用是返回L1变量。然后，它包含了一个包含两个YY_RULE_SETUP和YY_BREAK的代码块。YY_RULE_SETUP用于设置输入流中的token，而YY_BREAK用于跳过当前输入流中的token。

第二个case语句定义了一个名为35的case块，它的作用是返回L2变量。然后，它包含了一个包含两个YY_RULE_SETUP和YY_BREAK的代码块。与第一个case块相同，YY_RULE_SETUP用于设置输入流中的token，而YY_BREAK用于跳过当前输入流中的token。

第三个case语句定义了一个名为36的case块，它的作用是返回IIH变量。然后，它包含了一个包含两个YY_RULE_SETUP和YY_BREAK的代码块。与前两个case块相同，YY_RULE_SETUP用于设置输入流中的token，而YY_BREAK用于跳过当前输入流中的token。

整个程序的作用是读取用户输入的一行文本，并根据用户输入的数字返回一个整数类型的token。


```cpp
case 34:
YY_RULE_SETUP
#line 293 "scanner.l"
return L1;
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 294 "scanner.l"
return L2;
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 295 "scanner.l"
return IIH;
	YY_BREAK
```

这段代码是一个名为 "YY_RULE_SETUP" 的函数，它定义了三个 case 语句，每个 case 后面跟着一个函数返回值。这些 case 语句定义了三个不同情况，它们分别是：

1. 当测试 number 37 时，代码将返回 LSP。
2. 当测试 number 38 时，代码将返回 SNP。
3. 当测试 number 39 时，代码将返回 CSNP。

YY_RULE_SETUP 和 YY_BREAK 是两个伪代码指令，它们的作用是在代码块中插入和输出行。


```cpp
case 37:
YY_RULE_SETUP
#line 296 "scanner.l"
return LSP;
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 297 "scanner.l"
return SNP;
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 298 "scanner.l"
return CSNP;
	YY_BREAK
```

这段代码是一个文本输入输出游戏中的规则。这个游戏应该有一个输入源和一个输出源。输入源读取玩家输入的规则文本，输出源将显示给玩家看到的屏幕上的结果。

这里我们关注的只有输出源，也就是最后两行。这两行代码会根据输入的规则文本，输出相应的结果。

具体来说，这段代码的作用是：

1. 当玩家输入的规则数量为40、41或42时，程序会执行相应的 case 语句。
2. 在每个 case 块中，程序会先执行 case 块内的代码。
3. 如果 case 块内有 return PSNP; 或者 return CLNP; 或者 return STP; 这三行代码，那么程序会返回相应的结果，并输出到屏幕上。
4. 如果 case 块内没有这三行代码，那么程序会默认输出默认的结果（通常是空格）。


```cpp
case 40:
YY_RULE_SETUP
#line 299 "scanner.l"
return PSNP;
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 301 "scanner.l"
return CLNP;
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 303 "scanner.l"
return STP;
	YY_BREAK
```

这段代码是一个C语言程序，它定义了三个case，用于处理不同种类的网络协议。

这段代码的作用是判断扫描仪设置的网络接口类型，并根据设置的网络接口类型返回相应的IPX、NETBEUI或HOST。

具体来说，当设置的网络接口类型为43时，代码将返回IPX，这意味着扫描仪将使用IPX(CMIP)协议进行网络通信。当设置的网络接口类型为44时，代码将返回NETBEUI，这意味着扫描仪将使用NETBEUI(NetBIOS over TCP/IP)协议进行网络通信。当设置的网络接口类型为45时，代码将返回HOST，这意味着扫描仪将使用HOST(主机)协议进行网络通信，可能是通过本地主机进行通信。


```cpp
case 43:
YY_RULE_SETUP
#line 305 "scanner.l"
return IPX;
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 307 "scanner.l"
return NETBEUI;
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 309 "scanner.l"
return HOST;
	YY_BREAK
```

这段代码是一个C语言代码，它是一个多选题，有四个case语句。

这个代码的作用是扫描四个不同类型的网络地址，包括IP地址（NET），子网掩码（NETMASK），端口号（PORT），IPv6地址（NETMASK）。

在这些case语句中，有一个YY_RULE_SETUP预处理指令，它告诉编译器在代码下面会有一条规则设置（SETUP）指令。这里假设编译器支持这种形式的预处理指令。如果没有支持，这个代码可能会被认为是无效的。

然后是case语句，每个case语句下面紧跟着一个if语句。如果测验为TRUE，那么case语句内部的代码会被执行，然后是YY_BREAK结束指令，它会输出一条警告信息。如果case语句为FALSE，那么不执行case语句内部的代码，而是直接跳过。

具体来说，这些case语句的作用如下：

1. 在case 46：中，设置预处理指令，然后执行以下SETUP指令。
2. 在 case 46：中，设置预处理指令，然后执行以下SETUP指令。
3. 在 case 47：中，设置预处理指令，然后执行以下SETUP指令。
4. 在 case 48：中，设置预处理指令，然后执行以下SETUP指令。
5. 在 case 46, case 47, case 48中，如果测验为TRUE，那么会输出一条警告信息。


```cpp
case 46:
YY_RULE_SETUP
#line 310 "scanner.l"
return NET;
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 311 "scanner.l"
return NETMASK;
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 312 "scanner.l"
return PORT;
	YY_BREAK
```

这段代码是一个if语句，根据数字49、50或51设置了不同的返回值。49、50和51是case语句的输入值，它们会根据设置的规则决定返回哪个值，然后执行相应的YY_BREAK语句。

具体来说，这段代码的作用是判断49、50或51的值，然后返回相应的值。通过这种自定义返回值的方式，可以用于系统中的不同情况，提高程序的灵活性和可维护性。


```cpp
case 49:
YY_RULE_SETUP
#line 313 "scanner.l"
return PORTRANGE;
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 314 "scanner.l"
return PROTO;
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 315 "scanner.l"
return PROTOCHAIN;
	YY_BREAK
```

这段代码是一个C语言程序，它是一个文本文件中的一个案例。这个程序的作用是读取输入文件中的内容，然后根据一定的规则进行处理，并将结果输出到控制台。

具体来说，这个程序可以读取包含三个不同输入类型的文件。对于每种输入类型，程序会执行相应的规则，并输出一个字符串类型的结果。然后，程序会输出一个包含三个字符的遥信类型YY_RULE_SETUP。最后，程序会输出一个包含三个字符的遥信类型YY_BREAK。


```cpp
case 52:
YY_RULE_SETUP
#line 317 "scanner.l"
return GATEWAY;
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 319 "scanner.l"
return TYPE;
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 320 "scanner.l"
return SUBTYPE;
	YY_BREAK
```

这段代码是一个 YY 规则，用于读取 scanner 文件中的输入数据。它通过 case 55 和 case 57 进入设置不同的输入数据，然后通过 return DIR 和 return ADDR1/ADDR2 返回输入数据中的 address 字段。具体来说，这段代码的作用是设置输入数据中的 address 字段，使得输入数据按照规则进行解析和匹配。


```cpp
case 55:
YY_RULE_SETUP
#line 321 "scanner.l"
return DIR;
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 322 "scanner.l"
return ADDR1;
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 323 "scanner.l"
return ADDR2;
	YY_BREAK
```

这段代码是一个文本输入输出游戏中的规则文件，它定义了不同 case 的作用。

具体来说，这段代码定义了三个 case，分别是：

case 58:
   YY_RULE_SETUP
   #line 324 "scanner.l"
   return ADDR3;
   YY_BREAK
case 59:
   YY_RULE_SETUP
   #line 325 "scanner.l"
   return ADDR4;
   YY_BREAK
case 60:
   YY_RULE_SETUP
   #line 326 "scanner.l"
   return RA;
   YY_BREAK

其中，YY_RULE_SETUP 是设置规则的函数，#line 324,325 是输出到屏幕的语句，ADDR3,ADDR4 和 RA 是地址，分别对应于第 58,59,60 种情况需要求解的问题。

每次循环，程序会先执行 case 58, 59, 60 中的代码，然后输出对应结果，最后再输出一个循环开始的语句，让下一个循环重新执行。


```cpp
case 58:
YY_RULE_SETUP
#line 324 "scanner.l"
return ADDR3;
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 325 "scanner.l"
return ADDR4;
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 326 "scanner.l"
return RA;
	YY_BREAK
```

这段代码是一个三相嵌套的嵌套 case 语句，用于读取用户输入的两个整数，并根据输入的值输出一个 T升一个 L的规则。

具体来说，这段代码的作用是：首先，将输入的两个整数保存在变量 TA 和 LESS 中；然后，根据输入的整数大小，判断应该输出哪个字母 T，并输出；最后，使用 yy_rule_setup 函数来设置输出规则，YY_BREAK 函数来结束本次循环。


```cpp
case 61:
YY_RULE_SETUP
#line 327 "scanner.l"
return TA;
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 329 "scanner.l"
return LESS;
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 330 "scanner.l"
return GREATER;
	YY_BREAK
```

这段代码是一个条件分支代码，用于根据数字 64、65 和 66 执行不同的操作。

当数字为 64 时，代码将跳转到第 331 行，执行一个名为 "YY_RULE_SETUP" 的函数，然后返回一个字节类型的变量 CBYTE。

当数字为 65 时，代码将跳转到第 332 行，执行一个名为 "YY_RULE_SETUP" 的函数，然后返回一个整数类型的变量 TK_BROADCAST，即将 TK_BROADCAST 宏设置为真。

当数字为 66 时，代码将跳转到第 333 行，执行一个名为 "YY_RULE_SETUP" 的函数，然后返回一个整数类型的变量 TK_MULTICAST，即将 TK_MULTICAST 宏设置为真。


```cpp
case 64:
YY_RULE_SETUP
#line 331 "scanner.l"
return CBYTE;
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 332 "scanner.l"
return TK_BROADCAST;
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 333 "scanner.l"
return TK_MULTICAST;
	YY_BREAK
```

这是一段使用Compiler编译的Python代码。它定义了三个case语句，每个case子句都定义了一个条件，如果条件为True，就执行YY_RULE_SETUP；如果条件为False，就跳过YY_RULE_SETUP，执行下一次case子句。

具体来说，这段代码的作用是：

1. 如果输入的扫描器文件名为"scanner.l"，则执行YY_RULE_SETUP，即输出"scanner.l"。
2. 如果输入的扫描器文件名为"system.py"，则执行YY_RULE_SETUP，即输出"system.py"。
3. 如果输入的扫描器文件名为任何其他名称，就跳过YY_RULE_SETUP，不输出任何内容。


```cpp
case 67:
YY_RULE_SETUP
#line 335 "scanner.l"
return AND;
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 336 "scanner.l"
return OR;
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 337 "scanner.l"
return '!';
	YY_BREAK
```

这段代码是一个名为“YY_RULE_SETUP”的函数，它定义了两个case语句，用于处理两个不同类型的目标字段。这些case语句检查输入文本中包含的目标字段是否以数字7开头。如果是数字7，则说明有特定类型的目标字段，需要返回相应的值。如果不是数字7，则说明没有特定类型的目标字段，需要执行其他操作。

代码的作用是根据输入文本中包含的目标字段，返回相应的值，或者执行其他操作。


```cpp
case 70:
YY_RULE_SETUP
#line 339 "scanner.l"
return LEN;
	YY_BREAK
case 71:
YY_RULE_SETUP
#line 340 "scanner.l"
return INBOUND;
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 341 "scanner.l"
return OUTBOUND;
	YY_BREAK
```

这段代码是一个用于配置串口通信的 YY_RULE_SETUP 规则。这个规则可以分成三个 case 块，分别对应不同的串口通信类型。

case 73:
这个 case 块是设置串口通信的波特率。具体地，它通过使用 IFINDEX 函数来获取设置值，并将设置值存储在 PORT2 中。

case 74:
这个 case 块是设置串口通信的 VLAN。具体地，它通过使用 IFINDEX 函数来获取设置值，并将设置值存储在 VLAN2 中。

case 75:
这个 case 块是设置串口通信的 MPLS。具体地，它通过使用 IFINDEX 函数来获取设置值，并将设置值存储在 MPLS2 中。

YY_BREAK 是一个汇编语言中的标签，用于输出代码中的块信息。它并不做任何实际的逻辑判断或者设置操作，只是一个代码标识，告诉编译器这个代码块在轮询规则时会被执行一次。


```cpp
case 73:
YY_RULE_SETUP
#line 343 "scanner.l"
return IFINDEX;
	YY_BREAK
case 74:
YY_RULE_SETUP
#line 345 "scanner.l"
return VLAN;
	YY_BREAK
case 75:
YY_RULE_SETUP
#line 346 "scanner.l"
return MPLS;
	YY_BREAK
```

这段代码是一个 C 语言程序，它定义了三个 case 语句，用于处理不同的输入情况。每个 case 语句都包含一个 label 和一个 returns 标号，表明它在这一层代码中会执行什么操作。

具体来说，这段代码的作用是读取一个文件中的扫描数据，并根据文件中每一行的内容，输出不同的结果。通过在 case 语句中使用 PPPOED 和 PPPOES 这两个变量，可以跟踪程序在扫描过程中的进展，以及记录最终的结果。而通过使用 YY_BREAK 标号，则可以在程序运行结束后退出 case 语句，从而完成整个文件的扫描。


```cpp
case 76:
YY_RULE_SETUP
#line 347 "scanner.l"
return PPPOED;
	YY_BREAK
case 77:
YY_RULE_SETUP
#line 348 "scanner.l"
return PPPOES;
	YY_BREAK
case 78:
YY_RULE_SETUP
#line 349 "scanner.l"
return GENEVE;
	YY_BREAK
```

这段代码是一个 C 语言编写的程序，可能用于读取并处理文本文件中的行。

它使用了 `YY_RULE_SETUP` 和 `YY_BREAK` 这两条指令来设置规则和跳出循环。

每个 `YY_RULE_SETUP` 指令用于设置规则，指定了一个字符串 `YY_RULE_NAME`，用于输入输出规则的名称。

每个 `YY_BREAK` 指令用于跳出循环，可能是用于在满足特定条件时停止程序的执行。

整个程序的作用是读取文本文件中的每一行，并根据行号 `YY_RULE_SETUP` 指定的规则输出相应的结果，或者跳出循环停止程序的执行。


```cpp
case 79:
YY_RULE_SETUP
#line 351 "scanner.l"
return LANE;
	YY_BREAK
case 80:
YY_RULE_SETUP
#line 352 "scanner.l"
return LLC;
	YY_BREAK
case 81:
YY_RULE_SETUP
#line 353 "scanner.l"
return METAC;
	YY_BREAK
```

这段代码是一个if语句，根据输入的数字，会执行对应case语句中的代码。

具体来说：

1. if(输入的数字 == 82)，会执行case 82中的代码，即：

YY_RULE_SETUP
#line 354 "scanner.l"
return BCC;

2. 如果输入的数字不是82，则会跳过if语句，执行else语句中的代码，即：

YY_BREAK

3. 如果在if语句的执行过程中，输入的数字等于84，则会执行case 84中的代码，即：

YY_RULE_SETUP
#line 356 "scanner.l"
return OAMF4;

4. 如果输入的数字不是84，则会跳过if语句，执行else语句中的代码，即：

YY_BREAK

5. 如果在if语句的执行过程中，输入的数字等于83或84，则会执行case 83或case 84中的代码，即：

YY_RULE_SETUP
#line 355 "scanner.l"
return OAM;

6. 如果输入的数字不是83或84，则会跳过if语句，执行else语句中的代码，即：

YY_BREAK


```cpp
case 82:
YY_RULE_SETUP
#line 354 "scanner.l"
return BCC;
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 355 "scanner.l"
return OAM;
	YY_BREAK
case 84:
YY_RULE_SETUP
#line 356 "scanner.l"
return OAMF4;
	YY_BREAK
```

这段代码是一个 C 语言编写的工具函数，它是用到了屏山扫描仪（YY_SCANNER）的协议。这个函数的作用是在扫描仪初始化之后，根据扫描仪的型号，返回对应的 OAMF4EC 或 OAMF4SC 值，用于在代码中进行分类。

这个代码可以被理解为：在扫描仪初始化成功后，根据传入的文件号，返回扫描仪原始的 LR 值。这个 LR 值对于屏山扫描仪来说，是固定的，并不会受到文件名的影响。


```cpp
case 85:
YY_RULE_SETUP
#line 357 "scanner.l"
return OAMF4EC;
	YY_BREAK
case 86:
YY_RULE_SETUP
#line 358 "scanner.l"
return OAMF4SC;
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 359 "scanner.l"
return SC;
	YY_BREAK
```

这段代码是一个 C 语言编写的函数，名为 "YY_RULE_SETUP"。它定义了三个 case 块，用于处理不同情况下的输入规则。

在每个 case 块中，首先定义了一个返回类型为整型的变量，名为 "ILMIC" 和 "VPI" 和 "VCI"，分别代表 " Implemented Legal Math Image Class" 和 "Valid Physical Input Class"。这两个变量没有定义任何成员变量，因此它们的值将永远都是 0。

接下来，函数中使用了三个名为 "YY_RULE_SETUP" 的函数，它们都定义了一个无参函数，它们的目的是在运行时初始化 YY 机器语言描述符。这些函数可能会在程序的其他部分中被调用，因此它们的实现可能非常复杂，需要使用其他函数和数据结构。

最后，在函数的结尾，使用了三个名为 "YY_BREAK" 的函数，它们也都定义了一个无参函数，它们的目的是在程序运行时跳出当前 case 块。


```cpp
case 88:
YY_RULE_SETUP
#line 360 "scanner.l"
return ILMIC;
	YY_BREAK
case 89:
YY_RULE_SETUP
#line 361 "scanner.l"
return VPI;
	YY_BREAK
case 90:
YY_RULE_SETUP
#line 362 "scanner.l"
return VCI;
	YY_BREAK
```

这段代码是一个名为 "YY_RULE_SETUP" 的 YAML 规则，定义了在与读取器（可能是一个不同设备或组件）连接时使用的一系列条件。

具体来说，这段代码定义了三种情况：

1. 当连接是 "scanner.l" 设备时，使用 "CONNECTMSG" 消息类型。
2. 当连接是 "scanner.l" 设备时，使用 "METACONNECT" 消息类型。
3. 当连接是一个文件名（可能是一个不同设备或组件）时，使用 "PF_IFNAME" 消息类型。

连接成功时，消息类型将被设置为 "CONNECTMSG"。


```cpp
case 91:
YY_RULE_SETUP
#line 363 "scanner.l"
return CONNECTMSG;
	YY_BREAK
case 92:
YY_RULE_SETUP
#line 364 "scanner.l"
return METACONNECT;
	YY_BREAK
case 93:
YY_RULE_SETUP
#line 366 "scanner.l"
return PF_IFNAME;
	YY_BREAK
```

这是一段使用Makefile编程语言（也称为YY格式的规则定义语言）编写的脚本。这段脚本定义了三个case，用于描述在一个名为“scanner.l”的源文件中发生的错误。

这段脚本的作用是当源文件“scanner.l”中存在这三种错误时，根据错误类型执行相应的case。

具体来说：

1. 当源文件“scanner.l”中存在名为“case 94:YY_RULE_SETUP”的case时，执行代码块“YY_RULE_SETUP”在“scanner.l”文件中的内容，然后跳回上一行并输出“PF_RSET”。

2. 当源文件“scanner.l”中存在名为“case 95:YY_RULE_SETUP”的case时，执行代码块“YY_RULE_SETUP”在“scanner.l”文件中的内容，然后跳回上一行并输出“PF_RNR”。

3. 当源文件“scanner.l”中存在名为“case 96:YY_RULE_SETUP”的case时，执行代码块“YY_RULE_SETUP”在“scanner.l”文件中的内容，然后跳回上一行并输出“PF_SRNR”。

通过这种方式，这段脚本可以确保在存在错误时，能够针对不同类型的错误采取不同的操作，从而提高程序的可读性和可维护性。


```cpp
case 94:
YY_RULE_SETUP
#line 367 "scanner.l"
return PF_RSET;
	YY_BREAK
case 95:
YY_RULE_SETUP
#line 368 "scanner.l"
return PF_RNR;
	YY_BREAK
case 96:
YY_RULE_SETUP
#line 369 "scanner.l"
return PF_SRNR;
	YY_BREAK
```

这段代码是一个简单的嵌套的 case 语句，它用于在不同的输入值下执行不同的函数。

1. 在 case 97和case 98的行中，YY_RULE_SETUP 和YY_BREAK 函数会被调用，但是在 case 99的行中，不会执行这些函数。
2. 在 case 97的行中，PF_REASON 函数会被调用，这个函数可能是用于在相乘之后计算结果的一种方式。
3. 在 case 98的行中，PF_ACTION 函数会被调用，这个函数也可能是用于在相乘之后计算结果的一种方式。
4. 在 case 99的行中，FISU 函数会被调用，这个函数很可能是用于处理错误情况的一种方式。


```cpp
case 97:
YY_RULE_SETUP
#line 370 "scanner.l"
return PF_REASON;
	YY_BREAK
case 98:
YY_RULE_SETUP
#line 371 "scanner.l"
return PF_ACTION;
	YY_BREAK
case 99:
YY_RULE_SETUP
#line 373 "scanner.l"
return FISU;
	YY_BREAK
```

这段代码是一个名为“YY_RULE_SETUP”的规则，它定义了两个条件判断块，分别对应数字 100 和 101。

在每个条件判断块中，代码会输出一个名为“LSSU”的标识符，并在标识符后面输出一个“YY_BREAK”符号。如果数字是 100，那么会输出“LSSU_100”并结束输出；如果数字是 101，那么会输出“LSSU_101”并结束输出。

具体来说，这段代码的作用是设置一个名为“YY_RULE_SETUP”的规则，并在规则中定义了两个条件判断块。这两个条件判断块分别对应数字 100 和 101，并在每个判断块中输出了一个名为“LSSU”的标识符。


```cpp
case 100:
YY_RULE_SETUP
#line 374 "scanner.l"
return LSSU;
	YY_BREAK
case 101:
YY_RULE_SETUP
#line 375 "scanner.l"
return LSSU;
	YY_BREAK
case 102:
YY_RULE_SETUP
#line 376 "scanner.l"
return MSU;
	YY_BREAK
```

这段代码是一个文本输入输出游戏中的规则。在这个游戏中，玩家需要通过输入不同数字的规则来获得胜利。每个规则都对应了一个case标签，当程序接收到这个case时，就会执行该case下的代码。

具体来说，这段代码可以实现以下功能：

1. 游戏规则setup中定义了三种变量：HFISU、HLSSU和HMSU，它们分别代表胜利分数为100、95和90的玩家。

2. 游戏规则setup中定义了一个case 103的判断块，该判断块会判断当前游戏是否为第103个规则。如果是，程序会执行case下的代码。

3. 在case 103下的代码中，程序会根据当前游戏的得分来设置胜利分数。例如，如果当前游戏的得分大于等于90，那么HFISU将会被设置为100，否则将设置为95。

4. 程序还定义了一个case 104的判断块，该判断块会判断当前游戏是否为第104个规则。如果是，程序会执行case下的代码。

5. 在case 104下的代码中，程序会根据当前游戏的得分来设置胜利分数。例如，如果当前游戏的得分大于等于95，那么HLSSU将会被设置为95，否则将设置为90。

6. 程序还定义了一个case 105的判断块，该判断块会判断当前游戏是否为第105个规则。如果是，程序会执行case下的代码。

7. 在case 105下的代码中，程序会根据当前游戏的得分来设置胜利分数。例如，如果当前游戏的得分大于等于95，那么HMSU将会被设置为95，否则将设置为90。


```cpp
case 103:
YY_RULE_SETUP
#line 377 "scanner.l"
return HFISU;
	YY_BREAK
case 104:
YY_RULE_SETUP
#line 378 "scanner.l"
return HLSSU;
	YY_BREAK
case 105:
YY_RULE_SETUP
#line 379 "scanner.l"
return HMSU;
	YY_BREAK
```

这段代码是一个用于指定输入输出文件、输出设备名称（如打印机或显示器）以及I/O操作类型的常量指针数组。它通过scanf函数从用户输入一个整数，然后根据输入的数字选择相应的I/O类型。

代码的作用是：
1. 如果用户输入的数字是106，则返回字符串SIO；
2. 如果用户输入的数字是107，则返回字符串OPC；
3. 如果用户输入的数字是108，则返回字符串DPC；
4. 如果用户输入的数字是109-111，则根据输入的数字选择相应的I/O类型，并返回该I/O类型的字符串表示。


```cpp
case 106:
YY_RULE_SETUP
#line 380 "scanner.l"
return SIO;
	YY_BREAK
case 107:
YY_RULE_SETUP
#line 381 "scanner.l"
return OPC;
	YY_BREAK
case 108:
YY_RULE_SETUP
#line 382 "scanner.l"
return DPC;
	YY_BREAK
```

这段代码是一个名为“YY_RULE_SETUP”的函数，它定义了三个case语句，用于处理不同情况下的输入。每个case语句都包含两行代码，第一行是函数内部的代码，第二行是注释。

这段代码的作用是读取输入数据，根据输入的数据类型，将其转换为相应的类型，然后返回对应的类型。具体实现如下：

1. 当输入数据类型为数字109时，函数将其转换为整型并返回整型。
2. 当输入数据类型为数字110时，函数将其转换为半双精度浮点型并返回半双精度浮点型。
3. 当输入数据类型为数字111时，函数将其转换为双精度浮点型并返回双精度浮点型。


```cpp
case 109:
YY_RULE_SETUP
#line 383 "scanner.l"
return SLS;
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 384 "scanner.l"
return HSIO;
	YY_BREAK
case 111:
YY_RULE_SETUP
#line 385 "scanner.l"
return HOPC;
	YY_BREAK
```

这是一个 Shell 脚本，名为 "rules.sh"。它定义了 4 个条件分支，用于处理不同情况。每个分支都包含一个条件，如果条件为真，则执行分支内的代码，并将结果存储到变量中。

具体来说，这段代码的作用是根据传入的规则编号（112、113、114）来决定使用哪个工具（HDPC、HSLS），并执行相应的操作。

具体实现如下：

1. 在开始时，定义了变量 HDPC 和 HSLS，它们分别用于存储 HDPC 和 HSLS 工具的路径。
2. 当条件为 112 时，执行分支代码块。
3. 在分支代码块中，使用 YY_RULE_SETUP 设置工具为 HDPC，并将结果存储到变量 "HDPC_PATH" 中。
4. 当条件为 113 时，执行分支代码块。
5. 在分支代码块中，使用 YY_RULE_SETUP 设置工具为 HSLS，并将结果存储到变量 "HSLS_PATH" 中。
6. 当条件为 114 时，判断是否匹配 EOF。如果是，则执行分支代码块。
7. 在分支代码块中，使用 YY_RULE_SETUP 设置工具为 HDPC，并将结果存储到变量 "HDPC_PATH" 中。


```cpp
case 112:
YY_RULE_SETUP
#line 386 "scanner.l"
return HDPC;
	YY_BREAK
case 113:
YY_RULE_SETUP
#line 387 "scanner.l"
return HSLS;
	YY_BREAK
case 114:
/* rule 114 can match eol */
YY_RULE_SETUP
#line 389 "scanner.l"
;
	YY_BREAK
```

这是一段将文本文件中的行按照给定的规则进行匹配并对匹配结果进行打印的代码。具体来说，这段代码的作用是读取一个名为“scanner.l”的文本文件，并按照给定的规则（case 115, case 116, case 117）对每一行进行匹配。如果匹配成功，则打印“YY_RULE_SETUP”和相应的结果（case 115: “YY_RULE_SETUP”），否则打印“YY_BREAK”。


```cpp
case 115:
YY_RULE_SETUP
#line 390 "scanner.l"
return yytext[0];
	YY_BREAK
case 116:
YY_RULE_SETUP
#line 391 "scanner.l"
return GEQ;
	YY_BREAK
case 117:
YY_RULE_SETUP
#line 392 "scanner.l"
return LEQ;
	YY_BREAK
```

这是一段使用 scanner.l 文件作为输入的编程代码。这段代码的作用是判断一个名为 "YY_RULE_SETUP" 的条件是否成立，如果是，就执行 body 内的代码，如果不是，则跳过 body 内的代码。body 内的代码包括三个 case 语句，分别对应三种不同的情况：

1. 当条件为 118 时，代码会执行 body 内的第一个语句，即 return NEQ;。
2. 当条件为 119 时，代码会执行 body 内的第二个语句，即 return '=';。
3. 当条件为 120 时，代码会执行 body 内的第三个语句，即 return LSH;。


```cpp
case 118:
YY_RULE_SETUP
#line 393 "scanner.l"
return NEQ;
	YY_BREAK
case 119:
YY_RULE_SETUP
#line 394 "scanner.l"
return '=';
	YY_BREAK
case 120:
YY_RULE_SETUP
#line 395 "scanner.l"
return LSH;
	YY_BREAK
```

这段代码是一个名为 "scanner.l" 的文件中的一个 C 语言函数。函数的作用是处理文本输入文件中的行，根据传入的行号进行不同的操作，并返回结果。

具体来说，该函数分为三个 case 块，每个 case 块内部都有一个 void 类型的函数指针，这些函数指针分别实现了对 "scanner.l" 文件中第 396、397、398 行数据的读取和处理。

第一个 case 块，函数指针为 "YY_RULE_SETUP"，该函数的作用是读取输入文件中第 396 行数据，根据行号 121 执行相应的操作，然后返回结果类型 "RSH"。

第二个 case 块，函数指针为 "YY_BREAK"，该函数的作用是退出第一个 case 块，并返回一个空缺的 "void" 类型。

第三个 case 块，函数指针为 "YY_RULE_SETUP"，该函数的作用是在 case 块内部创建一个新的字符串变量 "yyextra"，并将其长度设置为传入的行号减 1，然后读取输入文件中第 397 行数据，并将其存储到 "yyextra" 指向的字符串中。接着，函数指针返回结果类型 "AID"，表示成功读取到了行数据。

第四个 case 块，函数指针为 "YY_BREAK"，该函数的作用是退出所有的 case 块，并返回一个空缺的 "void" 类型。


```cpp
case 121:
YY_RULE_SETUP
#line 396 "scanner.l"
return RSH;
	YY_BREAK
case 122:
YY_RULE_SETUP
#line 397 "scanner.l"
{ yylval->s = sdup(yyextra, yytext); return AID; }
	YY_BREAK
case 123:
YY_RULE_SETUP
#line 398 "scanner.l"
{ yylval->s = sdup(yyextra, yytext); return EID; }
	YY_BREAK
```

这段代码是一个识别文本文件中的 YY 记号，并根据它们在文本中的位置进行不同的操作。

具体来说，代码会扫描文本文件中的每个 YY 记号，并对应执行不同的case语句。在这些case语句中，程序会执行一些操作，例如将字符串转换为整数、将整数转换为字符串或者复制字符串等。

YY_RULE_SETUP和YY_BREAK是输出语句，用于生成YY项目的预处理和后处理。YY_RULE_SETUP用于设置YY项目的规则，而YY_BREAK用于输出设置规则后的结果。


```cpp
case 124:
YY_RULE_SETUP
#line 399 "scanner.l"
{ return stou(yytext, yylval, yyextra); }
	YY_BREAK
case 125:
YY_RULE_SETUP
#line 400 "scanner.l"
{
			yylval->s = sdup(yyextra, (char *)yytext); return HID; }
	YY_BREAK
case 126:
YY_RULE_SETUP
#line 402 "scanner.l"
{
```

这段代码是一个用于检测 Linux 系统是否支持 IPv6 协议的示例。它使用了 `getaddrinfo` 函数来获取 IPv6 地址信息，然后使用 `if` 语句检查获取的地址是否支持 IPv6。如果是 IPv6 支持，则使用 `freeaddrinfo` 释放内存，并使用 `supercmd` 函数将 IPv6 地址复制到 `yyextra` 变量中。否则，它会输出一条错误消息并设置 `yylval->s` 为 `NULL`。


```cpp
#ifdef INET6
			  struct addrinfo hints, *res;
			  memset(&hints, 0, sizeof(hints));
			  hints.ai_family = AF_INET6;
			  hints.ai_flags = AI_NUMERICHOST;
			  if (getaddrinfo(yytext, NULL, &hints, &res)) {
				bpf_set_error(yyextra, "bogus IPv6 address %s", yytext);
				yylval->s = NULL;
			  } else {
				freeaddrinfo(res);
				yylval->s = sdup(yyextra, (char *)yytext);
			  }
#else
			  bpf_set_error(yyextra, "IPv6 address %s not supported", yytext);
			  yylval->s = NULL;
```

这段代码是一个C语言程序的头文件，其中包含了一些用于处理YAML格式的数据定义。

具体来说，这个程序定义了一个名为HID6的函数，它接受一个表示IPv6地址的参数。如果IPv6地址是有效的，那么函数返回IPv6地址；否则，函数返回错误代码。

此外，这个程序还定义了三个用于处理YAML文件的函数，分别是YY_BREAK、YY_RULE_SETUP和YY_RULE_CALL。这些函数用于处理YYAML文件中的规则，包括输入输出、错误处理和函数调用等。

最后，该程序还定义了一个常量INET6，用于表示输入的IPv6地址。


```cpp
#endif /*INET6*/
			  return HID6;
			}
	YY_BREAK
case 127:
YY_RULE_SETUP
#line 421 "scanner.l"
{ bpf_set_error(yyextra, "bogus ethernet address %s", yytext); yylval->s = NULL; return EID; }
	YY_BREAK
case 128:
YY_RULE_SETUP
#line 422 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 129:
```

这是一段C语言代码，定义了两个全局变量YY_RULE_SETUP和YY_RULE_CONT，以及一个内部函数YY_BREAK。这个函数的作用是断开当前输入的多行字符串，将输入的字符串存储在YY_RULE_SETUP内部。

YY_RULE_SETUP的作用是设置YY_RULE_CONT的值，使YY_RULE_CONT的值与输入的多行字符串中第1个字节的ASCII值相同。具体实现如下：

1. 定义了一个常量130，用于YY_RULE_SETUP函数的输入判断。
2. 定义了一个内部函数YY_BREAK，用于处理输入的多行字符串。
3. YY_RULE_SETUP函数内部，通过一个寄存器变量YY_RULE_CONT，来存储当前输入的多行字符串。
4. 如果输入的多行字符串中第1个字节的ASCII值等于130，则将YY_RULE_CONT的值设置为1，即与输入的多行字符串中第1个字节的ASCII值相同。
5. 通过循环131和132，实现断开输入的多行字符串，并存储YY_RULE_CONT的值。


```cpp
YY_RULE_SETUP
#line 423 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 130:
YY_RULE_SETUP
#line 424 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 131:
YY_RULE_SETUP
#line 425 "scanner.l"
{ yylval->h = 3; return NUM; }
	YY_BREAK
case 132:
```

这段代码是一个名为 "scanner.l" 的文件中的一个 C 语言源代码。它定义了一个名为 "YY_RULE_SETUP" 的函数，以及一个名为 "YY_BREAK" 的标签。

具体来说，这个源文件定义了一个常量 "YY_RULE_SETUP"，它被赋值为 4。然后，它定义了一个名为 "case 133:"，接着定义了一个名为 "YY_RULE_SETUP" 的函数，这个函数体被留空，然后被返回一个整数类型的值 "NUM"。

在 "case 133:" 下面的语句段中，定义了三个名为 "YY_RULE_SETUP" 的函数，它们的参数列表如下：

{ yylval->h = 4; return NUM; }

{ yylval->h = 5; return NUM; }

{ yylval->h = 8; return NUM; }

在 "YY_BREAK" 标签下面的代码段中，似乎没有做任何操作。


```cpp
YY_RULE_SETUP
#line 426 "scanner.l"
{ yylval->h = 4; return NUM; }
	YY_BREAK
case 133:
YY_RULE_SETUP
#line 427 "scanner.l"
{ yylval->h = 5; return NUM; }
	YY_BREAK
case 134:
YY_RULE_SETUP
#line 428 "scanner.l"
{ yylval->h = 8; return NUM; }
	YY_BREAK
case 135:
```

这段代码是一个C语言程序的局部变量，定义了三个变量 `YY_RULE_SETUP` 和 `YY_BREAK`，用于跟踪扫描器是否已设置完成，以及设置完成后打印出的行号。

具体来说，该程序可以扫描一个由数字组成的输入行，每次扫描后设置 `YY_RULE_SETUP` 变量的值为行号加一，然后打印出来。当扫描完所有数字后，会输出一个提示信息并进入下一个循环。

代码中定义的 `YY_RULE_SETUP` 和 `YY_BREAK` 变量分别用于设置和输出扫描器的规则。在 `case 136` 和 `case 137` 内，分别定义了 `YY_RULE_SETUP` 变量在扫描数字为 136 和 137 时执行的操作。


```cpp
YY_RULE_SETUP
#line 429 "scanner.l"
{ yylval->h = 9; return NUM; }
	YY_BREAK
case 136:
YY_RULE_SETUP
#line 430 "scanner.l"
{ yylval->h = 10; return NUM; }
	YY_BREAK
case 137:
YY_RULE_SETUP
#line 431 "scanner.l"
{ yylval->h = 11; return NUM; }
	YY_BREAK
case 138:
```

这是一段C语言代码，定义了三个变量yylval，并在其前分别加上了变量名h的整数类型。接着，代码使用了一个名为YY_RULE_SETUP的标签，即开始了一个内联函数。该函数体中，定义了两个名为YY_BREAK的标签，这意味着该函数只能在其内部被调用，而且可以在这两个标签内直接使用代码块。

进一步分析可以发现，这段代码的作用是定义了一个输入为数字的scanner，给定的输入为12-140，然后根据输入值输出一个整数类型的变量。其中，输出结果分别为12、13、14。


```cpp
YY_RULE_SETUP
#line 432 "scanner.l"
{ yylval->h = 12; return NUM; }
	YY_BREAK
case 139:
YY_RULE_SETUP
#line 433 "scanner.l"
{ yylval->h = 13; return NUM; }
	YY_BREAK
case 140:
YY_RULE_SETUP
#line 434 "scanner.l"
{ yylval->h = 14; return NUM; }
	YY_BREAK
case 141:
```

这是一段将一个整型变量 `YY_RULE_SETUP` 中的值逐个增加并返回编号的代码。

具体来说，代码会遍历 `YY_RULE_SETUP` 所在的文件中的第 435 行，然后在每个循环中，将 `YY_RULE_SETUP` 中的值增加 1，并返回增加后的值。当循环结束后，整个程序会返回增加的最后一个值作为结果。

这里使用了 `NUM` 作为变量名，可能是要表示循环计数器，但官方文档中没有明确说明。


```cpp
YY_RULE_SETUP
#line 435 "scanner.l"
{ yylval->h = 15; return NUM; }
	YY_BREAK
case 142:
YY_RULE_SETUP
#line 436 "scanner.l"
{ yylval->h = 16; return NUM; }
	YY_BREAK
case 143:
YY_RULE_SETUP
#line 437 "scanner.l"
{ yylval->h = 17; return NUM; }
	YY_BREAK
case 144:
```

这段代码是一个 C 语言编写的工具函，它定义了两个函数 `YY_RULE_SETUP` 和 `YY_BREAK`，用于处理文本文件中的行信息。这两个函数的作用是在读取文本文件时根据行号设置一个变量 `YY_RULE_SETUP` 的值，然后根据设置的值输出一条信息并返回一个整数 `NUM`。

具体来说，这段代码可以被理解为：

1. 在开始处理文本文件时，先定义了两个函数 `YY_RULE_SETUP` 和 `YY_BREAK`。
2. 在 `YY_RULE_SETUP` 函数中，定义了一个名为 `YY_RULE_SETUP` 的函数，它的输入参数 `yylval` 是一个指向 `scanner.l` 文件的指针，函数内部根据输入的行号设置变量 `h` 的值，然后返回一个整数 `NUM`。
3. 在 `YY_BREAK` 函数中，定义了一个名为 `YY_RULE_SETUP` 的函数，它的输入参数 `yylval` 与 `YY_RULE_SETUP` 函数相同，但返回一个整数 `NUM`，表示已经处理完整个文件。
4. 在文本文件中，每行包含一个规则名称，例如 "rule145" 和 "rule146"。
5. 在 `YY_RULE_SETUP` 函数中，根据行号设置变量 `YY_RULE_SETUP` 中的变量，例如，对于 "rule145"，会设置 `YY_RULE_SETUP` 中的 `h` 为 18，然后返回整数 NUM。
6. 在 `YY_BREAK` 函数中，直接输出整数 NUM，表示已经处理完整个文件。


```cpp
YY_RULE_SETUP
#line 438 "scanner.l"
{ yylval->h = 18; return NUM; }
	YY_BREAK
case 145:
YY_RULE_SETUP
#line 440 "scanner.l"
{ yylval->h = 0; return NUM; }
	YY_BREAK
case 146:
YY_RULE_SETUP
#line 441 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 147:
```

这段代码是一个 C 语言编写的工具函，属于 yy 工具函的一部分。YY 工具函是一个 C 语言库，用于处理 yy 解析器中的语法错误。

具体来说，这段代码定义了一个名为 "YY_RULE_SETUP" 的函数。这个函数的作用是在输入的规则中查找某个特定头部的最后一个字符，然后根据这个特定头部字符的值来跳转到另一个规则。如果找到了目标头部，函数将返回目标行号，否则返回 num；如果没有找到目标头部，函数将返回 num。

代码中包含了一系列的 case 语句，每个 case 语句后面都有一段注释。这些注释解释了这段代码的功能，说明了在哪些情况下会使用到它们。


```cpp
YY_RULE_SETUP
#line 443 "scanner.l"
{ yylval->h = 1; return NUM; }
	YY_BREAK
case 148:
YY_RULE_SETUP
#line 444 "scanner.l"
{ yylval->h = 2; return NUM; }
	YY_BREAK
case 149:
YY_RULE_SETUP
#line 445 "scanner.l"
{ yylval->h = 3; return NUM; }
	YY_BREAK
case 150:
```

这是一段C语言代码，定义了三个case标号，属于YY_RULE_SETUP函数。这个函数的作用是在读取扫描仪输入数据时，根据输入的数据类型设置断言规则。具体实现如下：

1. 当输入数据类型为整型时，设置断言规则为case 151，即将数据值与128比较，如果相等，则返回NUM，否则返回NOTNUM。

2. 当输入数据类型为浮点型（float），且数据值在-3.2E+38至3.2E+38之间时，设置断言规则为case 152，即将数据值与129比较，如果相等，则返回NUM，否则返回NOTNUM。

3. 当输入数据类型为浮点型（float），数据值超出-3.2E+38至3.2E+38范围时，设置断言规则为case 153，没有进一步的实现。

4. 最后，函数返回数值NUM，如果设置的断言规则为NOTNUM，返回NOTNUM。


```cpp
YY_RULE_SETUP
#line 446 "scanner.l"
{ yylval->h = 4; return NUM; }
	YY_BREAK
case 151:
YY_RULE_SETUP
#line 447 "scanner.l"
{ yylval->h = 128; return NUM; }
	YY_BREAK
case 152:
YY_RULE_SETUP
#line 448 "scanner.l"
{ yylval->h = 129; return NUM; }
	YY_BREAK
case 153:
```

这段代码是一个 C 语言编写的工具函，属于 YY 库，用于读取 YY 库中的规则文件。YY 库是一个用于解析 JSON 规则文件的标准库，可以支持多种输入输出格式，包括 JL（JSON 轻量级）和 ML（JSON 摩尔斯语言）。

具体来说，这段代码的作用是读取 YY 库中的 scanner.l 文件中的规则，并打印出每个规则的 h 值。h 值在 JSON 文件中以数字 130、131、132 等开头，用于标识该规则的索引号。在阅读完所有规则后，可能会发生 YY 库约定的 "YY_BREAK" 情况，此时会将所有规则的 h 值打印出来，并终止程序的读取和解析操作。


```cpp
YY_RULE_SETUP
#line 449 "scanner.l"
{ yylval->h = 130; return NUM; }
	YY_BREAK
case 154:
YY_RULE_SETUP
#line 450 "scanner.l"
{ yylval->h = 131; return NUM; }
	YY_BREAK
case 155:
YY_RULE_SETUP
#line 451 "scanner.l"
{ yylval->h = 132; return NUM; }
	YY_BREAK
case 156:
```

这是一段通用的文本输入输出代码，定义了不同情况下的函数出口。具体来说，这段代码定义了三个函数：scanner_start、scanner_end 和 yy_rule_setup。

1. scanner_start 函数的作用是在输入开始时设置断言句柄，并返回 1。这个函数只在开始输入时设置一次，用于确保程序能够正确地开始读取输入行。

2. scanner_end 函数的作用是在输入结束时设置断言句柄，并返回 1。这个函数只在输入结束时设置一次，用于确保程序能够正确地结束读取输入行。

3. yy_rule_setup 函数的作用是在开始输入行时设置断言句柄，并返回一个整数常量。这个函数会在每次输入行开始时设置断言句柄，确保程序能够正确地识别输入的语言规则。

这段代码的作用是定义了三个函数，用于控制文本输入输出的开始和结束，并确保程序在输入开始和结束时能够正确地识别输入的语言规则。


```cpp
YY_RULE_SETUP
#line 452 "scanner.l"
{ yylval->h = 133; return NUM; }
	YY_BREAK
case 157:
YY_RULE_SETUP
#line 453 "scanner.l"
{ yylval->h = 134; return NUM; }
	YY_BREAK
case 158:
YY_RULE_SETUP
#line 454 "scanner.l"
{ yylval->h = 135; return NUM; }
	YY_BREAK
case 159:
```

这是一段用TeX格式编写的Python代码。`YY_RULE_SETUP` 和 `YY_BREAK` 是批处理文件中的两个输出指令，它们用于输出一个名为 `scanner.l` 的文件，并在每个输出行后输出一个数值 `NUM`。

具体来说，这段代码的作用是读取 `scanner.l` 文件中的行，然后根据传入的规则集号（通过 `YY_RULE_SETUP` 和 `YY_BREAK` 指令指定），对每一行输出一个数值。规则集号是在程序运行时传递给程序的，而在这里我们只能看到两个输出实例。


```cpp
YY_RULE_SETUP
#line 455 "scanner.l"
{ yylval->h = 136; return NUM; }
	YY_BREAK
case 160:
YY_RULE_SETUP
#line 456 "scanner.l"
{ yylval->h = 137; return NUM; }
	YY_BREAK
case 161:
YY_RULE_SETUP
#line 457 "scanner.l"
{ yylval->h = 138; return NUM; }
	YY_BREAK
case 162:
```

这是一段用Emacs编辑器输出的Python代码。这段代码定义了一个名为“YY_RULE_SETUP”的规则，在输入字符串“scanner.l”时，如果输入的字符属于数字0到9，则返回数字139；如果是字母A到Z，则返回数字140。规则使用了一个名为“NUM”的变量来存储返回的数字。代码中使用了嵌套的“YY_BREAK”案例结构，用于在规则匹配成功时和匹配失败时退出规则循环。


```cpp
YY_RULE_SETUP
#line 458 "scanner.l"
{ yylval->h = 139; return NUM; }
	YY_BREAK
case 163:
YY_RULE_SETUP
#line 459 "scanner.l"
{ yylval->h = 140; return NUM; }
	YY_BREAK
case 164:
YY_RULE_SETUP
#line 460 "scanner.l"
{ yylval->h = 141; return NUM; }
	YY_BREAK
case 165:
```

这段代码是一个C语言程序的局部变量声明，定义了三个变量分别命名为YY_RULE_SETUP、YY_BREAK和YY_RULE_SETUP。

YY_RULE_SETUP定义了一个整型变量YY_RULE_SETUP，并将其赋值为142。然后返回一个整型常量NUM，表示程序会继续执行该规则。

YY_BREAK定义了一个case结构体，其中包含一个名为YY_RULE_SETUP的case。然后定义了一个整型变量YY_RULE_SETUP，并将其赋值为143。接下来，使用了一个if语句，判断当前行数是否为166、167或168。如果是166或167，那么就会执行YY_RULE_SETUP中的代码，即定义一个整型变量YY_RULE_SETUP，并将其赋值为144，然后返回一个整型常量NUM。如果是168，那么就会跳过YY_RULE_SETUP中的代码，直接执行下一个case结构体。

最后，该程序没有返回任何值，使用了一个continue语句来跳过YY_RULE_SETUP中的代码，并继续执行后续代码。


```cpp
YY_RULE_SETUP
#line 461 "scanner.l"
{ yylval->h = 142; return NUM; }
	YY_BREAK
case 166:
YY_RULE_SETUP
#line 462 "scanner.l"
{ yylval->h = 143; return NUM; }
	YY_BREAK
case 167:
YY_RULE_SETUP
#line 463 "scanner.l"
{ yylval->h = 144; return NUM; }
	YY_BREAK
case 168:
```

这是一段使用S scanner库的Python代码。S scanner是一个用于输入和输出文本文件的库，可以读取文件中的行并执行某些操作。

具体来说，这段代码的作用是读取一个名为"scanner.l"的文件，每行包含一个数字，并将每行的数字存储在YY_RULE_SETUP变量中。然后，根据输入的数字，会执行以下操作：

1. 如果数字为169，则执行YY_RULE_SETUP，并将YY_RULE_SETUP中的h值设置为145，然后返回NUM。
2. 如果数字为170或171，则执行YY_BREAK，这将终止当前输入读取线程。

这段代码可能是在扫描一个包含一些整数的文本文件，并根据文件中的每一行执行一些规则或操作。


```cpp
YY_RULE_SETUP
#line 464 "scanner.l"
{ yylval->h = 145; return NUM; }
	YY_BREAK
case 169:
YY_RULE_SETUP
#line 465 "scanner.l"
{ yylval->h = 146; return NUM; }
	YY_BREAK
case 170:
YY_RULE_SETUP
#line 466 "scanner.l"
{ yylval->h = 147; return NUM; }
	YY_BREAK
case 171:
```

这段代码是一个 C 语言程序，可能是一个用于输入或输出文本的工具，通过 `scanf` 函数从用户输入一些内容，并在输入内容达到一定规则时执行一些操作。

`YY_RULE_SETUP` 和 `YY_BREAK` 是预处理指令，用于告诉编译器在代码下面的 `YY_RULE_SETUP` 和 `YY_BREAK` 行之前和之后的代码块内是规则设置和分支控制。

具体来说，这段代码的作用是读取用户输入的一行文本，然后判断输入是否符合某种规则。如果符合规则，程序会执行相应的操作并返回一个数值 `NUM`。如果不符合规则，程序会输出一条错误消息并退出。


```cpp
YY_RULE_SETUP
#line 467 "scanner.l"
{ yylval->h = 148; return NUM; }
	YY_BREAK
case 172:
YY_RULE_SETUP
#line 468 "scanner.l"
{ yylval->h = 149; return NUM; }
	YY_BREAK
case 173:
YY_RULE_SETUP
#line 469 "scanner.l"
{ yylval->h = 151; return NUM; }
	YY_BREAK
case 174:
```

这段代码是一个 C 语言程序，可能是一个用于解析 yy 工具包的输入文件中的规则的程序。

YY_RULE_SETUP 是一个循环，用于读取输入文件中的规则，并设置相应的值，然后返回数字 NUM。

case 175,176,177 等是循环标记，表示这是一个多分支的 case 语句，会执行其中的代码块。

在 case 175 和 176 中，程序会设置 yylval 结构体的 h 成员。通过调用 yylval->h = 152 和 yylval->h = 153，分别将 h 成员的值设置为 152 和 153。然后，程序会通过 return NUM 语句返回数字 NUM，表示符合这两个 case 中的任何一个时返回的值。

在 case 177 中，程序会执行一个空语句，即不执行任何操作。


```cpp
YY_RULE_SETUP
#line 470 "scanner.l"
{ yylval->h = 152; return NUM; }
	YY_BREAK
case 175:
YY_RULE_SETUP
#line 471 "scanner.l"
{ yylval->h = 153; return NUM; }
	YY_BREAK
case 176:
YY_RULE_SETUP
#line 473 "scanner.l"
{ yylval->h = 13; return NUM; }
	YY_BREAK
case 177:
```

这是一段将字符'Y'（数字4）输出到控制台并在第474行设置行高为0x01（1个字符）的代码。接下来是扫描器规则的设置。

具体来说，这段代码实现了以下功能：

1. 在程序运行时，当读取到'Y'时，执行YY_RULE_SETUP函数。
2. 在YY_RULE_SETUP函数中，当'Y'为数字4时，执行以下操作：
	1. 将变量yylval的h值设置为0x01（1个字符）。
	2. 返回数字4（'Y'的ASCII值）。
3. 在整个案例 178 和 179 的开始处，设置行高为0x01。
4. 在案例 180 的开始处，没有执行任何操作。


```cpp
YY_RULE_SETUP
#line 474 "scanner.l"
{ yylval->h = 0x01; return NUM; }
	YY_BREAK
case 178:
YY_RULE_SETUP
#line 475 "scanner.l"
{ yylval->h = 0x02; return NUM; }
	YY_BREAK
case 179:
YY_RULE_SETUP
#line 476 "scanner.l"
{ yylval->h = 0x04; return NUM; }
	YY_BREAK
case 180:
```

这是一个 C 语言程序，它定义了三个变量 `YY_RULE_SETUP`、`YY_BREAK` 和 ` case 181`、` case 182` 和 `case 183`。

`YY_RULE_SETUP` 和 `YY_BREAK` 定义了两个宏定义，它们的的作用是设置 `YY_RULE_SETUP` 和 `YY_BREAK` 两个宏的参数 `h` 的值都为 0x08，并将返回值设为 9(`NUM` 的值)。

`case 181:` 和 `case 182` 是两个三行代码块，它们都定义了一个 `YY_RULE_SETUP` 函数。这两个代码块中只有一行有注释，即上面的一行，说明这个代码块是用于输出结果的，而下一行则用于设置 `YY_RULE_SETUP` 和 `YY_BREAK` 宏的参数。

`case 183:` 是另一个代码块，它定义了一个 `YY_RULE_SETUP` 函数，但是这个函数没有设置任何参数，因此它的作用是不确定的。


```cpp
YY_RULE_SETUP
#line 477 "scanner.l"
{ yylval->h = 0x08; return NUM; }
	YY_BREAK
case 181:
YY_RULE_SETUP
#line 478 "scanner.l"
{ yylval->h = 0x10; return NUM; }
	YY_BREAK
case 182:
YY_RULE_SETUP
#line 479 "scanner.l"
{ yylval->h = 0x20; return NUM; }
	YY_BREAK
case 183:
```

这是一段使用yytext库的 C 语言代码。这个库似乎提供了一个用于输入和输出文本的功能，yytext 是一个 C 语言库，它可以在输入和输出时捕获和替换文本。不过我不确定这个库是否包含文件头 480-482 行，因为我在文件中找到了从 483 行开始的内容。

现在让我解释这段代码的作用：

1. `YY_RULE_SETUP` 和 `YY_BREAK` 是头文件，它们定义了输出文本的前缀。它们的作用是告诉编译器在编译之前进行一些自定义的预处理。

2. `yyval` 是 yytext 库的值结构体类型，它包含两个整型成员：`h` 表示当前输入的行号，`s` 表示当前输入的文本字符串。

3. `yytext` 是一个 C 语言库，它提供了一个用于处理文本的工具集。在这段代码中，它被用来读取输入文本并将其存储在 `yyval` 的 `s` 成员中。

4. `scanner.l` 是源文件名。

5. 以上代码的主要作用是定义了输入文本的格式，包括行号和文本字符串。然后通过 `yytext` 库将输入的文本存储到 `yyval` 的 `s` 成员中，以便进行后续的处理。


```cpp
YY_RULE_SETUP
#line 480 "scanner.l"
{ yylval->h = 0x40; return NUM; }
	YY_BREAK
case 184:
YY_RULE_SETUP
#line 481 "scanner.l"
{ yylval->h = 0x80; return NUM; }
	YY_BREAK
case 185:
YY_RULE_SETUP
#line 482 "scanner.l"
{
			 yylval->s = sdup(yyextra, (char *)yytext); return ID; }
	YY_BREAK
```

这段代码是一个 C 语言程序，它是一个文本文件中的测试套件。

它通过 `YY_RULE_SETUP` 和 `YY_BREAK` 两个伪命名定义了三个 case，用于处理不同情况下的输入。

`case 186:` 和 `case 187:` 伪命名定义了一个名为 `YY_RULE_SETUP` 的函数。这个函数的作用是读取一个名为 `yytext` 的字符数组，然后将其前 1 个字符存储到变量 `s` 中，然后返回 `ID` 变量。

`case 188:` 伪命名定义了一个名为 `YY_RULE_SETUP` 的函数，这个函数的作用是输出一个字符串 "ECHO"。

然后，在 `YY_BREAK` 后面，有一个额外的 `YY_RULE_SETUP` 函数，它的作用是输出一个 LEX 错误消息。

整个程序的逻辑是读取一个文件中的输入，根据不同的情况输出相应的结果。


```cpp
case 186:
YY_RULE_SETUP
#line 484 "scanner.l"
{ yylval->s = sdup(yyextra, (char *)yytext + 1); return ID; }
	YY_BREAK
case 187:
YY_RULE_SETUP
#line 485 "scanner.l"
{ return LEX_ERROR; }
	YY_BREAK
case 188:
YY_RULE_SETUP
#line 486 "scanner.l"
ECHO;
	YY_BREAK
```

This is a C program that appears to be the flex pointbuffer parser for YY 3. The program takes a single argument, the path to a file containing the YY file, and outputs the symbol table for the parsed YY file.

The program uses a recursive function `yy_parse()` to parse the YY file and reach the end of the file or a specific action. The `yy_parse()` function takes a `YY_FILE` argument that specifies the path to the file and a `YY_ACT` argument that specifies the action to take. The function returns a boolean value indicating whether the file was successfully parsed.

The program also includes a `YY_ACT_CONTINUE_SCAN`, `YY_ACT_TOKEN_B城乡， `YY_ACT_SET_SYMBOL_NAME` and `YY_ACT_ADD_SYMBOL_信息系统几个辅助函数，这些辅助函数用于处理扫描器中的符号和符号名称等。

最后，程序包括一个 `YY_FATAL_ERROR()` 函数，用于在解析过程中出现严重错误时引发栈溢出并崩溃。


```cpp
#line 4277 "scanner.c"
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * pcap_lex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_last_accepting_cpos;
				yy_current_state = yyg->yy_last_accepting_state;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( pcap_wrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of pcap_lex */

```

This appears to be a function for getting the next buffer of text from a YYG parser object. It appears to check if the buffer is already large enough to hold the next buffer, and if not, it creates a new buffer and checks if the new buffer can hold the text. If the buffer is too small, an error is thrown.

It also appears to check if the buffer has any data in it, and if not, it returns EOB_ACT_CONTINUE_SCAN. If the buffer has data, it scans through the text and returns EOB_ACT_LAST_MATCH.

I'm sorry, but I'm not able to understand the rest of this code, as it appears to be written in a language that I am not familiar with.


```cpp
/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			yy_size_t num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				yy_size_t new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					pcap_realloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			pcap_restart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) pcap_realloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

```

这段代码是一个名为 `yy_get_previous_state` 的函数，它用于获取在 EOB 字符到达之前的函数状态。

函数接受一个 `yyyscan_t` 类型的参数 `yyscanner`，这个参数是一个 `yyyscanner` 结构体，它包含一个指向 `yy` 结构的指针，以及一个指向 `yytext_ptr` 的指针。

函数内部首先定义了一个名为 `yy_current_state` 的静态变量，它用于记录当前函数状态。

接下来，函数遍历 `yytext_ptr` 和 `yy_c_buf_p` 两个成员变量所指向的内存区域，对于每个字符 `yy_c`，它检查自己是否处于接纳状态，如果是，则将状态记录到 `yy_last_accepting_state` 和 `yy_last_accepting_cpos` 变量中。

接着，函数从 `yy_base` 数组中偏移 `yy_c` 对应的位置，并尝试获取该位置的下一个字符，如果不是当前状态则执行循环，直到获取成功为止。

最后，函数返回 `yy_current_state`，即当前函数状态。


```cpp
/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1785 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

```

这段代码是一个名为“yy_try_NUL_trans”的函数，用于在给定的yy状态和扫描器的情况下，尝试从当前状态转移到另一个状态。函数的参数包括当前状态和扫描器对象，返回目标状态类型。

函数内部首先定义了一个名为“yy_is_jam”的变量，用于判断当前状态是否需要尝试下一个状态。然后，定义了一个名为“yyg”的结构体，用于保存当前状态的yy信息和下一个状态的yy信息。接着，定义了一个“yy_cp”指向的字符数组，用于保存当前扫描器的缓冲区的起始位置。

函数体内部，首先尝试从当前状态接受一个字符，如果接受成功，则记录下当前状态和下一个接受的状态，并将“yy_is_jam”设置为0。否则，遍历当前扫描器缓冲区中的所有字符，直到找到一个可以接受的字符，并更新当前状态和“yy_is_jam”。

接下来，尝试从当前状态转移。如果转移成功，则返回0，否则返回当前状态。最后，将内部函数“yyg”作为参数传递给“yy_try_NUL_trans”，以便正确处理从当前状态到目标状态的转移。


```cpp
/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1785 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 1784);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

```

This is a description of a valid NUL character in the buffer of a YY text scanner. The NUL character is formed if the buffer is not allocated before the start of the buffer, or if it is allocated but it is not filled before the end of the buffer.

If the NUL character is formed before the end of the buffer, it is considered a valid NUL. If not, then we have reached the end of the buffer and it is a loss of data.

It is important to note that if the buffer is not allocated before the start of the buffer, or if it is allocated but it is not filled before the end of the buffer, the buffer may not be valid. It is recommended to fill the buffer before the start of the scan, or to handle the case where the buffer is not allocated correctly.


```cpp
#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					pcap_restart(yyin ,yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( pcap_wrap(yyscanner ) )
						return EOF;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
```

这段代码是一个 C 语言函数，它根据传递给它的参数 yyscanner 是一个 YY 扫描器（YY 工具链）的情况，选择输出不同的函数实现。

具体来说，当函数定义为 `#ifdef __cplusplus` 时，函数体输出的是 `yyinput` 函数，而当函数定义为 `#else` 时，函数体输出的是 `input` 函数。

函数 `input` 函数接受一个 YY 扫描器 `yyyscanner`，并返回其下一个输入的值。函数 `yyinput` 函数也接受一个 YY 扫描器 `yyyscanner`，并返回其下一个输入的值，但是这个函数是在 `input` 函数的基础上实现的，它会尝试从 `yyyscanner` 中读取一个完整的字符，如果失败则返回 `-1`。

函数 `yyg->yy_c_buf_p` 指向了 `yyyscanner` 的一个缓冲区位置，`yy_hold_char` 指向 `yyyscanner` 当前读取的字符，而 `yyg->yy_hold_char` 则是一个整数类型，表示 `yyyscanner` 中的当前字符。

函数的主要作用是在 `yyinput` 和 `yyoutput` 两个函数中选择正确的实现，根据输入的 YY 扫描器类型来返回相应的函数实现。


```cpp
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
	yyg->yy_hold_char = *++yyg->yy_c_buf_p;

	return c;
}
```

这段代码定义了一个名为`pcap_restart`的函数，用于在接收到新的输入数据时重新启动捕获。它的输入参数包括`input_file`是一个可读的文件名和一个`yyyscanner`对象，这个对象是一个用于读取数据和处理数据的`YYSCANNER`实例。

函数内部首先检查`YY_NO_INPUT`是否定义，如果是，则不需要进行任何操作，直接返回。否则，函数会创建一个新的`YYGUEST`结构体变量`yg`，并将它作为`yyyscanner`的参数传递给`pcap_create_buffer`函数，以确保新的数据流得到正确的处理。

接着，函数调用`pcap_ensure_buffer_stack`函数来确保`YY_CURRENT_BUFFER`变量在数据到来之前已经被分配，并且调用`pcap__init_buffer`函数初始化新的缓冲区。最后，函数调用`pcap__load_buffer_state`函数加载缓冲区的状态，这样就可以开始捕获数据了。


```cpp
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void pcap_restart  (FILE * input_file , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! YY_CURRENT_BUFFER ){
        pcap_ensure_buffer_stack (yyscanner);
		YY_CURRENT_BUFFER_LVALUE =
            pcap__create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
	}

	pcap__init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);
	pcap__load_buffer_state(yyscanner );
}

```

这段代码定义了一个名为`pcap__switch_to_buffer`的函数，它用于将输入数据缓冲区从当前缓冲区切换到一个新的缓冲区。这个函数接受两个参数：一个新的缓冲区`new_buffer`和一个扫描器对象`yyyscanner`。

函数内部首先定义了一个名为`YYGUTS_T`的结构体变量`yyg`，用于存储输入缓冲区的信息。然后通过`pcap_ensure_buffer_stack`函数确保输入缓冲区栈已经被清除，然后检查当前缓冲区是否等于一个新的缓冲区。如果是，那么函数直接返回，因为已经切换到了新的缓冲区。

如果当前缓冲区仍然存在，那么函数会执行以下操作：

1. 将新缓冲区的`YYGUTS_T`结构体中的`yy_c_buf_p`成员赋值给`yyg->yy_hold_char`，并将`YYGUTS_T`结构体中的`yy_buf_pos`成员的值赋给`YYGUTS_T`结构体中的`yy_hold_char`成员。
2. 如果新缓冲区的长度`YYGUTS_T`结构体中的`yy_n_chars`成员的值不为0，那么将新缓冲区的`YYGUTS_T`结构体中的`yy_n_chars`成员的值赋给`YYGUTS_T`结构体中的`yy_n_chars`成员。
3. 通过调用`pcap_pop_buffer_state`函数将当前缓冲区从输入缓冲区栈中弹出，并将其设置为新的缓冲区。
4. 通过调用`pcap_push_buffer_state`函数将当前缓冲区设置为新的缓冲区。
5. 设置`YYGUTS_T`结构体中的`yy_did_buffer_switch_on_eof`成员为1，表明我们已经完成了从当前缓冲区切换到新缓冲区的操作。

最后，函数内部还定义了一个辅助函数`pcap__load_buffer_state`，用于在缓冲区切换时加载相关信息，但这个函数在当前代码中没有被使用。


```cpp
/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
    void pcap__switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		pcap_pop_buffer_state();
	 *		pcap_push_buffer_state(new_buffer);
     */
	pcap_ensure_buffer_stack (yyscanner);
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	pcap__load_buffer_state(yyscanner );

	/* We don't actually know whether we did this switch during
	 * EOF (pcap_wrap()) processing, but the only time this flag
	 * is looked at is after pcap_wrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyg->yy_did_buffer_switch_on_eof = 1;
}

```

This code appears to be a C implementation of the `yyg` object that is used for parsing and storing yytext in a buffer.

It defines several functions:

* `YY_CURRENT_BUFFER_LVALUE->yy_n_chars` is a read-only member variable that gets the number of characters in the current buffer.
* `YY_CURRENT_BUFFER_LVALUE->yytext_ptr` is a read-only member variable that gets the pointer to the buffer that contains the current yytext.
* `YY_CURRENT_BUFFER_LVALUE->yy_input_file` is a read-only member variable that gets the file that the input buffer is coming from.
* `YY_CURRENT_BUFFER_LVALUE->yy_hold_char` is a read-only member variable that gets the character at the current position in the buffer that contains the input from the file.
* `YY_BUFFER_STATE->yy_ch_buf` is a member function that gets the current character buffer state.
* `YY_BUFFER_STATE->yy_is_our_buffer` is a member function that checks if the buffer is allocated for our use.
* `YY_BUFFER_STATE->yy_output_file` is a member function that gets the file to write the buffer to.
* `YY_BUFFER_STATE->yy_hold_char` is a member function that gets the character at the current position in the buffer that contains the output.

The `pcap_alloc` function is used to dynamically allocate memory for the buffer based on the size and type specified when creating the buffer.

It appears that `YY_CURRENT_BUFFER_LVALUE` is the input parameter for this function, and it is passed to the `pcap_alloc` function to allocate memory for the buffer.


```cpp
static void pcap__load_buffer_state  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE pcap__create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) pcap_alloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in pcap__create_buffer()" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) pcap_alloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in pcap__create_buffer()" );

	b->yy_is_our_buffer = 1;

	pcap__init_buffer(b,file ,yyscanner);

	return b;
}

```

这段代码定义了一个名为 pcap__delete_buffer 的函数，它的参数包括一个由 pcap__create_buffer() 函数创建的缓冲区和一个 yyscanner 对象。

函数的作用是销毁传入的缓冲区，并将其从内存中移除。以下是函数的更详细说明：

1. 首先检查传入的参数 b 是否为空，如果是，函数返回。
2. 如果 b 是当前缓冲区的缓冲区，函数会将当前缓冲区的 yy 成员设为 0，以便在销毁时正确地释放内存。
3. 如果 b 是一个我们自己的缓冲区，函数会使用 pcap_free() 函数释放缓冲区，其中第二个参数 yyscanner 指定了要释放的 yy 数据。
4. 最后，函数使用 pcap_free() 函数释放 b 本身，将其从内存中移除。

总之，这个函数的主要作用是销毁传入的缓冲区，并确保在释放内存时正确地释放了缓冲区，使得函数不会创建不必要的内存泄漏。


```cpp
/** Destroy the buffer.
 * @param b a buffer created with pcap__create_buffer()
 * @param yyscanner The scanner object.
 */
    void pcap__delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		pcap_free((void *) b->yy_ch_buf ,yyscanner );

	pcap_free((void *) b ,yyscanner );
}

```



这段代码是一个用于初始化或重新初始化缓冲区的函数，可能会在pcap_restart()或at EOF时被调用。

函数内部首先检查错误号oerrno，然后使用yyscanner对象的YY输入流，将其写入缓冲区中。

然后，将缓冲区的文件名(通过参数file)设置为给定的缓冲区(b)的YY输入文件名(file)，并设置给定的缓冲区(b)的填充缓冲标志为1，即开始了填充缓冲区操作。

接下来是关键点：

1. 如果当前缓冲区(b)不是正在使用的缓冲区，则执行以下操作：重置缓冲区中的行偏移(lineno)和列偏移(column)，并将缓冲区(b)设置为交互式(yy_is_interactive)模式，以便在需要时动态分配缓冲区空间。

2. 最后，函数返回错误号oerrno，如果初始化缓冲区时出现任何错误，则返回该错误号。


```cpp
/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a pcap_restart() or at EOF.
 */
    static void pcap__init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)

{
	int oerrno = errno;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	pcap__flush_buffer(b ,yyscanner);

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then pcap__init_buffer was _probably_
     * called from pcap_restart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

```

这段代码是用于在 YY 输入时丢弃缓冲区中的所有字符，并在下一次扫描时仅发送有效的字符。

具体来说，代码首先检查缓冲区是否为空，如果是，则直接返回。否则，代码清空缓冲区中的所有字符，即设置缓冲区的 yy_n_chars 为 0，并设置两个 end-of-buffer 字符为 YY_END_OF_BUFFER_CHAR。然后，将当前缓冲区的开始位置设置为 b->yy_ch_buf[0] 指向的位置，并设置 b->yy_at_bol 为 1，表示正在开始一个新的缓冲区状态。最后，如果当前缓冲区为正在使用的缓冲区，代码将调用 pcap__load_buffer_state(yyscanner) 来加载缓冲区状态。


```cpp
/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
    void pcap__flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		pcap__load_buffer_state(yyscanner );
}

```

这段代码的作用是推动新的二进制数据帧将新的状态加入到栈中，将新的状态成为当前状态。如果栈空间不足，该函数会尝试进行栈扩展。在函数内部，首先检查输入的参数new_buffer是否为空，如果是，则直接返回。接着，通过pcap_ensure_buffer_stack函数确保栈空间，然后将YY_CURRENT_BUFFER所指向的内存区域复制到YYGUTS结构体中的yyg成员中。复制完成后，判断YY_CURRENT_BUFFER是否为真，如果是，则执行以下操作：将栈顶元素从 old_buffer 中的栈顶处弹出，将 yyg 结构体中的 yy 成员赋值为 new_buffer 的 yy 成员，并将 yy 成员的 n_chars 成员设置为 new_buffer 的 n_chars 成员。最后，如果复制过程中触发了 EOF，则设置yyg 结构体中的 yyDidBufferSwitchOnEOF 成员为 1，表明异步数据帧已经到达了栈顶。


```cpp
/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void pcap_push_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (new_buffer == NULL)
		return;

	pcap_ensure_buffer_stack(yyscanner);

	/* This block is copied from pcap__switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		yyg->yy_buffer_stack_top++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from pcap__switch_to_buffer. */
	pcap__load_buffer_state(yyscanner );
	yyg->yy_did_buffer_switch_on_eof = 1;
}

```

这段代码的作用是移除并删除栈顶元素，如果栈顶元素存在。然后将下一个元素设置为新的栈顶元素。以下是代码的更详细解释：

1. 首先定义了一个名为 `pcap_pop_buffer_state` 的函数，它接受一个名为 `yyyscanner` 的参数。
2. 在函数内部，声明了一个名为 `YY_CURRENT_BUFFER` 的变量，并初始化为 0。
3. 接下来，通过调用 `pcap__delete_buffer` 函数，将栈顶元素从传递给该函数的 `YY_CURRENT_BUFFER` 对象中删除，并将其值设置为 `NULL`。
4. 如果 `YY_CURRENT_BUFFER` 变量为真，则执行以下操作：
  4.1. 通过调用 `pcap__load_buffer_state` 函数，将栈顶元素存储在 `yyg` 结构体中。
  4.2. 如果 `YY_CURRENT_BUFFER` 栈顶元素已经被设置为 `EOF`，则执行以下操作：
     4.2.1. 设置 `yyg->yy_did_buffer_switch_on_eof` 变量为 1，表明 `YY_CURRENT_BUFFER` 已经发生了 EOF。
     4.2.2. 通过调用 `pcap__unload_buffer_state` 函数，将栈顶元素从 `yyg` 结构体中删除。
     4.2.3. 设置 `yyg->yy_buffer_stack_top` 变量为 `YY_CURRENT_BUFFER` 减去 1，表示栈顶元素被删除后，`YY_CURRENT_BUFFER` 变量将自动恢复。
5. 最后，在 `pcap_pop_buffer_state` 函数内部，通过 `if` 语句检查 `YY_CURRENT_BUFFER` 是否为真，如果是，则执行以下操作：
  5.1. 通过调用 `pcap__load_buffer_state` 函数，将栈顶元素存储在 `yyg` 结构体中。
  5.2. 通过调用 `pcap__unload_buffer_state` 函数，将栈顶元素从 `yyg` 结构体中删除。
  5.3. 通过 `return` 语句返回，表示函数执行成功。


```cpp
/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void pcap_pop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	pcap__delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		pcap__load_buffer_state(yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

```

This function appears to allocated and initialized a buffer for the yy商人报数据， if the buffer is not large enough it creates a new larger buffer, it seems like it's done this process multiple times to make sure it can handle a large number of yy商人报数据.

It's important to note that this function should be called each time the buffer needs to be allocated or initialized and should be passed a large buffer variable, this variable should be the size of the buffer that the buffer is expected to hold.


```cpp
/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void pcap_ensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)pcap_alloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in pcap_ensure_buffer_stack()" );
								  
		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)pcap_realloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in pcap_ensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

```

这段代码定义了一个名为 `pcap__scan_buffer` 的函数，它的作用是设置输入缓冲区的状态，以便直接从用户指定的字符缓冲区中扫描字符。

具体来说，这个函数接受三个参数：

- `base`：要扫描的字符缓冲区的起始地址，它应该是 `YY_END_OF_BUFFER_CHAR` 的后一位，即字符结束标志。
- `size`：字符缓冲区的大小，以字节为单位。
- `yyscanner`：一个 `YYSCANNER` 类型的参数，用于从缓冲区中读取数据。

函数首先检查 `size` 是否小于 2，如果是，那么说明他们忘记了一个 EOB（End of Buffer）标记，可能会导致程序崩溃。如果是，函数直接返回一个空字符缓冲区，然后释放内存。

否则，函数创建一个新的字符缓冲区，并将其初始化为与 `size` 相关的值，然后将其传递给 `pcap_alloc` 函数，如果分配成功，将返回新创建的字符缓冲区的 `YY_BUFFER_STATE` 类型的指针。

最后，函数调用 `pcap_switch_to_buffer` 函数将输入缓冲区设置为 `pcap_scan_buffer` 函数的接受者，以便从用户指定的字符缓冲区中读取数据。

函数的实现确保了在输入缓冲区中的字符将按照预期顺序被扫描，并在字符缓冲区中的 EOB 标记处设置一个合适的颜色，以便开发人员知道数据是否已结束。


```cpp
/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE pcap__scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) pcap_alloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in pcap__scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	pcap__switch_to_buffer(b ,yyscanner );

	return b;
}

```

这段代码定义了一个名为 `pcap__scan_string()` 的函数，用于将一个字符串中的字节扫描到输入缓冲区中，并返回一个新的缓冲区状态对象。

函数有两个参数，一个是字符串 `ystr`，另一个是扫描器对象 `yscanner`。函数内部先调用 `pcap__scan_bytes()` 函数将字符串中的字节扫描到输入缓冲区中，然后将扫描得到的字符串长度存储到参数 `_yybytes_len` 中。最后，将扫描得到的字符串中的字节复制到输入缓冲区中，并返回一个新的缓冲区状态对象。

如果需要在扫描的字节中包含 NUL 值，可以使用 `pcap__scan_bytes()` 函数，它会遍历字节中的所有字符，并不仅仅只扫描 NUL 值。


```cpp
/** Setup the input buffer state to scan a string. The next call to pcap_lex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       pcap__scan_bytes() instead.
 */
YY_BUFFER_STATE pcap__scan_string (yyconst char * yystr , yyscan_t yyscanner)
{
    
	return pcap__scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to pcap_lex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
```

这段代码定义了一个名为 pcap__scan_bytes 的函数，它的参数包括一个指向字符数组 yybytes 的指针 yybytes_len 和一个指向 yyscanner 的整数类型 yyscanner。

函数的作用是获取一个字符数组 yybytes 中符合 yyscanner 定义的连续字节，并将它们存储到一个名为 buf 的字符数组中。这个字符数组的长度应该比输入的 yybytes_len 大 2，以便包含 trailing EOB's。然后，将缓冲区中的字符串转换为 yy_end_of_buffer_char 类型，以便告诉函数扫描器已经到达了字符串的结尾。

最后，将缓冲区 b 作为参数传递给 pcap__scan_buffer 函数，如果函数成功返回，那么将返回一个 yy_buffer_state 类型的数据，否则会抛出错误。函数中的 b->yy_is_our_buffer 成员变量用于指示是否已经处理完了缓冲区，以便在需要时排除它。


```cpp
YY_BUFFER_STATE pcap__scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) pcap_alloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in pcap__scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = pcap__scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in pcap__scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

```

这段代码是一个C语言的预处理指令，定义了一个名为YY_EXIT_FAILURE的常量，其值为2。

它首先检查是否定义了这个常量，如果没有，则定义一个新的常量YY_EXIT_FAILURE，其值为2。然后定义了一个名为yyfatal_error的函数，它接收两个参数，一个字符串类型的参数msg，和一个yyscanner类型的参数yyscanner。

函数内部先获取yyscanner类型的变量，然后将yyscanner的值（即1，因为YYSCANNER是姜战战在2015年创建的，而YYSCANNER_MOD=3）传递给函数外部的函数，并使用传入的msg打印出字符串。最后，使用exit函数输出YY_EXIT_FAILURE，并退出程序。


```cpp
#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
```

这段代码定义了一个名为yyless的宏，它的参数是一个整型变量n。这个宏内部实现了一个do-while循环，会在循环体中执行一系列的语句。

让我们一步一步地来看这些语句的作用：

1. `do { ... }`：这是一个do-while循环，会在循环体中执行一系列的语句。
2. `int yyless_macro_arg = (n);`：这是一个获取变量n的整型变量，将其赋值为n。
3. `YY_LESS_LINENO(yyless_macro_arg);`：这是一个使用yyless_macro_arg计算YY_LESS_LINENO函数的返回值，将其赋值给yyless_macro_arg。
4. `yytext[yyleng] = yyg->yy_hold_char;`：这是将变量yyg的引用（即yyg->yy_hold_char）复制到yytext数组的第yyleng个位置。
5. `yyg->yy_c_buf_p = yytext + yyless_macro_arg;`：这是将变量yyg的引用（即yyg->yy_c_buf_p）复制到yytext数组的第yyless_macro_arg个位置。
6. `yyg->yy_hold_char = *yyg->yy_c_buf_p;`：这是将yyg的引用（即yyg->yy_hold_char）复制到yyg->yy_c_buf_p指向的内存空间。
7. `*yyg->yy_c_buf_p = '\0';`：这是将yyg的引用（即yyg->yy_c_buf_p）的值设置为'\0'，也就是一个空字符串'\0'。
8. `yyleng = yyless_macro_arg;`：这是将变量yyless_macro_arg的值赋给变量yyleng。

综上所述，这段代码定义了一个名为yyless的宏，它的作用是复制一个整型变量yyg的引用（包括所有成员变量和给定的缓冲区）到yytext数组的指定位置。


```cpp
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

```

这两段代码是用于scanline工具中的选项设置。

`pcap_get_extra`函数的作用是获取用户定义的数据，它接收一个`yyscanner`参数，这个参数是一个`yy`扫描器对象。这个函数返回一个指向`YY_EXTRA_TYPE`类型的结构体的指针，它存储了用户定义的数据。

`pcap_get_lineno`函数的作用是获取当前行号。它接收一个`yyscanner`参数，这个参数是一个`yy`扫描器对象。这个函数首先检查是否正在读取行首的缓冲区，如果是，则返回当前行号。否则，它返回0。

`YY_CURRENT_BUFFER`是一个预定义的常量，它表示是否正在读取行首的缓冲区。如果没有这个常量，那么它的值将是`false`。


```cpp
/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE pcap_get_extra  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int pcap_get_lineno  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    
        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yylineno;
}

```

这段代码定义了两个函数，用于获取不同参数的 scanner 对象。

第一个函数名为 `pcap_get_column`，它接收一个名为 `YYSCANNER` 的参数，返回当前缓冲区的列号。具体实现是通过调用 `YY_CURRENT_BUFFER` 函数获取当前缓冲区，如果当前缓冲区为空，则返回 0。

第二个函数名为 `YY_TRACE_ROOT_MAPPINGS`，它定义了一个结构体 `YYGUEST` 类型的变量 `yyguest`，用于存储输入流中的各个数据点的来源信息。然后，它将这个结构体传递给一个名为 `yyscanner` 的参数，然后返回这个结构体。


```cpp
/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int pcap_get_column  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    
        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
```

这两段代码是用来操作 YYGUMSANNER 对象的。YYGUMSANNER 是一个 YY 格式器的输出串，可以从中读取网络数据包。这两段代码定义了两个函数，pcap_get_in 和 pcap_get_out。

pcap_get_in 函数接受一个 YY 扫描器对象作为参数，并返回一个指向输出文件的指针。函数的作用是读取输入数据包并将其输出到文件中。

pcap_get_out 函数同样接受一个 YY 扫描器对象作为参数，并返回一个指向输出文件的指针。函数的作用是将输入数据包输出到文件中。

这两个函数都在文件操作系统的输入输出方面进行了操作。YYGUMSANNER 对象被用来读取和写入网络数据包。


```cpp
FILE *pcap_get_in  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *pcap_get_out  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyout;
}

```

这两段代码是用于网络工具类中的yyyscanner对象中的函数。

pcap_get_leng函数的作用是获取当前解析器对象（yyyscanner）中的YYGUMS结构的当前文本句柄（YYGUMS_T）的长度，然后将其返回。

pcap_get_text函数的作用是获取当前解析器对象（yyyscanner）中的YYGUMS结构的当前文本内容，然后将其返回。

需要注意的是，这些函数需要提供给scanf函数使用，以便将文本内容从输入文件中读取并传递给解析器。


```cpp
/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
yy_size_t pcap_get_leng  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *pcap_get_text  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yytext;
}

```



这两段代码是用于设置 scanner 对象的输出数据和当前行号的功能。

第一段代码 `pcap_set_extra` 函数，允许用户定义一个数据，这个数据将不会被 scanner 读取。函数接受两个参数，一个是用户定义的数据 `user_defined`，另一个是 scanner 对象 `yyyscanner`。函数内部创建一个 `YYGUTS_T` 类型的变量 `yyg`，并将其指向 `user_defined`。

第二段代码 `pcap_set_lineno` 函数，允许用户设置当前行号。函数接受两个参数，一个是当前行号 `_line_number`，另一个是 scanner 对象 `yyyscanner`。函数内部创建一个 `YYGUTS_T` 类型的变量 `yyg`，并将其指向 `_line_number`。如果当前缓冲区不存在，函数会抛出一个错误。

两段代码都在尝试确保输入参数 `_line_number` 和 `yyyscanner` 存在，否则会抛出错误。


```cpp
/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void pcap_set_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyextra = user_defined ;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void pcap_set_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "pcap_set_lineno called with no buffer" );
    
    yylineno = _line_number;
}

```

这段代码定义了一个名为`pcap_set_column`的函数，用于设置数据包中的当前列。

该函数需要传入两个参数：`_column_no`表示要设置的列号，`YYSCANNER`表示一个`YYSCANNER`对象。

函数内部首先定义了一个名为`YYGUMS`的结构体，该结构体包含一个指向`YYSCANNER`对象的指针`yy`，以及一个表示当前列编号的整数`yycolumn`。

接着，函数判断是否已经创建了输入缓冲区，如果没有创建，则抛出一个错误。

最后，将`yycolumn`赋值为参数`_column_no`，即将要设置的列号。

整个函数的作用是确保在设置列号时，输入缓冲区已经存在，并在设置后返回正确的结果。


```cpp
/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void pcap_set_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "pcap_set_column called with no buffer" );
    
    yycolumn = _column_no;
}

```

这段代码定义了两个函数：`pcap_set_in` 和 `pcap_set_out`，用于设置输入流和输出流。

具体来说，`pcap_set_in`函数接收一个可读流和一个扫描器对象，将其设置为输入流的起始位置，并将其输入缓冲区设置为输入流的位置。这样，当数据开始进入输入流时，`pcap_set_in`函数将其赋值给输入流的起始位置，而不是将其删除。

`pcap_set_out`函数与`pcap_set_in`函数类似，只是将扫描器的输出位置作为参数传递给函数。这样，当数据开始从输出流进入时，`pcap_set_out`函数将其赋值给输出流的起始位置，而不是将其删除。


```cpp
/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see pcap__switch_to_buffer
 */
void pcap_set_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void pcap_set_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

```



这段代码是关于 capture（数据捕获）工具链中的两个函数：`pcap_get_debug` 和 `pcap_set_debug`。它们的作用是获取和设置 `YYSCANNER` 对象的 `YY_FLEX_DEBUG` 成员。

具体来说，`pcap_get_debug` 函数返回了一个指向 `YYGUMSCT` 结构的指针（`struct yyguts_t *`），并返回了一个布尔值（`int`），这个布尔值表示 `YYSCANNER` 对象所表示的下一个 `YYSCANNER` 是否开启了 debug 模式。

`pcap_set_debug` 函数接受两个参数：一个整数类型的参数 `_bdebug`，表示是否启用 debug 模式，另一个是 `YYSCANNER` 对象。它将 `_bdebug` 的值存储在 `YYGUMSCT` 结构中，然后将 `YY_FLEX_DEBUG` 成员的值设置为 `_bdebug`。

这两个函数通过 `YYGUMSCT` 结构中的 `YY_FLEX_DEBUG` 成员，实现了对于捕获过程的调试，以便在程序调试中查看更多的信息。


```cpp
int pcap_get_debug  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yy_flex_debug;
}

void pcap_set_debug (int  _bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yy_flex_debug = _bdebug ;
}

/* Accessor methods for yylval and yylloc */

YYSTYPE * pcap_get_lval  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yylval;
}

```



该代码定义了一个名为 `pcap_set_lval` 的函数，用于设置 `YYSTYPE` 类型的参数 `yylval_param` 的值。

该函数接受两个参数：一个指向 `YYSTYPE` 类型变量的指针 `yylval_param` 和一个 `YYSCANNER` 类型的参数 `yyscanner`。

在函数内部，使用 `struct yyguts_t * yy` 将 `yyscanner` 的值复制到一个 `YYSTYPE` 类型的变量 `yy` 中，然后将 `yy` 赋值给 `yylval_param`。

该函数的作用是提供一个简单的函数，用于设置 `YYSTYPE` 类型的参数的值，但仅在函数内部使用。

注意，由于 `yyscanner` 是一个 `YYSCANNER` 类型的参数，因此需要使用 `YYSCANNER` 的指针来访问 `YYSTYPE` 类型的变量。


```cpp
void pcap_set_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yylval = yylval_param;
}

/* User-visible API */

/* pcap_lex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */

int pcap_lex_init(yyscan_t* ptr_yy_globals)

{
    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) pcap_alloc ( sizeof( struct yyguts_t ), NULL );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals ( *ptr_yy_globals );
}

```

这段代码定义了一个名为 pcap_lex_init_extra 的函数，它是 pcap_lex_init 的派生函数，但遵循了将扫描器作为最后一个实参的惯例。

函数接受两个实参：一个是用户定义的类型，表示输入数据中的扫描器；另一个是一个指向 yy 全局变量的指针，表示存储用户定义的值的变量。

函数首先定义了一个名为 dummy_yyguts 的结构体，用于存储设置 extra 层的扫描器。

函数接着创建一个指向 struct yyguts_t 类型的指针变量 ptr_yy_globals，用于存储用户定义的值的 yy 全局变量。

函数使用 pcap_set_extra 函数将用户定义的类型的值设置为 dummy_yyguts，然后检查是否成功。如果成功，就设置 ptr_yy_globals 指向 dummy_yyguts，否则返回 EINVAL 和 ENOMEM。

函数最后调用 yy_init_globals 函数，将设置好的值存储到 yy 全局变量中。

注意：函数的实现不包含输出，但函数名和函数签名可能会让人误解为输出。


```cpp
/* pcap_lex_init_extra has the same functionality as pcap_lex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to pcap_alloc in
 * the yyextra field.
 */

int pcap_lex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    pcap_set_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }
	
    *ptr_yy_globals = (yyscan_t) pcap_alloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
	
    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }
    
    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
    
    pcap_set_extra (yy_user_defined, *ptr_yy_globals);
    
    return yy_init_globals ( *ptr_yy_globals );
}

```

这段代码是一个名为“yyy_init_globals”的函数，属于yyyscan_t类型的函数。它的作用是初始化一个yyyscanner对象，并执行一些初始化操作。

具体来说，这段代码首先检查传入的yyyscanner对象是否已经被初始化，如果已经初始化，则执行完初始化操作后返回。否则，执行初始化操作，并将结果存储在yyg对象中。

初始化操作主要包括以下几个步骤：

1. 将yyg对象的静态成员变量yy_buffer_stack、yy_buffer_stack_top、yy_buffer_stack_max都初始化为0。
2. 将yyg对象的静态成员变量yy_c_buf_p初始化为0。
3. 将yyg对象的静态成员变量yy_init和yy_start都设置为1。
4. 如果前一个函数（pcap_lex_destroy）中已经初始化了yyyscanner，则将初始化操作中计算出的值存储在yyg对象的静态成员变量中。
5. 最后，返回初始化后的yyg对象，YYG_NO_初始化代码。


```cpp
static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from pcap_lex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = 0;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = (char *) 0;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

```

这段代码定义了一个名为 `YY_STDINIT` 的宏，用于在编译时检查是否使用了 `stdin` 和 `stdout` 文件指针。如果没有使用它们，代码会定义 `yyin` 和 `yyout` 分别为 `FILE` 类型的 0，即没有指针。如果使用了它们，代码会将 `yyin` 和 `yyout` 指向实际的文件指针。

然后，代码会输出一个字符串 `"/path/to/YY_STDINIT"`，用于指示编译器在使用该宏时返回什么错误信息。如果宏定义成功，该代码将返回 0。


```cpp
/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * pcap_lex_init()
     */
    return 0;
}

```

这段代码是一个用于释放捕获器实例数据结构的应用程序。它针对可重入和不可重入的扫描器，通过递归方式遍历缓冲区和栈，并最终释放数据结构所占用的内存。

具体来说，这段代码的作用如下：

1. 首先定义了一个名为 pcap_lex_destroy 的函数，它接受一个 yyscanner 类型的参数。

2. 在函数内部，创建了一个名为 yyg 的 yy 对象，并将其指向传入的 yyscanner。

3. 接着遍历缓冲区栈（如果使用的是可重入扫描器，则从 yyscanner 的第二个输出缓冲区开始），逐个删除当前缓冲区，并将其对应的 yy 对象从栈中弹出。

4. 然后释放栈中的所有数据，包括栈本身。

5. 最后，对于不可重入的扫描器，还需要释放栈和全局变量。

6. 在函数内部，还调用了 yy 的初始化函数（如果使用的是可重入扫描器）。

7. 最后，在函数外部，返回 0，表示成功释放了数据结构。


```cpp
/* pcap_lex_destroy is for both reentrant and non-reentrant scanners. */
int pcap_lex_destroy  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		pcap__delete_buffer(YY_CURRENT_BUFFER ,yyscanner );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		pcap_pop_buffer_state(yyscanner);
	}

	/* Destroy the stack itself. */
	pcap_free(yyg->yy_buffer_stack ,yyscanner);
	yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
        pcap_free(yyg->yy_start_stack ,yyscanner );
        yyg->yy_start_stack = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * pcap_lex() is called, initialization will occur. */
    yy_init_globals( yyscanner);

    /* Destroy the main struct (reentrant only). */
    pcap_free ( yyscanner , yyscanner );
    yyscanner = NULL;
    return 0;
}

```

这段代码定义了一个名为"yytext\_ptr"的内部 utility 函数，用于将两个字符串（或向量）字面值复制到第三个字符数组中。这个函数的实现包括以下几个步骤：

1. 定义一个名为"yy\_flex\_strncpy"的函数，该函数接收两个字符串参数s1和s2，以及一个整数参数n和一个表示当前输入字符数组位置的整数类型的变量yyscaner。
2. 将s1和s2的字符指针复制到yyscaner指向的struct yyguts\_t结构体中，这个结构体中包含一个int类型的成员，表示当前输入字符数组位置。
3. 使用一个for循环从0到n-1遍历输入字符串s1。
4. 在循环内部，将s1[i]复制到s2[i]中。

整个函数的实现主要涉及两个部分：一是将源字符串s1和s2的字符指针复制到yyscaner指向的struct yyguts\_t结构体中，二是循环内部对输入字符串s1的每个字符进行复制到目标字符串s2的过程。


```cpp
/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

```



该代码定义了两个函数，一个是在#ifdef YY_NEED_STRLEN注释下定义的yyflex_strlen函数，另一个是pcap_alloc函数。

1. yyflex_strlen函数的作用是计算一个字符串的长度，它接收一个字符串参数s和一个yyscanner类型的变量yyscanner，并返回字符串中可变字符数组s中可变字符的数量。

2. pcap_alloc函数的作用是在YYNEED_STRLEN注释下分配一个大小为size字节字符串缓冲区，并返回该缓冲区的内存地址。它接收一个大小为size字节字符串缓冲区和一个yyscanner类型的变量yyscanner。

YYNEED_STRLEN注释是预处理指令，用于告诉编译器在编译之前需要定义的函数。如果没有这个注释，编译器不会生成任何函数定义，这个函数也就无法使用。


```cpp
#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *pcap_alloc (yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	return (void *) malloc( size );
}

```

这段代码是一个名为 `pcap_realloc` 的函数，属于 `pcap` 项目。它的作用是重新分配内存，以便在 `yyyscanner` 结构中使用。

具体来说，函数接受三个参数：

1. `ptr`：这是一个 `void` 类型指针，表示要重新分配的内存的起始地址。
2. `size`：这是一个 `YYSDK_PRICE_FLOAT` 类型，表示要分配的内存大小，以字节为单位。
3. `yyscanner`：这是一个 `YYSDK_PRICE_FLOAT` 类型，表示一个 `YYSCANNER` 结构体，包含了 `scan` 函数的指针。

函数首先将 `yyscanner` 结构的指针复制到一个名为 `yy` 的 `struct` 中，然后调用 `realloc` 函数，将 `ptr` 所指内存区域重新分配为给定的大小。

需要注意的是，由于 `yy` 结构中包含了 `void` 指针，因此 `realloc` 函数使用了 `void *` 类型的别指针，以适应所有使用 `void *` 类型指针的实现。如果使用的是 `void *` 类型的指针，则不需要在 `realloc` 函数中执行别指针检查。


```cpp
void *pcap_realloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

```

这段代码是一个名为 `pcap_free` 的函数，属于 `pcap` 子模块。它的作用是释放由 `yyyscanner` 指向的结构体 `yyg` 所占用的内存。释放的方式是使用 `free` 函数，同时通过 `yygscanner` 类型的参数 `yyg` 来获取 `yyyscanner` 的地址，以确保正确的内存释放。

函数的定义在 `scanner.l` 文件中，定义了一个名为 `YYTABLES_NAME` 的常量，用于表示数据表的名称。


```cpp
void pcap_free (void * ptr , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	free( (char *) ptr );	/* see pcap_realloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 486 "scanner.l"



/*
 * Turn diagnostics back on, so we check the code that we've written.
 */
```

This looks like a JavaScript number literal. In particular, it appears to be a binary number that has been encoded in little-endian byte order, and it contains a 32-bit overflow.

The `yytext_arg` parameter seems to be a pointer to a variable that is being converted to a string, and the `yyextra_arg` parameter is a pointer to a variable that is being passed to `yytext_arg` but is not used in this function.

The function takes two arguments: `yytext_arg` and `yyextra_arg`. The `yytext_arg` argument seems to be a pointer to a variable that is going to receive the converted number and is being converted to a string, while `yyextra_arg` is a pointer to a variable that is going to be passed to `yytext_arg` but is not used in this function.

The function contains several checks and conversions, including converting the binary number to a decimal number and shifting it left to ensure that it is in little-endian byte order. It also checks for a 32-bit overflow and, if one is found, it will return an error message.

Overall, it looks like the function is being used to convert a binary number to a string, but it is also checking for certain errors that may occur during the conversion process.


```cpp
DIAG_ON_FLEX

/*
 * Convert string to 32-bit unsigned integer.  Just like atoi(), but checks for
 * preceding 0x or 0 and uses hex or octal instead of decimal.
 *
 * On success, sets yylval->h to the value and returns NUM.
 * On failure, sets the BPF error string and returns LEX_ERROR, to force
 * the parse to stop.
 */
static int
stou(char *yytext_arg, YYSTYPE *yylval_arg, compiler_state_t *yyextra_arg)
{
	bpf_u_int32 n = 0;
	unsigned int digit;
	char *s = yytext_arg;

	/*
	 * yytext_arg is guaranteed either to be a string of decimal digits
	 * or 0[xX] followed by a string of hex digits.
	 */
	if (*s == '0') {
		if (s[1] == 'x' || s[1] == 'X') {
			/*
			 * Begins with 0x or 0X, so hex.
			 * Guaranteed to be all hex digits following the
			 * prefix, so anything that's not 0-9 or a-f is
			 * A-F.
			 */
			s += 2;	/* skip the prefix */
			while ((digit = *s++) != '\0') {
				if (digit >= '0' && digit <= '9')
					digit = digit - '0';
				else if (digit >= 'a' && digit <= 'f')
					digit = digit - 'a' + 10;
				else
					digit = digit - 'A' + 10;

				/*
				 * Check for overflow.
				 */
				if (n > 0xFFFFFFFU) {
					/*
					 * We have more than 28 bits of
					 * number, and are about to
					 * add 4 more; that won't fit
					 * in 32 bits.
					 */
					bpf_set_error(yyextra_arg,
					    "number %s overflows 32 bits",
					    yytext_arg);
					return LEX_ERROR;
				}
				n = (n << 4) + digit;
			}
		} else {
			/*
			 * Begins with 0, but not 0x or 0X, so octal.
			 * Guaranteed to be all *decimal* digits following
			 * the prefix, so we need to catch 8 and 9 and
			 * report an error.
			 */
			s += 1;
			while ((digit = *s++) != '\0') {
				if (digit >= '0' && digit <= '7')
					digit = digit - '0';
				else {
					bpf_set_error(yyextra_arg,
					    "number %s contains non-octal digit",
					    yytext_arg);
					return LEX_ERROR;
				}
				if (n > 03777777777U) {
					/*
					 * We have more than 29 bits of
					 * number, and are about to add
					 * 3 more; that won't fit in
					 * 32 bits.
					 */
					bpf_set_error(yyextra_arg,
					    "number %s overflows 32 bits",
					    yytext_arg);
					return LEX_ERROR;
				}
				n = (n << 3) + digit;
			}
		}
	} else {
		/*
		 * Decimal.
		 */
		while ((digit = *s++) != '\0') {
			digit = digit - '0';
```

这段代码是一个 C 语言中的预处理指令，它定义了两个常量 #define CUTOFF_DEC 和 #define CUTLIM_DEC，以及一个函数指针 yyextra_arg。

#define CUTOFF_DEC 和 #define CUTLIM_DEC 是预处理指令，它们定义了两个 16 位的无符号整数类型，CUTOFF_DEC 和 CUTLIM_DEC。它们的含义是将输入的整数 n 右移 16 位，相当于将 n 除以 2^16，并取余数，得到一个 16 位无符号整数。

yyextra_arg 是函数指针，它指向一个函数，这个函数的作用是处理输入的整数 n，当 n 大于 CUTOFF_DEC 时，函数会输出 "number %s overflows 32 bits" 这个错误信息，并将返回值设为 LEX_ERROR。函数的参数包括一个整型变量 yytext_arg，一个整型变量 digit，以及一个指向整型变量的 yyextra_arg。

函数的作用是判断输入的整数 n 是否大于 CUTOFF_DEC，如果是，就执行函数 body，将 n 赋值为 (n * 10) + digit，否则输出错误信息。这里要注意的是，由于 CUTOFF_DEC 和 CUTLIM_DEC 是无符号整数类型，所以 n 在经过右移操作后会变为有符号整数，但仍然可以进行大小比较。


```cpp
#define CUTOFF_DEC	(0xFFFFFFFFU / 10U)
#define CUTLIM_DEC	(0xFFFFFFFFU % 10U)
			if (n > CUTOFF_DEC ||
			    (n == CUTOFF_DEC && digit > CUTLIM_DEC)) {
				bpf_set_error(yyextra_arg,
				    "number %s overflows 32 bits",
				    yytext_arg);
				return LEX_ERROR;
			}
			n = (n * 10) + digit;
		}
	}

	yylval_arg->h = n;
	return NUM;
}


```