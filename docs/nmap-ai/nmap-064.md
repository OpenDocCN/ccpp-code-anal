# Nmap源码解析 64

# `libpcap/pcap-types.h`

This message is a NetGroup message for the NetGroup 005 subgroup. It appears to be a request to join the NetGroup 005 subgroup, which is described as follows:

"To join the NetGroup 005 subgroup, please send a message to the following email address:
netgroup005@calando.com

Please include your name and contact information in the body of the message. We will
require your approval to join your request.

Sincerely,
[Your Name]"

This message is generated by the Davis, California-based company, CACE Technologies, Inc.


```cpp
/*
 * Copyright (c) 2002 - 2005 NetGroup, Politecnico di Torino (Italy)
 * Copyright (c) 2005 - 2009 CACE Technologies, Inc. Davis (California)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Politecnico di Torino nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
```

这段代码定义了一个名为`pcap_types_h`的头文件。通过检查编译器是否支持`#ifdef`或`#define`语句，我们可以确定这个头文件是在特定操作系统上定义的。

在Windows操作系统上，该头文件通过`#ifdef`语句定义了一个名为`u_int`的枚举类型。而在Unix（包括Linux和macOS）操作系统上，该头文件通过`#define`语句定义了`u_int`类型。

这意味着，`pcap_types_h`头文件为`pcap_types.h`文件提供了跨平台类型定义。`pcap_types.h`文件中可能定义了一些`u_int`类型，以及其他类型的定义。


```cpp
#ifndef pcap_types_h
#define pcap_types_h

/*
 * Get u_int defined, by hook or by crook.
 */
#ifdef _WIN32
  /*
   * This defines u_int.
   */
  #include <winsock2.h>
#else /* _WIN32 */
  /*
   * This defines u_int, among other types.
   */
  #include <sys/types.h>
```

这两行代码是C预处理指令，它们检查pcap_types_h.h文件是否定义过。如果文件已经被定义过，则这两行代码将不会被执行。

pcap_types_h.h文件是一个头文件，它定义了pcap类型定义。如果你在编写一个C或C++程序时，需要在其他源文件中使用pcap类型，那么你就需要包含这个头文件。如果你不希望使用这个头文件，那么你可以在你的源文件中定义自己需要的pcap类型，并将它们的定义包含在源文件中。


```cpp
#endif

#endif /* pcap_types_h */

```

# `libpcap/pcap-usb-linux-common.c`

这段代码是一个C语言的函数，名为“pcap-usb-linux-common.c”。它是一个名为“pcap”的软件包的一部分，主要用于处理Linux USB捕捉。下面是解释这段代码的一些要点：

1. 该函数是C语言的，由于C语言的普遍性和灵活性，可以轻松地编写与Linux USB捕捉相关的代码。
2. 该函数基于Linux USB捕捉领域的公共代码，也就是说，它可以从Linux USB captures中提取出公共的、可重复使用的功能。
3. 该函数采用“暴露”的C接口，因此任何人都可以使用这些公共代码，包括在商业和非商业项目中。
4. 该函数遵循Linux的版权通知和专利通知要求，确保使用该软件包的人或组织需要遵守相应的法律要求。
5. 该函数使用该软件包的名称作为文件名的一部分，以向用户表明该软件包的用途和价值。


```cpp
/*
 * Copyright (c) 1993, 1994, 1995, 1996, 1997
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that: (1) source code distributions
 * retain the above copyright notice and this paragraph in its entirety, (2)
 * distributions including binary code include the above copyright notice and
 * this paragraph in its entirety in the documentation or other materials
 * provided with the distribution, and (3) all advertising materials mentioning
 * features or use of this software display the following acknowledgement:
 * ``This product includes software developed by the University of California,
 * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
 * the University nor the names of its contributors may be used to endorse
 * or promote products derived from this software without specific prior
 * written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * pcap-usb-linux-common.c - common code for everything that needs to
 * deal with Linux USB captures.
 */

```

This code looks at the captured Linux kernel buffers in a USB endpoint, such as the one captured by libpcap, and calculates the length of the captured data based on how long it is. It takes into account the data truncation length, which is the length of the data that is truncated due to the limits of the USB endpoint, and also takes into account the pre-truncation data length, if it is greater than zero.

The code then sets the length of the captured data to the maximum of the captured length and the pre-truncation data length, and also sets the length of the pre-truncation data to the maximum of the data truncation length and the captured length.

Finally, the code calculates the length of the pre-truncation data based on the data\_len field of the usb\_isodesc structure in the captured data, and adjusts the length of the pre-truncation data accordingly.

It is important to note that the data\_len field in the usb\_isodesc structure may not always be accurate, as it is the sum of all the isochronous descriptors, which may not always be present in every captured packet, and may be limited by the usb endpoint.


```cpp
#include "pcap/pcap.h"
#include "pcap/usb.h"

#include "pcap-usb-linux-common.h"

/*
 * Compute, from the data provided by the Linux USB memory-mapped capture
 * mechanism, the amount of packet data that would have been provided
 * had the capture mechanism not chopped off any data at the end, if, in
 * fact, it did so.
 *
 * Set the "unsliced length" field of the packet header to that value.
 */
void
fix_linux_usb_mmapped_length(struct pcap_pkthdr *pkth, const u_char *bp)
{
	const pcap_usb_header_mmapped *hdr;
	u_int bytes_left;

	/*
	 * All callers of this routine must ensure that pkth->caplen is
	 * >= sizeof (pcap_usb_header_mmapped).
	 */
	bytes_left = pkth->caplen;
	bytes_left -= sizeof (pcap_usb_header_mmapped);

	hdr = (const pcap_usb_header_mmapped *) bp;
	if (!hdr->data_flag && hdr->transfer_type == URB_ISOCHRONOUS &&
	    hdr->event_type == URB_COMPLETE &&
	    (hdr->endpoint_number & URB_TRANSFER_IN) &&
	    pkth->len == sizeof(pcap_usb_header_mmapped) +
	                 (hdr->ndesc * sizeof (usb_isodesc)) + hdr->urb_len) {
		usb_isodesc *descs;
		u_int pre_truncation_data_len, pre_truncation_len;

		descs = (usb_isodesc *) (bp + sizeof(pcap_usb_header_mmapped));

		/*
		 * We have data (yes, data_flag is 0 if we *do* have data),
		 * and this is a "this is complete" incoming isochronous
		 * transfer event, and the length was calculated based
		 * on the URB length.
		 *
		 * That's not correct, because the data isn't contiguous,
		 * and the isochronous descriptos show how it's scattered.
		 *
		 * Find the end of the last chunk of data in the buffer
		 * referred to by the isochronous descriptors; that indicates
		 * how far into the buffer the data would have gone.
		 *
		 * Make sure we don't run past the end of the captured data
		 * while processing the isochronous descriptors.
		 */
		pre_truncation_data_len = 0;
		for (uint32_t desc = 0;
		    desc < hdr->ndesc && bytes_left >= sizeof (usb_isodesc);
		    desc++, bytes_left -= sizeof (usb_isodesc)) {
			u_int desc_end;

			if (descs[desc].len != 0) {
				desc_end = descs[desc].offset + descs[desc].len;
				if (desc_end > pre_truncation_data_len)
					pre_truncation_data_len = desc_end;
			}
		}

		/*
		 * Now calculate the total length based on that data
		 * length.
		 */
		pre_truncation_len = sizeof(pcap_usb_header_mmapped) +
		    (hdr->ndesc * sizeof (usb_isodesc)) +
		    pre_truncation_data_len;

		/*
		 * If that's greater than or equal to the captured length,
		 * use that as the length.
		 */
		if (pre_truncation_len >= pkth->caplen)
			pkth->len = pre_truncation_len;

		/*
		 * If the captured length is greater than the length,
		 * use the captured length.
		 *
		 * For completion events for incoming isochronous transfers,
		 * it's based on data_len, which is calculated the same way
		 * we calculated pre_truncation_data_len above, except that
		 * it has access to all the isochronous descriptors, not
		 * just the ones that the kernel were able to provide us or,
		 * for a capture file, that weren't sliced off by a snapshot
		 * length.
		 *
		 * However, it might have been reduced by the USB capture
		 * mechanism arbitrarily limiting the amount of data it
		 * provides to userland, or by the libpcap capture code
		 * limiting it to being no more than the snapshot, so
		 * we don't want to just use it all the time; we only
		 * do so to try to get a better estimate of the actual
		 * length - and to make sure the on-the-network length
		 * is always >= the captured length.
		 */
		if (pkth->caplen > pkth->len)
			pkth->len = pkth->caplen;
	}
}

```

# `libpcap/pcap-usb-linux.c`

This is a software license for the USB sniffing API implementation for Linux platform. It is distributed under the terms of the GNU General Public License v2.

The copyright for this software is held by the contributors. The contributors have granted all rights for the reception and use of this software, with the above conditions:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.

This software can be modified by obtaining the source code from the URL https://github.com/KrisKatterjohn/USB-Sniffing-API. The original implementation is available at https://github.com/Italy/USB-Sniffing-API.


```cpp
/*
 * Copyright (c) 2006 Paolo Abeni (Italy)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * USB sniffing API implementation for Linux platform
 * By Paolo Abeni <paolo.abeni@email.it>
 * Modifications: Kris Katterjohn <katterjohn@gmail.com>
 *
 */

```

这段代码是一个用于检测特定头文件是否存在的预处理指令。如果头文件被包含，则包含其头文件和里面的代码。如果头文件未被包含，则不包含任何代码，从而输出一个警告消息。

具体来说，代码的作用是检查系统是否支持配置文件，如果支持，则检查是否包含名为"config.h"的头文件。如果不包含该头文件，则编译并输出一个警告消息。此外，代码还包含一个包含linux下错误处理程序的头文件，如果需要的话，可以用来输出错误信息。


```cpp
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "pcap-int.h"
#include "pcap-usb-linux.h"
#include "pcap-usb-linux-common.h"
#include "pcap/usb.h"

#include "extract.h"

#ifdef NEED_STRERROR_H
#include "strerror.h"
#endif

```

这段代码是一个C语言程序，它包括了多个头文件和一些函数的定义。它们的作用如下：

1. `#include <errno.h>` 和 `#include <stdlib.h>` 是C标准库中的两个头文件，它们分别提供了全局变量`errno`和`stdlib`的定义。

2. `#include <unistd.h>` 是`unistd.h`的包含头文件，它包含了`stdout`、`stderr`、`sys`、`bot`和` Temple`等头文件的定义。

3. `#include <fcntl.h>` 是Linux系统标准库中的一个头文件，它提供了文件输入输出函数的定义。

4. `#include <limits.h>` 是`<limits.h>`的包含头文件，它提供了`max_int`、`max_if中小于等于`INTPMAX`的定义。

5. `#include <string.h>` 是`<string.h>`的包含头文件，它提供了`char*`、`wchar_t*`、`size_t`、`int64_t`、`uint64_t`和`double`等头文件的定义。

6. `#include <dirent.h>` 是`<dirent.h>`的包含头文件，它提供了`struct dirent`的定义。

7. `#include <byteswap.h>` 是`<byteswap.h>`的包含头文件，它提供了`void*`、`char*`、`wchar_t*`和`size_t`等头文件的定义。

8. `#include <netinet/in.h>` 是Linux系统标准库中的一个头文件，它提供了`INET_LOOPback`和`INET_aton`函数的定义。

9. `#include <sys/ioctl.h>` 是Linux系统标准库中的一个头文件，它提供了`<sys/ioctl.h>`的头文件。

10. `#include <sys/mman.h>` 是Linux系统标准库中的一个头文件，它提供了`<sys/mman.h>`的头文件。

11. `#include <sys/umsname.h>` 是Linux系统标准库中的一个头文件，它提供了`<sys/umsname.h>`的头文件。

12. `#ifdef HAVE_LINUX_USBDEVICE_FS_H` 是`/path/to/linux/USBdevice_fs.h`的一个预处理指令，如果这个编译器支持它预处理，它会在编译时将`/path/to/linux/USBdevice_fs.h`的内容复制到`/path/to/linux/USBdevice_fs.c`中。

13. `/* We might need <linux/compiler.h> to define __user for
      * <linux/usbdevice_fs.h> */` 是`/path/to/linux/compiler.h`的一个定义，它指出了`compiler.h`可能需要的一个头文件。

14. `#include <int.h>` 是`<int.h>`的包含头文件，它提供了`int`、`unsigned int`、`long`、`unsigned long`和`long long`等头文件的定义。


```cpp
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>
#include <string.h>
#include <dirent.h>
#include <byteswap.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/utsname.h>
#ifdef HAVE_LINUX_USBDEVICE_FS_H
/*
 * We might need <linux/compiler.h> to define __user for
 * <linux/usbdevice_fs.h>.
 */
```

这段代码包括两个条件编译语句，它们检查当前系统的编译器是否支持Linux编译器。如果支持，那么就会包含`linux/compiler.h`和`linux/usbdevice_fs.h`头文件。然后，又引入了`diag-control.h`头文件。

主要作用是定义了两个头文件，`usbmon.h` 和 `usbmon_dev.h`。`usbmon.h` 是周联合工厂函数，用于产生调试信息，`usbmon_dev.h` 是 `usbmon.h` 的定义。

`#define USB_IFACE "usbmon"` 是 USB 设备接口，定义了 USB 设备的名称。

`#define USBMON_DEV_PREFIX "usbmon"` 和 `#define USBMON_DEV_PREFIX_LEN (sizeof USBMON_DEV_PREFIX - 1)` 是 USB 设备接口前缀的长度，用于定义 USB 设备的名称。

`#define USB_LINE_LEN 4096` 是 USB 线的长度，用于连接到USB 设备。

`#if __BYTE_ORDER == __LITTLE_ENDIAN` 是判断当前系统是否为小端字节序。如果是，那么 `__LITTLE_ENDIAN` 编译选项将被启用，`__WILILEGAL` 宏将被展开。

最后，`#include "diag-control.h"` 是引入了 `diag-control.h` 头文件，可能用于与更多的日志控制有关的功能。


```cpp
#ifdef HAVE_LINUX_COMPILER_H
#include <linux/compiler.h>
#endif /* HAVE_LINUX_COMPILER_H */
#include <linux/usbdevice_fs.h>
#endif /* HAVE_LINUX_USBDEVICE_FS_H */

#include "diag-control.h"

#define USB_IFACE "usbmon"

#define USBMON_DEV_PREFIX "usbmon"
#define USBMON_DEV_PREFIX_LEN	(sizeof USBMON_DEV_PREFIX - 1)
#define USB_LINE_LEN 4096

#if __BYTE_ORDER == __LITTLE_ENDIAN
```



这段代码是一个C语言预处理指令，定义了三个宏定义：htols、htoll和htol64。它们的作用是将定义的宏名称与参数名称进行宏替换，以生成更易于阅读和理解的名称。

htols macro定义了两个宏，分别宏名为"htols"和"htols"，参数宏名为"s"和"l"。htols macro将宏名称替换为"htols"并将参数名称替换为"s",htols macro将宏名称替换为"htops"并将参数名称替换为"l"。这样，当需要使用宏定义时，只需要使用"htols"而不是"htops"。

htoll macro定义了两个宏，分别宏名为"htoll"和"htoll"，参数宏名为"l"和"ll"。htoll macro将宏名称替换为"htoll"并将参数名称替换为"l",htoll macro将宏名称替换为"htollp"并将参数名称替换为"ll"。这样，当需要使用宏定义时，只需要使用"htoll"而不是"htollp"。

最后，定义了一个名为"mon_bin_stats"的结构体，包含两个成员变量"queued"和"dropped"，用于记录二进制数据包队列中的数据包数量和删除的数据包数量。

另外，定义了一个名为"mon_bin_get"的结构体，包含一个指向pcap_usb_header的指针"hdr"和一个指向数据的指针"data"，以及一个数据长度标志"data_len"。这个结构体用于在mon_bin_stats结构体中记录接收到的二进制数据包。


```cpp
#define htols(s) s
#define htoll(l) l
#define htol64(ll) ll
#else
#define htols(s) bswap_16(s)
#define htoll(l) bswap_32(l)
#define htol64(ll) bswap_64(ll)
#endif

struct mon_bin_stats {
	uint32_t queued;
	uint32_t dropped;
};

struct mon_bin_get {
	pcap_usb_header *hdr;
	void *data;
	size_t data_len;   /* Length of data (can be zero) */
};

```

这是一个结构体定义，表示一个名为“mon_bin_mfetch”的结构体，其中包含以下成员：

- offvec: 一个32位的事件向量(vector of events fetched)
- nfetch: 一个32位的事件数量(out: fetched)
- nflush: 一个32位的事件清空数量(out: flushed)

定义了一系列宏，包括：

- MON_IOC_MAGIC: 0x92，定义了MON_IOC消息类型的魔数
- MON_IOCQ_URB_LEN: _IO(MON_IOC_MAGIC, 1)，定义了MON_IOCQURB消息类型的长度
- MON_IOCX_URB: _IO(MON_IOC_MAGIC, 2, struct mon_bin_hdr)，定义了MON_IOCXURB消息类型的起始地址
- MON_IOCG_STATS: _IO(MON_IOC_MAGIC, 3, struct mon_bin_stats)，定义了MON_IOCGSTATS消息类型的起始地址
- MON_IOCT_RING_SIZE: _IO(MON_IOC_MAGIC, 4)，定义了MON_IOCTRING_SIZE消息类型的起始地址
- MON_IOCQ_RING_SIZE: _IO(MON_IOC_MAGIC, 5)，定义了MON_IOCQRING_SIZE消息类型的起始地址
- MON_IOCX_GET: _IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)，定义了MON_IOCXGET消息类型的起始地址
- MON_IOCX_MFETCH: _IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)，定义了MON_IOCXMFETCH消息类型的起始地址


```cpp
struct mon_bin_mfetch {
	int32_t *offvec;   /* Vector of events fetched */
	int32_t nfetch;    /* Number of events to fetch (out: fetched) */
	int32_t nflush;    /* Number of events to flush */
};

#define MON_IOC_MAGIC 0x92

#define MON_IOCQ_URB_LEN _IO(MON_IOC_MAGIC, 1)
#define MON_IOCX_URB  _IOWR(MON_IOC_MAGIC, 2, struct mon_bin_hdr)
#define MON_IOCG_STATS _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)
#define MON_IOCT_RING_SIZE _IO(MON_IOC_MAGIC, 4)
#define MON_IOCQ_RING_SIZE _IO(MON_IOC_MAGIC, 5)
#define MON_IOCX_GET   _IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)
#define MON_IOCX_MFETCH _IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)
```

这段代码定义了几个宏，用于描述USB Linux设备中MON_IOC_MAGIC设备的设置。

```cpp
#define MON_IOCH_MFLUSH                         _IO(MON_IOC_MAGIC, 8)
#define MON_BIN_SETUP                         0x1 /* setup hdr is present*/
#define MON_BIN_SETUP_ZERO                  0x2 /* setup buffer is not available */
#define MON_BIN_DATA_ZERO                  0x4 /* data buffer is not available */
#define MON_BIN_ERROR                        8
```

第一个宏定义了`MON_IOCH_MFLUSH`，它是一个宏定义，将`MON_IOC_MAGIC`作为第一个参数，第二个参数为8，表示这是一个I/O魔术。这个魔术将向后兼容的以`MON_IOC_MAGIC`为前缀的函数提供更多的功能。

接下来的三个宏定义了一系列用于设置USB Linux设备中MON_IOC_MAGIC设备设置的标志。

宏定义了两个与USB相关的宏：`MON_BIN_SETUP`和`MON_BIN_SETUP_ZERO`。这两个宏分别用于设置USB设备上MON_IOC_MAGIC为`0x1`和`0x2`的设置。通过这些设置，可以设置USB设备的设置选项。

然后定义了一个宏`MON_BIN_DATA_ZERO`，用于设置USB数据缓冲区为空。

最后一个宏定义了一个常量`MON_BIN_ERROR`，用于标识在设置USB设备时发生的错误。

另外，定义了一个结构体`pcap_usb_linux`，用于在USB Linux设备中捕获数据包。


```cpp
#define MON_IOCH_MFLUSH _IO(MON_IOC_MAGIC, 8)

#define MON_BIN_SETUP	0x1 /* setup hdr is present*/
#define MON_BIN_SETUP_ZERO	0x2 /* setup buffer is not available */
#define MON_BIN_DATA_ZERO	0x4 /* data buffer is not available */
#define MON_BIN_ERROR	0x8

/*
 * Private data for capturing on Linux USB.
 */
struct pcap_usb_linux {
	u_char *mmapbuf;	/* memory-mapped region pointer */
	size_t mmapbuflen;	/* size of region */
	int bus_index;
	u_int packets_read;
};

```

This is a code snippet that modifies the USB device driver for Linux, adding a new USB device to the device list.

The `usb_dev_add` function takes a `pcap_if_list_t` structure that contains the device list, a device number, and a human-readable error message. The function adds a new USB device to the device list and returns 0 on success, or -1 on failure.

The `add_dev` function is used by the `usb_inject_linux` function, which is called by the `usb_setdirection_linux` function.

The `usb_inject_linux` function takes a `pcap_t` structure that contains the capitalization table for the device, a raw data buffer, and the maximum number of bytes that should be contributed to the traffic on this bus. The function injects the raw data buffer into the traffic for the specified bus, with the maximum number of bytes specified as the argument.

The `usb_setdirection_linux` function takes a `pcap_t` structure that contains the device direction for the bus, and a new direction for the device. The function updates the device direction for the bus to the new direction.

The `usb_cleanup_linux_mmap` function is used by the `add_dev` function, as it is called by the `usb_inject_linux` function when the new USB device is injected into the device list. It cleans up the memory used by the USB device by calling the `mmap_destroy` function, which removes the memory mapping between the device and the kernel's memory space.


```cpp
/* forward declaration */
static int usb_activate(pcap_t *);
static int usb_stats_linux_bin(pcap_t *, struct pcap_stat *);
static int usb_read_linux_bin(pcap_t *, int , pcap_handler , u_char *);
static int usb_read_linux_mmap(pcap_t *, int , pcap_handler , u_char *);
static int usb_inject_linux(pcap_t *, const void *, int);
static int usb_setdirection_linux(pcap_t *, pcap_direction_t);
static void usb_cleanup_linux_mmap(pcap_t *);

/* facility to add an USB device to the device list*/
static int
usb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)
{
	char dev_name[10];
	char dev_descr[30];
	snprintf(dev_name, 10, USB_IFACE"%d", n);
	/*
	 * XXX - is there any notion of "up" and "running"?
	 */
	if (n == 0) {
		/*
		 * As this refers to all buses, there's no notion of
		 * "connected" vs. "disconnected", as that's a property
		 * that would apply to a particular USB interface.
		 */
		if (add_dev(devlistp, dev_name,
		    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
		    "Raw USB traffic, all USB buses", err_str) == NULL)
			return -1;
	} else {
		/*
		 * XXX - is there a way to determine whether anything's
		 * plugged into this bus interface or not, and set
		 * PCAP_IF_CONNECTION_STATUS_CONNECTED or
		 * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?
		 */
		snprintf(dev_descr, 30, "Raw USB traffic, bus number %d", n);
		if (add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)
			return -1;
	}

	return 0;
}

```

这段代码是一个用于获取USB设备驱动程序的函数。它接受一个指向 USB 设备列表的指针和字符串变量 err_str，用于存储错误信息。函数首先打开一个名为 /dev 的目录，并扫描其中所有的设备。对于每个设备，函数使用 usb_dev_add 函数将驱动程序添加到设备列表中。函数使用 binary-mode 支持，因此它不需要对 /dev/usbmon 目录进行特殊处理。


```cpp
int
usb_findalldevs(pcap_if_list_t *devlistp, char *err_str)
{
	struct dirent* data;
	int ret = 0;
	DIR* dir;
	int n;
	char* name;

	/*
	 * We require 2.6.27 or later kernels, so we have binary-mode support.
	 * The devices are of the form /dev/usbmon{N}.
	 * Open /dev and scan it.
	 */
	dir = opendir("/dev");
	if (dir != NULL) {
		while ((ret == 0) && ((data = readdir(dir)) != 0)) {
			name = data->d_name;

			/*
			 * Is this a usbmon device?
			 */
			if (strncmp(name, USBMON_DEV_PREFIX,
			    USBMON_DEV_PREFIX_LEN) != 0)
				continue;	/* no */

			/*
			 * What's the device number?
			 */
			if (sscanf(&name[USBMON_DEV_PREFIX_LEN], "%d", &n) == 0)
				continue;	/* failed */

			ret = usb_dev_add(devlistp, n, err_str);
		}

		closedir(dir);
	}
	return 0;
}

```

This function appears to modify the ring buffer size based on the snapshot size. If the snapshot size is greater than the maximum allowed ring size, the function sets the ring size to the maximum allowed size and adjusts the snapshot length accordingly. If the snapshot size is less than the minimum allowed ring size, the function sets the ring size to the minimum allowed size and adjusts the snapshot length accordingly.

It is important to note that the function returns an error code based on the result of the ioctl call. If the ioctl call fails, the function returns -1.


```cpp
/*
 * Matches what's in mon_bin.c in the Linux kernel.
 */
#define MIN_RING_SIZE	(8*1024)
#define MAX_RING_SIZE	(1200*1024)

static int
usb_set_ring_size(pcap_t* handle, int header_size)
{
	/*
	 * A packet from binary usbmon has:
	 *
	 *  1) a fixed-length header, of size header_size;
	 *  2) descriptors, for isochronous transfers;
	 *  3) the payload.
	 *
	 * The kernel buffer has a size, defaulting to 300KB, with a
	 * minimum of 8KB and a maximum of 1200KB.  The size is set with
	 * the MON_IOCT_RING_SIZE ioctl; the size passed in is rounded up
	 * to a page size.
	 *
	 * No more than {buffer size}/5 bytes worth of payload is saved.
	 * Therefore, if we subtract the fixed-length size from the
	 * snapshot length, we have the biggest payload we want (we
	 * don't worry about the descriptors - if we have descriptors,
	 * we'll just discard the last bit of the payload to get it
	 * to fit).  We multiply that result by 5 and set the buffer
	 * size to that value.
	 */
	int ring_size;

	if (handle->snapshot < header_size)
		handle->snapshot = header_size;
	/* The maximum snapshot size is small enough that this won't overflow */
	ring_size = (handle->snapshot - header_size) * 5;

	/*
	 * Will this get an error?
	 * (There's no wqy to query the minimum or maximum, so we just
	 * copy the value from the kernel source.  We don't round it
	 * up to a multiple of the page size.)
	 */
	if (ring_size > MAX_RING_SIZE) {
		/*
		 * Yes.  Lower the ring size to the maximum, and set the
		 * snapshot length to the value that would give us a
		 * maximum-size ring.
		 */
		ring_size = MAX_RING_SIZE;
		handle->snapshot = header_size + (MAX_RING_SIZE/5);
	} else if (ring_size < MIN_RING_SIZE) {
		/*
		 * Yes.  Raise the ring size to the minimum, but leave
		 * the snapshot length unchanged, so we show the
		 * callback no more data than specified by the
		 * snapshot length.
		 */
		ring_size = MIN_RING_SIZE;
	}

	if (ioctl(handle->fd, MON_IOCT_RING_SIZE, ring_size) == -1) {
		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
		    errno, "Can't set ring size from fd %d", handle->fd);
		return -1;
	}
	return ring_size;
}

```

这段代码是一个用于 Linux 系统的 pcap 库函数，名为 usb_mmap。它的作用是允许用户设置 USB 设备转储文件的大小，以便在系统中启用 USB 设备树。

函数接收一个 pcap 句柄（handle）参数，这个句柄是一个指向结构体 pcap_usb_linux 的指针。

函数首先尝试设置环的大小，这个大小是根据 snapshot 长度来计算的，这样可以确保不超出操作系统对 ring 大小的支持。设置环的大小失败时，函数将使用非内存映射的方式获取 USB 设备转储文件，并返回 1，表示成功。如果设置环的大小成功，函数将返回 0，成功设置 USB 设备转储文件。


```cpp
static
int usb_mmap(pcap_t* handle)
{
	struct pcap_usb_linux *handlep = handle->priv;
	int len;

	/*
	 * Attempt to set the ring size as appropriate for the snapshot
	 * length, reducing the snapshot length if that'd make the ring
	 * bigger than the kernel supports.
	 */
	len = usb_set_ring_size(handle, (int)sizeof(pcap_usb_header_mmapped));
	if (len == -1) {
		/* Failed.  Fall back on non-memory-mapped access. */
		return 0;
	}

	handlep->mmapbuflen = len;
	handlep->mmapbuf = mmap(0, handlep->mmapbuflen, PROT_READ,
	    MAP_SHARED, handle->fd, 0);
	if (handlep->mmapbuf == MAP_FAILED) {
		/*
		 * Failed.  We don't treat that as a fatal error, we
		 * just try to fall back on non-memory-mapped access.
		 */
		return 0;
	}
	return 1;
}

```

这段代码定义了一些宏，用于描述USB设备文件系统的相关信息。

首先，通过#ifdef标志检查操作系统是否支持Linux USB设备文件系统。如果不支持，则定义了一些常量，如CTRL_TIMEOUT表示控制台timeout超时时间( milliseconds )。

接下来，定义了一些宏，用于定义USB设备文件系统的配置和描述符。USB_DIR_IN表示USB设备目录的输入类型，USB_TYPE_STANDARD表示USB标准类型，USB_RECIP_DEVICE表示设备接收者类型，USB_REQ_GET_DESCRIPTOR表示USB描述符的获取请求。

然后，定义了一些与USB设备文件系统相关的常量。USB_DT_DEVICE表示设备描述符目录的索引，USB_DT_CONFIG表示配置描述符目录的索引。USB_DEVICE_DESCRIPTOR_SIZE和USB_CONFIG_DESCRIPTOR_SIZE分别表示设备描述符和配置描述符的大小。

最后，通过#define标志定义了一些函数，用于获取/设置USB设备的配置描述符。


```cpp
#ifdef HAVE_LINUX_USBDEVICE_FS_H

#define CTRL_TIMEOUT    (5*1000)        /* milliseconds */

#define USB_DIR_IN		0x80
#define USB_TYPE_STANDARD	0x00
#define USB_RECIP_DEVICE	0x00

#define USB_REQ_GET_DESCRIPTOR	6

#define USB_DT_DEVICE		1
#define USB_DT_CONFIG		2

#define USB_DEVICE_DESCRIPTOR_SIZE	18
#define USB_CONFIG_DESCRIPTOR_SIZE	9

```

这段代码的作用是针对连接到总线上的USB设备进行描述符的查询，以便于外部应用程序（如Wireshark）进行数据解码。它将捕获到总线上的USB设备配置描述符和数据，并在被查询的设备的配置描述符中进行分析，以便于了解USB设备的配置和功能。

具体来说，这段代码实现以下几个步骤：

1. 扫描总线上连接的USB设备，并获取设备节点。
2. 对于每个设备节点，执行以下操作：
a. 取得设备节点名称（即USB设备名称）。
b. 如果设备节点名称以点（.）开头的，则跳过此行。
c. 将设备节点名称存储在`busdevpath`数组中。
d. 如果接下来的配置描述符是有效的，则执行以下操作：
e. 取得一个描述符缓冲区（用于存储配置描述符）。
f. 如果`configdesc`缓冲区已分配，则将`configdesc`中的内容复制到新的描述符缓冲区中。
g. 创建一个新的配置描述符`desc`，其中包含`configdesc`中的配置描述符和当前设备节点名称。
i. 设置`ret`为`1`，表示成功分析配置描述符。
3. 将查询得到的配置描述符和数据存储在`desc`中，以便于外部应用程序进行数据解码。


```cpp
/* probe the descriptors of the devices attached to the bus */
/* the descriptors will end up in the captured packet stream */
/* and be decoded by external apps like wireshark */
/* without these identifying probes packet data can't be fully decoded */
static void
probe_devices(int bus)
{
	struct usbdevfs_ctrltransfer ctrl;
	struct dirent* data;
	int ret = 0;
	char busdevpath[sizeof("/dev/bus/usb/000/") + NAME_MAX];
	DIR* dir;
	uint8_t descriptor[USB_DEVICE_DESCRIPTOR_SIZE];
	uint8_t configdesc[USB_CONFIG_DESCRIPTOR_SIZE];

	/* scan usb bus directories for device nodes */
	snprintf(busdevpath, sizeof(busdevpath), "/dev/bus/usb/%03d", bus);
	dir = opendir(busdevpath);
	if (!dir)
		return;

	while ((ret >= 0) && ((data = readdir(dir)) != 0)) {
		int fd;
		char* name = data->d_name;

		if (name[0] == '.')
			continue;

		snprintf(busdevpath, sizeof(busdevpath), "/dev/bus/usb/%03d/%s", bus, data->d_name);

		fd = open(busdevpath, O_RDWR);
		if (fd == -1)
			continue;

		/*
		 * Sigh.  Different kernels have different member names
		 * for this structure.
		 */
```

这段代码是一个 C 语言程序，它定义了一个 USB 设备控制 transfer 的 Request。通过使用宏定义，它允许在不同的编译器中使用相同的代码。

具体来说，这段代码定义了一个名为 "USBDEVFS_CTRLTRANSFER_BREQUESTTYPE" 的宏，它表示了 USB 设备控制 transfer 的请求类型、请求和服务类型。如果宏定义在头文件中定义，则以 #ifdef 开始，如果不是，则以 #define 开始。

在 define 语句中，定义了两个宏，分别定义了 USB 设备控制 transfer 的 Request 类型和请求值，以及 Request 的 Configuration 描述符的值。同时，还定义了 Request 的 timeout 选项。

接着，通过使用 ioctl 函数，设置 Request 的 Configuration 描述符，设置为设备的 Descriptor，并设置 Request 的 timeout 选项。最后，使用 ret 函数检查是否成功设置 Request。

整个函数的作用是设置 USB 设备控制 transfer Request 的 Configuration 描述符，设置 Request 的 timeout 选项，并使用 ioctl 函数发送请求，获取设备的 Descriptor。


```cpp
#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
		ctrl.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
		ctrl.bRequest = USB_REQ_GET_DESCRIPTOR;
		ctrl.wValue = USB_DT_DEVICE << 8;
		ctrl.wIndex = 0;
		ctrl.wLength = sizeof(descriptor);
#else
		ctrl.requesttype = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
		ctrl.request = USB_REQ_GET_DESCRIPTOR;
		ctrl.value = USB_DT_DEVICE << 8;
		ctrl.index = 0;
		ctrl.length = sizeof(descriptor);
#endif
		ctrl.data = descriptor;
		ctrl.timeout = CTRL_TIMEOUT;

		ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);

		/* Request CONFIGURATION descriptor alone to know wTotalLength */
```

这段代码是一个 C 语言代码，它定义了一个名为“USBDEVFS_CTRLTRANSFER_BREQUESTTYPE”的结构体变量 ctrl，并实现了对该结构体的控制。

具体来说，这段代码的作用如下：

1. 如果定义了宏名“HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE”，则执行以下操作：

  a. 将 ctrl.wValue 设置为 USB_DT_CONFIG 高 8 位，即 0x12345678。

  b. 将 ctrl.wLength 设置为 configdesc 结构体的大小，即 32 位。

  c. 如果已经定义了这个宏，则不必再次定义，直接跳过。

2. 如果未定义宏名“HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE”，则执行以下操作：

  a. 将 ctrl.value 设置为 USB_DT_CONFIG 高 8 位，即 0x12345678。

  b. 将 ctrl.length 设置为 configdesc 结构体的大小，即 32 位。

  c. 如果已经定义了这个宏，则不必再次定义，直接跳过。

d. 最后，通过 ioctl() 函数将 ctrl 结构体发送给设备，并获取返回值 ret。

e. 如果 ret >= 0，说明设备接受 ctrl 结构体，则执行以下操作：

  f. 通过 ioctl() 函数读取设备的配置数据，具体实现方式取决于设备类型和操作系统。

  g. 将读取到的配置数据按位或后与 ctrl.data 指向的地址，得到一个只与 ctrl.data 指向的配置数据不同的值，即 configdesc[2] 的值。

  h. 最终，将得到的 configdesc[2] 的值作为整数类型，传输给设备，完成 USB 设备与操作系统的通信。


```cpp
#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
		ctrl.wValue = USB_DT_CONFIG << 8;
		ctrl.wLength = sizeof(configdesc);
#else
		ctrl.value = USB_DT_CONFIG << 8;
		ctrl.length = sizeof(configdesc);
#endif
		ctrl.data = configdesc;
		ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
		if (ret >= 0) {
			uint16_t wtotallength;
			wtotallength = EXTRACT_LE_U_2(&configdesc[2]);
#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
			ctrl.wLength = wtotallength;
#else
			ctrl.length = wtotallength;
```

This is a C function that takes a USB device string (device name followed by a /), a buffer to hold the Linux USB device description (ebuf), and a pointer to a boolean indicating whether the device is a driver or a host. It returns a pointer to a new pcap\_t structure that represents the USB device.

The function first checks if the device starts with USB\_IFACE. If it does, it assume the device is a driver and returns a NULL pointer. If it does not, it looks for a number in the device name and tries to convert it to an integer. If it succeeds, it sets the is\_ours flag to 1 and returns a NULL pointer. If it fails, it sets the is\_ours flag to 0 and returns a NULL pointer.

If the device is a driver, the function calls the usb\_activate function to activate the device. This function may do any necessary initialization or cleanup before returning.

Note that the is\_ours flag should be set to 0 before calling the usb\_activate function. Also, this function should be called from a thread that has access to the pcap library (since the pcap\_t structure is created there).


```cpp
#endif
			ctrl.data = malloc(wtotallength);
			if (ctrl.data) {
				ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
				free(ctrl.data);
			}
		}
		close(fd);
	}
	closedir(dir);
}
#endif /* HAVE_LINUX_USBDEVICE_FS_H */

pcap_t *
usb_create(const char *device, char *ebuf, int *is_ours)
{
	const char *cp;
	char *cpend;
	long devnum;
	pcap_t *p;

	/* Does this look like a USB monitoring device? */
	cp = strrchr(device, '/');
	if (cp == NULL)
		cp = device;
	/* Does it begin with USB_IFACE? */
	if (strncmp(cp, USB_IFACE, sizeof USB_IFACE - 1) != 0) {
		/* Nope, doesn't begin with USB_IFACE */
		*is_ours = 0;
		return NULL;
	}
	/* Yes - is USB_IFACE followed by a number? */
	cp += sizeof USB_IFACE - 1;
	devnum = strtol(cp, &cpend, 10);
	if (cpend == cp || *cpend != '\0') {
		/* Not followed by a number. */
		*is_ours = 0;
		return NULL;
	}
	if (devnum < 0) {
		/* Followed by a non-valid number. */
		*is_ours = 0;
		return NULL;
	}

	/* OK, it's probably ours. */
	*is_ours = 1;

	p = PCAP_CREATE_COMMON(ebuf, struct pcap_usb_linux);
	if (p == NULL)
		return (NULL);

	p->activate_op = usb_activate;
	return (p);
}

```

It seems that the code is trying to read the device name and then the USB bus index from it. However, it is unable to do so because the device name is being treated as a Unix domain name, and therefore the index is being treated as a literal value rather than a symbolic reference.

To fix this, you can try using the 'strings' command instead of 'scanning' the device name to get the index. This should work in both Unix and Windows systems. Alternatively, you can try using the 'strings' command to get the index from the device name, like this:
```cppphp
sprintf(handle->errbuf, "%s: USB bus index is %d", handle->opt.device, handlep->bus_index);
```
This will print the device name and the USB bus index to the handle's error buffer.


```cpp
static int
usb_activate(pcap_t* handle)
{
	struct pcap_usb_linux *handlep = handle->priv;
	char		full_path[USB_LINE_LEN];

	/*
	 * Turn a negative snapshot value (invalid), a snapshot value of
	 * 0 (unspecified), or a value bigger than the normal maximum
	 * value, into the maximum allowed value.
	 *
	 * If some application really *needs* a bigger snapshot
	 * length, we should just increase MAXIMUM_SNAPLEN.
	 */
	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
		handle->snapshot = MAXIMUM_SNAPLEN;

	/* Initialize some components of the pcap structure. */
	handle->bufsize = handle->snapshot;
	handle->offset = 0;
	handle->linktype = DLT_USB_LINUX;

	handle->inject_op = usb_inject_linux;
	handle->setfilter_op = install_bpf_program; /* no kernel filtering */
	handle->setdirection_op = usb_setdirection_linux;
	handle->set_datalink_op = NULL;	/* can't change data link type */
	handle->getnonblock_op = pcap_getnonblock_fd;
	handle->setnonblock_op = pcap_setnonblock_fd;

	/*get usb bus index from device name */
	if (sscanf(handle->opt.device, USB_IFACE"%d", &handlep->bus_index) != 1)
	{
		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
			"Can't get USB bus index from %s", handle->opt.device);
		return PCAP_ERROR;
	}

	/*
	 * We require 2.6.27 or later kernels, so we have binary-mode support.
	 * Try to open the binary interface.
	 */
	snprintf(full_path, USB_LINE_LEN, "/dev/"USBMON_DEV_PREFIX"%d",
	    handlep->bus_index);
	handle->fd = open(full_path, O_RDONLY, 0);
	if (handle->fd < 0)
	{
		/*
		 * The attempt failed; why?
		 */
		switch (errno) {

		case ENOENT:
			/*
			 * The device doesn't exist.
			 * That could either mean that there's
			 * no support for monitoring USB buses
			 * (which probably means "the usbmon
			 * module isn't loaded") or that there
			 * is but that *particular* device
			 * doesn't exist (no "scan all buses"
			 * device if the bus index is 0, no
			 * such bus if the bus index isn't 0).
			 *
			 * For now, don't provide an error message;
			 * if we can determine what the particular
			 * problem is, we should report that.
			 */
			handle->errbuf[0] = '\0';
			return PCAP_ERROR_NO_SUCH_DEVICE;

		case EACCES:
			/*
			 * We didn't have permission to open it.
			 */
```

这段代码是用来处理 Linux 系统中 Usb 设备文件的错误。它包括了以下几个主要部分：

1. DIAG_OFF_FORMAT_TRUNCATION：输出错误信息，描述为什么尝试打开 USB 设备文件失败，并提示需要具有根特权权限。
2. DIAG_ON_FORMAT_TRUNCATION：与 DIAG_OFF_FORMAT_TRUNCATION 类似，但是输出错误信息，描述为什么尝试打开 USB 设备文件失败，并提示操作系统可能需要具有根特权权限。这是因为在这个操作系统中，用户组可能没有足够的权限来打开 USB 设备文件。
3. default：当上面两个部分都出现时，执行default部分代码。这部分代码包含了一些默认处理，如关闭尝试打开的 USB 设备文件，并返回一个表示错误的代码。
4. 处理 Usb 设备文件错误：如果在处理 Usb 设备文件错误时出现错误，使用最后一个部分代码进行错误处理。这部分代码会尝试使用 fast mmap 访问来打开 USB 设备文件，如果没有成功，就会返回一个表示错误的代码。根据最后的错误处理，如果文件成功打开，那么就会设置一些统计信息。


```cpp
DIAG_OFF_FORMAT_TRUNCATION
			snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
			    "Attempt to open %s failed with EACCES - root privileges may be required",
			    full_path);
DIAG_ON_FORMAT_TRUNCATION
			return PCAP_ERROR_PERM_DENIED;

		default:
			/*
			 * Something went wrong.
			 */
			pcap_fmt_errmsg_for_errno(handle->errbuf,
			    PCAP_ERRBUF_SIZE, errno,
			    "Can't open USB bus file %s", full_path);
			return PCAP_ERROR;
		}
	}

	if (handle->opt.rfmon)
	{
		/*
		 * Monitor mode doesn't apply to USB devices.
		 */
		close(handle->fd);
		return PCAP_ERROR_RFMON_NOTSUP;
	}

	/* try to use fast mmap access */
	if (usb_mmap(handle))
	{
		/* We succeeded. */
		handle->linktype = DLT_USB_LINUX_MMAPPED;
		handle->stats_op = usb_stats_linux_bin;
		handle->read_op = usb_read_linux_mmap;
		handle->cleanup_op = usb_cleanup_linux_mmap;
```

这段代码是一个用于 Linux USB 设备的设备文件系统的函数。它主要实现了两个功能：

1. 检测 Linux USB 设备文件系统是否支持二进制接口访问，如果不支持，则尝试使用二进制接口访问。
2. 如果检测到文件系统支持二进制接口访问，则设置环的大小，以便于在拍摄快照时减少快照长度。

具体来说，代码首先通过函数 `probe_devices` 尝试检测文件系统是否支持二进制接口访问。如果检测到文件系统不支持二进制接口访问，则函数将返回一个表示失败的常量。如果检测到文件系统支持二进制接口访问，则函数将调用 `usb_set_ring_size` 函数设置环的大小，这个函数的参数是一个指向 `pcap_usb_header` 类型的指针，表示每秒可承受的最大数据大小。如果设置环的大小失败，则函数将返回一个表示失败的常量，并尝试关闭文件并返回 PCAP_ERROR。如果设置环的大小成功，则函数将返回 0。

另外，如果函数在执行过程中尝试使用 `handle->fd` 文件进行读写操作时失败，则将调用 `close` 函数关闭文件并返回 PCAP_ERROR。如果函数在执行过程中成功设置环的大小并读取文件，则返回 0。


```cpp
#ifdef HAVE_LINUX_USBDEVICE_FS_H
		probe_devices(handlep->bus_index);
#endif

		/*
		 * "handle->fd" is a real file, so
		 * "select()" and "poll()" work on it.
		 */
		handle->selectable_fd = handle->fd;
		return 0;
	}

	/*
	 * We failed; try plain binary interface access.
	 *
	 * Attempt to set the ring size as appropriate for
	 * the snapshot length, reducing the snapshot length
	 * if that'd make the ring bigger than the kernel
	 * supports.
	 */
	if (usb_set_ring_size(handle, (int)sizeof(pcap_usb_header)) == -1) {
		/* Failed. */
		close(handle->fd);
		return PCAP_ERROR;
	}
	handle->stats_op = usb_stats_linux_bin;
	handle->read_op = usb_read_linux_bin;
```

这段代码的作用是检查系统是否支持在Linux USB设备上使用USB设备文件系统(USBDEVICE_FS_H)。如果不支持，代码会尝试使用标准的USB设备文件系统并提供支持。

具体来说，代码首先检查定义头文件HAVE_LINUX_USBDEVICE_FS_H是否与当前系统平台相关。如果不相关，代码将不会执行下面的probe_devices函数。

如果HAVE_LINUX_USBDEVICE_FS_H已定义，probe_devices函数将被调用以检查设备是否支持USB设备文件系统。如果设备支持该文件系统，代码将在handle->fd文件上执行select()和poll()函数。这是因为handle->fd文件是一个真正的文件，而select()和poll()函数可以通过文件描述符访问该文件。

如果handle->fd文件不是一个真正的文件，代码将在handle->errbuf数组中分配空间并返回PCAP_ERROR。此外，代码还定义了一个handle->buffer变量，用于在设备支持二进制或文本访问时分配读取缓冲区。如果无法在内存中分配足够大的缓冲区，代码将返回PCAP_ERROR。

最后，如果设备支持USB设备文件系统，代码将返回0。否则，代码将返回PCAP_ERROR。


```cpp
#ifdef HAVE_LINUX_USBDEVICE_FS_H
	probe_devices(handlep->bus_index);
#endif

	/*
	 * "handle->fd" is a real file, so "select()" and "poll()"
	 * work on it.
	 */
	handle->selectable_fd = handle->fd;

	/* for plain binary access and text access we need to allocate the read
	 * buffer */
	handle->buffer = malloc(handle->bufsize);
	if (!handle->buffer) {
		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
		    errno, "malloc");
		close(handle->fd);
		return PCAP_ERROR;
	}
	return 0;
}

```



这两个函数是用于 Linux 系统上的 usb_inject_linux 和 usb_setdirection_linux 函数，属于 usb_inject_linux 函数的作用是输出一条错误消息，指出当前系统不支持在 USB 设备上进行数据包注入。而 usb_setdirection_linux 函数的作用是设置给定的 pcap_t 结构体指向一个 valid 的 pcap_direction_t 变量。


```cpp
static int
usb_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)
{
	snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
	    "Packet injection is not supported on USB devices");
	return (-1);
}

static int
usb_setdirection_linux(pcap_t *p, pcap_direction_t d)
{
	/*
	 * It's guaranteed, at this point, that d is a valid
	 * direction value.
	 */
	p->direction = d;
	return 0;
}

```

这段代码是一个用于获取Linux内核UAPI统计信息的C函数。它接受一个pcap_t类型的输入参数handle和一个结构体数组stats作为输出参数。

函数的作用是读取Linux内核中USB统计信息，包括接收和丢弃的数据包数量，以及接收和丢弃的数据包百分比。然后将统计信息添加到输出结构体数组中，并返回0表示成功。

函数首先定义了一个名为handlep的struct pcap_usb_linux结构体变量，该结构体用于存储统计信息。然后定义了一个名为ret的int变量，用于存储从操作系统调用ioctl的返回值。

接下来，函数使用ioctl函数调用handle的文件描述符，并读取由操作系统返回的统计信息。如果函数调用失败，将错误信息打印到handle的errbuf中，然后返回-1。

如果函数调用成功，将统计信息存储到handlep->packets_read和st.queued中，然后将stats->ps_recv和stats->ps_drop替换为统计信息。最后，函数返回0表示成功。


```cpp
static int
usb_stats_linux_bin(pcap_t *handle, struct pcap_stat *stats)
{
	struct pcap_usb_linux *handlep = handle->priv;
	int ret;
	struct mon_bin_stats st;
	ret = ioctl(handle->fd, MON_IOCG_STATS, &st);
	if (ret < 0)
	{
		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
		    errno, "Can't read stats from fd %d", handle->fd);
		return -1;
	}

	stats->ps_recv = handlep->packets_read + st.queued;
	stats->ps_drop = st.dropped;
	stats->ps_ifdrop = 0;
	return 0;
}

```

This is a function definition for `pkth.packets_read`. It appears to be a function that keeps track of the number of packets that have been read from the USB device, based on the `pcap_usb_handle()` function.

Here's an overview of the function:

1. The function takes in a `pcap_usb_handle` structure, which represents the USB device handle.
2. It initializes the `pkth.len` variable to the size of the `pcap_usb_header`, which is required by the USB device.
3. It sets the `pkth.ts.tv_sec` and `pkth.ts.tv_usec` variables to the current timestamp.
4. It passes the `pcap_filter()` function to the `handle->fcode.bf_insns` pointer to determine which packets to pass through the filter.
5. If the filter passes any packets, the function increments the `handlep->packets_read` counter and calls the `callback()` function to pass the packets to the user.
6. If the filter fails to pass any packets, the function returns 0 to indicate that no packets were passed through the filter.

This function appears to be an essential part of the packet processing mechanism for the USB device, as it keeps track of the number of packets that have been read and passed through the filter.


```cpp
/*
 * see <linux-kernel-source>/Documentation/usb/usbmon.txt and
 * <linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI
 */
static int
usb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)
{
	struct pcap_usb_linux *handlep = handle->priv;
	struct mon_bin_get info;
	int ret;
	struct pcap_pkthdr pkth;
	u_int clen = handle->snapshot - sizeof(pcap_usb_header);

	/* the usb header is going to be part of 'packet' data*/
	info.hdr = (pcap_usb_header*) handle->buffer;
	info.data = (u_char *)handle->buffer + sizeof(pcap_usb_header);
	info.data_len = clen;

	/* ignore interrupt system call errors */
	do {
		ret = ioctl(handle->fd, MON_IOCX_GET, &info);
		if (handle->break_loop)
		{
			handle->break_loop = 0;
			return -2;
		}
	} while ((ret == -1) && (errno == EINTR));
	if (ret < 0)
	{
		if (errno == EAGAIN)
			return 0;	/* no data there */

		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
		    errno, "Can't read from fd %d", handle->fd);
		return -1;
	}

	/*
	 * info.hdr->data_len is the number of bytes of isochronous
	 * descriptors (if any) plus the number of bytes of data
	 * provided.  There are no isochronous descriptors here,
	 * because we're using the old 48-byte header.
	 *
	 * If info.hdr->data_flag is non-zero, there's no URB data;
	 * info.hdr->urb_len is the size of the buffer into which
	 * data is to be placed; it does not represent the amount
	 * of data transferred.  If info.hdr->data_flag is zero,
	 * there is URB data, and info.hdr->urb_len is the number
	 * of bytes transmitted or received; it doesn't include
	 * isochronous descriptors.
	 *
	 * The kernel may give us more data than the snaplen; if it did,
	 * reduce the data length so that the total number of bytes we
	 * tell our client we have is not greater than the snaplen.
	 */
	if (info.hdr->data_len < clen)
		clen = info.hdr->data_len;
	info.hdr->data_len = clen;
	pkth.caplen = sizeof(pcap_usb_header) + clen;
	if (info.hdr->data_flag) {
		/*
		 * No data; just base the on-the-wire length on
		 * info.hdr->data_len (so that it's >= the captured
		 * length).
		 */
		pkth.len = sizeof(pcap_usb_header) + info.hdr->data_len;
	} else {
		/*
		 * We got data; base the on-the-wire length on
		 * info.hdr->urb_len, so that it includes data
		 * discarded by the USB monitor device due to
		 * its buffer being too small.
		 */
		pkth.len = sizeof(pcap_usb_header) + info.hdr->urb_len;
	}
	pkth.ts.tv_sec = (time_t)info.hdr->ts_sec;
	pkth.ts.tv_usec = info.hdr->ts_usec;

	if (handle->fcode.bf_insns == NULL ||
	    pcap_filter(handle->fcode.bf_insns, handle->buffer,
	      pkth.len, pkth.caplen)) {
		handlep->packets_read++;
		callback(user, &pkth, handle->buffer);
		return 1;
	}

	return 0;	/* didn't pass filter */
}

```

This is a function that manages theflush of pending events for a specific TCP port using the`pcap`library in Linux.

It works by receiving a packet header and iterating through all the pending packets for the port, flushing them out first before sending them out. It also handles the case where the port's maximum number of packets per time unit is limited.

The function takes apcap\_isochronous\_event结构体指针和hdr结构体作为参数，其中hdr结构体包含发送者和接收者之间的信息。

It starts by initializing variables such aspkth,handle, max\_packets, and callback. It then setspkth.len to the correct size and creates a packet structure for the header.

In the while loop, it iterates through all the pending packets and performs various actions such aslen = sizeof(pcap_usb_header_mmapped) + (hdr->ndesc \* sizeof (usb_isodesc)) + hdr->urb\_len;This is done to create a packet structure that includes the header but does not include the actual data.

It also fixes the buffer if the port is an incoming isochronous transfer, and if it is a completion event for an incoming isochronous transfer, it creates a fixed length packet.

After that, it sets thets.tv\_sec and ts.tv\_usec for the packet, and if handle->fcode.bf\_insns is not NULL, it sends the packet out and increments the callback's packets\_read counter.

If the max\_packets specifies "unlimited", it stops after the first chunk.

Finally, it calls ioctl with theMON\_IOCH\_MFLUSH system call to flush the pending events and returns the number of packets that were successfully flushed.

It is important to note that this code should be added to a自制eticlnet, and the dependencies should be installed.


```cpp
/*
 * see <linux-kernel-source>/Documentation/usb/usbmon.txt and
 * <linux-kernel-source>/drivers/usb/mon/mon_bin.c binary ABI
 */
#define VEC_SIZE 32
static int
usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)
{
	struct pcap_usb_linux *handlep = handle->priv;
	struct mon_bin_mfetch fetch;
	int32_t vec[VEC_SIZE];
	struct pcap_pkthdr pkth;
	u_char *bp;
	pcap_usb_header_mmapped* hdr;
	int nflush = 0;
	int packets = 0;
	u_int clen, max_clen;

	max_clen = handle->snapshot - sizeof(pcap_usb_header_mmapped);

	for (;;) {
		int i, ret;
		int limit;

		if (PACKET_COUNT_IS_UNLIMITED(max_packets)) {
			/*
			 * There's no limit on the number of packets
			 * to process, so try to fetch VEC_SIZE packets.
			 */
			limit = VEC_SIZE;
		} else {
			/*
			 * Try to fetch as many packets as we have left
			 * to process, or VEC_SIZE packets, whichever
			 * is less.
			 *
			 * At this point, max_packets > 0 (otherwise,
			 * PACKET_COUNT_IS_UNLIMITED(max_packets)
			 * would be true) and max_packets > packets
			 * (packet starts out as 0, and the test
			 * at the bottom of the loop exits if
			 * max_packets <= packets), so limit is
			 * guaranteed to be > 0.
			 */
			limit = max_packets - packets;
			if (limit > VEC_SIZE)
				limit = VEC_SIZE;
		}

		/*
		 * Try to fetch as many events as possible, up to
		 * the limit, and flush the events we've processed
		 * earlier (nflush) - MON_IOCX_MFETCH does both
		 * (presumably to reduce the number of system
		 * calls in loops like this).
		 */
		fetch.offvec = vec;
		fetch.nfetch = limit;
		fetch.nflush = nflush;
		/* ignore interrupt system call errors */
		do {
			ret = ioctl(handle->fd, MON_IOCX_MFETCH, &fetch);
			if (handle->break_loop)
			{
				handle->break_loop = 0;
				return -2;
			}
		} while ((ret == -1) && (errno == EINTR));
		if (ret < 0)
		{
			if (errno == EAGAIN)
				return 0;	/* no data there */

			pcap_fmt_errmsg_for_errno(handle->errbuf,
			    PCAP_ERRBUF_SIZE, errno, "Can't mfetch fd %d",
			    handle->fd);
			return -1;
		}

		/* keep track of processed events, we will flush them later */
		nflush = fetch.nfetch;
		for (i=0; i<fetch.nfetch; ++i) {
			/*
			 * XXX - we can't check break_loop here, as
			 * we read the indices of packets into a
			 * local variable, so if we're later called
			 * to fetch more packets, those packets will
			 * not be seen - and won't be flushed, either.
			 *
			 * Instead, we would have to keep the array
			 * of indices in our private data, along
			 * with the count of packets to flush - or
			 * would have to flush the already-processed
			 * packets if we break out of the loop here.
			 */

			/* Get a pointer to this packet's buffer */
			bp = &handlep->mmapbuf[vec[i]];

			/* That begins with a metadata header */
			hdr = (pcap_usb_header_mmapped*) bp;

			/* discard filler */
			if (hdr->event_type == '@')
				continue;

			/*
			 * hdr->data_len is the number of bytes of
			 * isochronous descriptors (if any) plus the
			 * number of bytes of data provided.
			 *
			 * If hdr->data_flag is non-zero, there's no
			 * URB data; hdr->urb_len is the size of the
			 * buffer into which data is to be placed; it does
			 * not represent the amount of data transferred.
			 * If hdr->data_flag is zero, there is URB data,
			 * and hdr->urb_len is the number of bytes
			 * transmitted or received; it doesn't include
			 * isochronous descriptors.
			 *
			 * The kernel may give us more data than the
			 * snaplen; if it did, reduce the data length
			 * so that the total number of bytes we
			 * tell our client we have is not greater than
			 * the snaplen.
			 */
			clen = max_clen;
			if (hdr->data_len < clen)
				clen = hdr->data_len;
			pkth.caplen = sizeof(pcap_usb_header_mmapped) + clen;
			if (hdr->data_flag) {
				/*
				 * No data; just base the on-the-wire length
				 * on hdr->data_len (so that it's >= the
				 * captured length).
				 */
				pkth.len = sizeof(pcap_usb_header_mmapped) +
				    hdr->data_len;
			} else {
				/*
				 * We got data; base the on-the-wire length
				 * on hdr->urb_len, so that it includes
				 * data discarded by the USB monitor device
				 * due to its buffer being too small.
				 */
				pkth.len = sizeof(pcap_usb_header_mmapped) +
				    (hdr->ndesc * sizeof (usb_isodesc)) + hdr->urb_len;

				/*
				 * Now clean it up if it's a completion
				 * event for an incoming isochronous
				 * transfer.
				 */
				fix_linux_usb_mmapped_length(&pkth, bp);
			}
			pkth.ts.tv_sec = (time_t)hdr->ts_sec;
			pkth.ts.tv_usec = hdr->ts_usec;

			if (handle->fcode.bf_insns == NULL ||
			    pcap_filter(handle->fcode.bf_insns, (u_char*) hdr,
			      pkth.len, pkth.caplen)) {
				handlep->packets_read++;
				callback(user, &pkth, (u_char*) hdr);
				packets++;
			}
		}

		/*
		 * If max_packets specifiesg "unlimited", we stop after
		 * the first chunk.
		 */
		if (PACKET_COUNT_IS_UNLIMITED(max_packets) ||
		    (packets >= max_packets))
			break;
	}

	/* flush pending events*/
	if (ioctl(handle->fd, MON_IOCH_MFLUSH, nflush) == -1) {
		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
		    errno, "Can't mflush fd %d", handle->fd);
		return -1;
	}
	return packets;
}

```

这段代码是一个用于清理 Linux 系统上使用 libusb 库的 pcap 数据包的函数。libusb 是用于创建 Linux 系统上的 USB 设备和驱动程序的库，因此，这段代码可能会被用于清理使用它的数据包。

具体来说，这段代码会先检查给定的 pcap 数据包是否与 USB 相关，如果是，就执行一些额外的清理操作。首先，它会检查给定的 handle 是否指向一个已经创建好的 pcap 数据包，如果是，就执行一些额外的清理操作。然后，它会检查给定的 handle 所指向的 pcap 数据包中是否有一个与 USB 相关的内存映射，如果是，就会卸载它并将其设置为 NULL。最后，它会调用 pcap_cleanup_live_common 函数来清理数据的链路。


```cpp
static void
usb_cleanup_linux_mmap(pcap_t* handle)
{
	struct pcap_usb_linux *handlep = handle->priv;

	/* if we have a memory-mapped buffer, unmap it */
	if (handlep->mmapbuf != NULL) {
		munmap(handlep->mmapbuf, handlep->mmapbuflen);
		handlep->mmapbuf = NULL;
	}
	pcap_cleanup_live_common(handle);
}

```