# xmrig源码解析 37

# `src/3rdparty/hwloc/src/topology-windows.c`

这段代码是一个定义宏，名为`_WIN32_WINNT`，值为0x0601。它定义了该宏的名称，并为该宏定义了相应的常量。

接下来是几个头文件和函数的包含：

* "private/autogen/config.h"：可能是用于自动生成的配置文件中的头文件。
* "hwloc.h"：可能是用于管理硬件资源和定位硬件设备的头文件。
* "hwloc/windows.h"：可能是用于在Windows上使用硬件定位技术的头文件。
* "private/private.h"：可能是用于定义宏、常量和其他配置的头部文件。

然后是定义了一些变量：

* "autogenerated"：定义了一个名为"autogenerated"的常量，但没有定义该常量的值。
* "config"：定义了一个名为"config"的常量，但没有定义该常量的值。
* "file"：定义了一个名为"file"的常量，但没有定义该常量的值。
* "level"：定义了一个名为"level"的常量，但没有定义该常量的值。
* "win_size"：定义了一个名为"win_size"的常量，但没有定义该常量的值。
* "padding"：定义了一个名为"padding"的常量，但没有定义该常量的值。

最后是一些函数的定义：

* "get_host_name"：从给定的设备中获取主机名称的函数。
* "set_lidar_mode"：设置给定设备中LIDAR模式的函数。
* "set_device_mode"：设置给定设备中设备模式的函数。
* "set_forward_only_mode"：设置给定设备中是否启用转发模式函数。
* "set_security_mode"：设置给定设备中安全模式的函数。
* "set_awake_mode"：设置给定设备中是否唤醒模式的函数。


```cpp
/*
 * Copyright © 2009 CNRS
 * Copyright © 2009-2022 Inria.  All rights reserved.
 * Copyright © 2009-2012, 2020 Université Bordeaux
 * Copyright © 2011 Cisco Systems, Inc.  All rights reserved.
 * See COPYING in top-level directory.
 */

/* To try to get all declarations duplicated below.  */
#define _WIN32_WINNT 0x0601

#include "private/autogen/config.h"
#include "hwloc.h"
#include "hwloc/windows.h"
#include "private/private.h"
```

这段代码包括两个头文件和三个定义。首先，它通过包含"private/windows.h"和"private/debug.h"来引入这两个头文件的内容。然后，它通过包含"windows.h"来引入标准库头文件中的"windows.h"。

接下来，它通过包含"kaffininity.h"来引入一个名为"KAFFINITY"的定义，并将其定义为"ULONG_PTR"类型。这意味着"KAFFINITY"可以是一个无符号长整型或一个指向这样的类型的指针。

然后，它通过包含"processor_cache_type.h"来引入一个名为"PROCESSOR_CACHE_TYPE"的定义，该定义定义了三种处理器缓存类型：缓存统一、指令缓存和数据缓存。

最后，它通过包含三个定义来给三个变量赋值。第一个定义将"HAVE_KAFFINITY"赋值为真(即1)，第二个定义将"HAVE_PROCESSOR_CACHE_TYPE"赋值为某个名为"PROCESSOR_CACHE_TYPE"的常量，第三个定义将"PROCESSOR_CACHE_TYPE"的常量值指定为"CacheInstruction"。


```cpp
#include "private/windows.h" /* must be before windows.h */
#include "private/debug.h"

#include <windows.h>

#ifndef HAVE_KAFFINITY
typedef ULONG_PTR KAFFINITY, *PKAFFINITY;
#endif

#ifndef HAVE_PROCESSOR_CACHE_TYPE
typedef enum _PROCESSOR_CACHE_TYPE {
  CacheUnified,
  CacheInstruction,
  CacheData,
  CacheTrace
} PROCESSOR_CACHE_TYPE;
```

这段代码定义了一个名为“CACHE_FULLY_ASSOCIATIVE”的常量，其值为0xFF。它还定义了一个名为“MAXIMUM_PROC_PER_GROUP”的常量，其值为64，如果没有定义，则默认为64。

接下来，它定义了一个名为“HAVE_CACHE_DESCRIPTOR”的类型，该类型定义了一个名为“CACHE_DESCRIPTOR”的结构体，其中包含以下成员：

- Level：当前缓存级别
- Associativity：缓存颗粒的级联模式
- LineSize：缓存行的大小，以字节为单位
- Size：缓存颗粒的总大小，以字节为单位
- Type：缓存颗粒的类型，如0表示内部缓存，1表示外部缓存

最后，它定义了一个名为“PCACHE_DESCRIPTOR”的指向“CACHE_DESCRIPTOR”类型的指针，用于将“HAVE_CACHE_DESCRIPTOR”类型的值传递给函数。


```cpp
#endif

#ifndef CACHE_FULLY_ASSOCIATIVE
#define CACHE_FULLY_ASSOCIATIVE 0xFF
#endif

#ifndef MAXIMUM_PROC_PER_GROUP /* missing in MinGW */
#define MAXIMUM_PROC_PER_GROUP 64
#endif

#ifndef HAVE_CACHE_DESCRIPTOR
typedef struct _CACHE_DESCRIPTOR {
  BYTE Level;
  BYTE Associativity;
  WORD LineSize;
  DWORD Size; /* in bytes */
  PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;
```

这段代码定义了一个名为LOGICAL_PROCESSOR_RELATIONSHIP的结构体，用于指定与逻辑处理器相关的不同组件或包。

在代码中，首先定义了一个名为“#endif”的声明，表示这是一个无条件编译预处理指令，将在编译时如果LOGICAL_PROCESSOR_RELATIONSHIP被定义为有效值时被编译。如果LOGICAL_PROCESSOR_RELATIONSHIP为无效值(即未被定义或未定义为任何特定的值)，则编译器将不会产生任何错误。

接下来定义了一个名为“#ifndef”的声明，表示逻辑处理器与相关组件或包的定义开始。在接下来的代码中，通过使用“typedef”定义了一个名为“RelationProcessorCore”的枚举类型，用于指定逻辑处理器的核心组件。然后，通过使用“RelationNumaNode”枚举类型，定义了逻辑处理器与Numai节点的相关组件。

接着，定义了一个名为“RelationCache”的枚举类型，用于指定逻辑处理器与高速缓存的关联。然后，定义了一个名为“RelationProcessorPackage”的枚举类型，用于指定逻辑处理器与软件包的关联。最后，定义了一个名为“RelationGroup”的枚举类型，用于指定逻辑处理器与分组或部署的关联。

最后，通过使用“RelationAll”枚举类型，定义了LOGICAL_PROCESSOR_RELATIONSHIP的最大值为0xffff，表示所有未定义的值。


```cpp
#endif

#ifndef HAVE_LOGICAL_PROCESSOR_RELATIONSHIP
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
  RelationProcessorCore,
  RelationNumaNode,
  RelationCache,
  RelationProcessorPackage,
  RelationGroup,
  RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;
#else /* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */
#  ifndef HAVE_RELATIONPROCESSORPACKAGE
#    define RelationProcessorPackage 3
#    define RelationGroup 4
```

这段代码定义了一些结构体和宏，其中包含了一个名为RelationAll的定义，这个定义表示所有可以使用的特权，宏定义中包含了一个if分支，如果该分支为真，则执行后续代码。

如果满足HAVE_LOGICAL_PROCESSOR_RELATIONSHIP定义，则定义了一个GROUP_AFFINITY结构体，其中包含一个KAFFINITY类型的成员Mask，一个表示GROUP的成员Group，以及一个表示RESERVED的成员Array[3]。

如果尚未满足HAVE_GROUP_AFFINITY定义，则定义了一个HWLOC_PROCESSOR_RELATIONSHIP结构体，其中包含一个BYTE类型的成员Flags，一个表示EfficiencyClass的成员，一个表示RESERVED的成员Array[20]，一个表示GROUP_COUNT的成员，以及一个表示GROUP_MASK的成员Array[ANYSIZE_ARRAY]。

然后定义了一个名为__relationprocessor_relationship_的宏，该宏定义了RelationAll的值，为0xffff。

最后定义了一个名为__logical_processor_relationship_的宏，该宏定义了逻辑处理器与关系处理器之间的关系。


```cpp
#    define RelationAll 0xffff
#  endif /* HAVE_RELATIONPROCESSORPACKAGE */
#endif /* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */

#ifndef HAVE_GROUP_AFFINITY
typedef struct _GROUP_AFFINITY {
  KAFFINITY Mask;
  WORD Group;
  WORD Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;
#endif

/* always use our own structure because the EfficiencyClass field didn't exist before Win10 */
typedef struct HWLOC_PROCESSOR_RELATIONSHIP {
  BYTE Flags;
  BYTE EfficiencyClass; /* for RelationProcessorCore, higher means greater performance but less efficiency */
  BYTE Reserved[20];
  WORD GroupCount;
  GROUP_AFFINITY GroupMask[ANYSIZE_ARRAY];
} HWLOC_PROCESSOR_RELATIONSHIP;

```

这段代码定义了两个结构体：HWLOC_NUMA_NODE_RELATIONSHIP和HWLOC_CACHE_RELATIONSHIP。它们都包含用于描述硬件内存区域的信息。

HWLOC_NUMA_NODE_RELATIONSHIP结构体包含以下字段：

- NodeNumber：硬件内存区域的节点编号。
- Reserved：保留字段，用于在不同定义中保留。
- GroupCount：与NodeNumber相关的群组数量。
- GroupMask：用于指定属于GroupCount的群组的内存区域。

HWLOC_CACHE_RELATIONSHIP结构体包含以下字段：

- Level：缓存层次结构中的缓存级别。
- Associativity：缓存层次结构中缓存单元位的对齐模式，它定义了缓存单元位的放置策略。
- LineSize：缓存行的大小，单位为字节。
- CacheSize：缓存的大小，单位为字节。
- Type：缓存的类型，可以是高速缓存或非高速缓存。
- Reserved：保留字段，用于在不同定义中保留。
- GroupCount：与Level相关的群组数量。
- GroupMask：用于指定属于GroupCount的群组的内存区域。

这两个结构体都用于描述硬件内存区域，并定义了如何使用它们。


```cpp
/* always use our own structure because the GroupCount and GroupMasks fields didn't exist in some Win10 */
typedef struct HWLOC_NUMA_NODE_RELATIONSHIP {
  DWORD NodeNumber;
  BYTE Reserved[18];
  WORD GroupCount;
  _ANONYMOUS_UNION
  union {
    GROUP_AFFINITY GroupMask;
    GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
  } DUMMYUNIONNAME;
} HWLOC_NUMA_NODE_RELATIONSHIP;

typedef struct HWLOC_CACHE_RELATIONSHIP {
  BYTE Level;
  BYTE Associativity;
  WORD LineSize;
  DWORD CacheSize;
  PROCESSOR_CACHE_TYPE Type;
  BYTE Reserved[18];
  WORD GroupCount;
  union {
    GROUP_AFFINITY GroupMask;
    GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
  } DUMMYUNIONNAME;
} HWLOC_CACHE_RELATIONSHIP;

```

这段代码定义了一个名为“PROCESSOR_GROUP_INFO”的结构体，用于表示处理器组的信息。这个结构体有四个字段：最大处理器数（MaximumProcessorCount）、活动处理器数（ActiveProcessorCount）、保留字段（Reserved）和激活处理器掩码（ActiveProcessorMask）。

接下来定义了一个名为“GROUP_RELATIONSHIP”的结构体，用于表示组与组之间的关系。这个结构体有四个字段：最大组数（MaximumGroupCount）、活动组数（ActiveGroupCount）、保留字段（Reserved）和组信息数组大小（GroupInfoSize）。

通过这些结构体，可以实现对处理器组和组之间的关系进行描述和操作。例如，可以在GROUP_RELATIONSHIP结构体中查找有关当前组的成员，也可以在PROCESSOR_GROUP_INFO结构体中设置活动处理器数量。


```cpp
#ifndef HAVE_PROCESSOR_GROUP_INFO
typedef struct _PROCESSOR_GROUP_INFO {
  BYTE MaximumProcessorCount;
  BYTE ActiveProcessorCount;
  BYTE Reserved[38];
  KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
#endif

#ifndef HAVE_GROUP_RELATIONSHIP
typedef struct _GROUP_RELATIONSHIP {
  WORD MaximumGroupCount;
  WORD ActiveGroupCount;
  ULONGLONG Reserved[2];
  PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;
```

这段代码定义了一个名为`HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX`的结构体，其中包含以下成员：

1. `Relationship`：逻辑处理器与主机的物理关系，可以是`LOGICAL_PROCESSOR_RELATIONSHIP`、`HWLOC_PROCESSOR_RELATIONSHIP`、`HWLOC_NUMA_NODE_RELATIONSHIP`、`HWLOC_CACHE_RELATIONSHIP`或`GROUP_RELATIONSHIP`。

2. `Size`：与`Relationship`相关的数据类型的大小。

3. `AnonymousArray`：通过`_ANONYMOUS_UNION`定义的匿名联合类型，可以在需要时使用。

4. `Processor`：与逻辑处理器相关的成员。

5. `NumaNode`：与NUMA节点相关的成员。

6. `Cache`：与缓存相关的成员。

7. `Group`：与组相关的成员。

8. `DUMMYUNIONNAME`：一个特殊的成员，用于告诉CPU该结构体属于哪个命名空间。该成员将在编译时生成，因此其值不会影响程序的运行。

该结构体通常用于在操作系统或硬件提供的逻辑处理器、缓存和NUMA节点等信息中记录相关元数据。


```cpp
#endif

/* always use our own structure because we need our own HWLOC_PROCESSOR/CACHE/NUMA_NODE_RELATIONSHIP */
typedef struct HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
  LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
  DWORD Size;
  _ANONYMOUS_UNION
  union {
    HWLOC_PROCESSOR_RELATIONSHIP Processor;
    HWLOC_NUMA_NODE_RELATIONSHIP NumaNode;
    HWLOC_CACHE_RELATIONSHIP Cache;
    GROUP_RELATIONSHIP Group;
    /* Odd: no member to tell the cpu mask of the package... */
  } DUMMYUNIONNAME;
} HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

```

这段代码定义了一个名为PSAPI_WORKING_SET_EX_BLOCK的联合体结构体，用于表示进程执行上下文信息中的工作集。这个结构体定义了一些标志位，表示是否启用了工作集，以及工作集的特定属性。

具体来说，这个结构体定义了以下标志位：

- Flags字段：表示工作集是否启用，它的值为0表示不启用，值为1表示启用。
- Valid字段：表示是否可以分配资源，它的值为0表示不可以，值为1表示可以。
- ShareCount字段：表示工作集可以分配的最大份额，它的值为0表示不限制，值为1表示工作集可以分配任何份额。
- Win32Protection字段：表示是否禁止修改，它的值为0表示可以，值为1表示禁止。
- Shared字段：表示工作集是否可共享，它的值为0表示不共享，值为1表示可以共享。
- Node字段：表示是否支持NUMA，它的值为0表示不支持，值为1表示支持。
- Locked字段：表示是否被锁定，它的值为0表示没有被锁定，值为1表示已经被锁定。
- LargePage字段：表示是否启用大页分配，它的值为0表示不启用，值为1表示启用。

这个结构体的定义在#ifdef之间，因此只有在包含这个头文件的情况下，它才会被定义。


```cpp
#ifndef HAVE_PSAPI_WORKING_SET_EX_BLOCK
typedef union _PSAPI_WORKING_SET_EX_BLOCK {
  ULONG_PTR Flags;
  struct {
    unsigned Valid  :1;
    unsigned ShareCount  :3;
    unsigned Win32Protection  :11;
    unsigned Shared  :1;
    unsigned Node  :6;
    unsigned Locked  :1;
    unsigned LargePage  :1;
  };
} PSAPI_WORKING_SET_EX_BLOCK;
#endif

```

这段代码定义了一个名为PSAPI_WORKING_SET_EX_INFORMATION的结构体类型，以及一个名为PROCESSOR_NUMBER的结构体类型。

PSAPI_WORKING_SET_EX_INFORMATION结构体包含两个成员变量：虚拟地址和虚拟属性。

PROCESSOR_NUMBER结构体包含三个成员变量：组别、数字和保留字段，以及一个名为PROCESSOR_NUMBER的结构体类型的指针。

这个代码定义了两个结构体类型，PSAPI_WORKING_SET_EX_INFORMATION和PROCESSOR_NUMBER。PSAPI_WORKING_SET_EX_INFORMATION结构体中的虚拟地址和虚拟属性可能是在系统上分配的虚拟内存，而PROCESSOR_NUMBER结构体则用于表示CPU的当前组别和当前数字。


```cpp
#ifndef HAVE_PSAPI_WORKING_SET_EX_INFORMATION
typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
  PVOID VirtualAddress;
  PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
} PSAPI_WORKING_SET_EX_INFORMATION;
#endif

#ifndef HAVE_PROCESSOR_NUMBER
typedef struct _PROCESSOR_NUMBER {
  WORD Group;
  BYTE Number;
  BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
#endif

```

这段代码定义了三个函数指针类型变量，分别代表获取当前处理器组、当前处理器数量和当前处理器编号的函数。

GetActiveProcessorGroupCountProc函数指针变量，代表获取当前处理器组数的函数，其参数为空，返回值为当前处理器组数。

GetActiveProcessorCountProc函数指针变量，代表获取当前处理器数量的函数，其参数为某个整数，返回值为当前处理器数量。

GetCurrentProcessorNumberProc函数指针变量，代表获取当前处理器编号的函数，其参数为空，返回值为当前处理器编号。

GetCurrentProcessorNumberExProc函数指针变量，代表获取当前处理器编号的Ex版函数，其参数为某个整数，返回值为当前处理器编号的Ex版形式。

GetLogicalProcessorInformationEX函数指针变量，代表获取当前逻辑处理器信息的函数，其参数为当前处理器关系和缓冲区指针，返回值为当前逻辑处理器信息。


```cpp
/* Function pointers */

typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORGROUPCOUNT)(void);
static PFN_GETACTIVEPROCESSORGROUPCOUNT GetActiveProcessorGroupCountProc;

typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORCOUNT)(WORD);
static PFN_GETACTIVEPROCESSORCOUNT GetActiveProcessorCountProc;

typedef DWORD (WINAPI *PFN_GETCURRENTPROCESSORNUMBER)(void);
static PFN_GETCURRENTPROCESSORNUMBER GetCurrentProcessorNumberProc;

typedef VOID (WINAPI *PFN_GETCURRENTPROCESSORNUMBEREX)(PPROCESSOR_NUMBER);
static PFN_GETCURRENTPROCESSORNUMBEREX GetCurrentProcessorNumberExProc;

typedef BOOL (WINAPI *PFN_GETLOGICALPROCESSORINFORMATIONEX)(LOGICAL_PROCESSOR_RELATIONSHIP relationship, HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *Buffer, PDWORD ReturnLength);
```

这段代码定义了几个函数指针类型变量，用于不同操作系统版本的Windows。

PFN_GETLOGICALPROCESSORINFORMATIONEX GetLogicalProcessorInformationExProc是一个函数指针，指向一个BOOL类型的函数，用于获取逻辑处理器信息。

PFN_SETTHREADGROUPAFFINITY SetThreadGroupAffinityProc是一个函数指针，指向一个BOOL类型的函数，用于设置线程组 Affinity，即将特定的组 Affinity 应用到指定的线程上。

PFN_GETTHREADGROUPAFFINITY GetThreadGroupAffinityProc是一个函数指针，指向一个BOOL类型的函数，用于获取线程组 Affinity，即将指定的组 Affinity 应用到线程上。

PFN_GETNUMAAVAILABLEMEMORYNODE GetNumaAvailableMemoryNodeProc是一个函数指针，指向一个BOOL类型的函数，用于获取可用内存中的偏移量，用于指定哪些内存区域在系统缺省情况下仍然可用。

PFN_GETNUMAAVAILABLEMEMORYNODEEX GetNumaAvailableMemoryNodeExProc是一个函数指针，指向一个BOOL类型的函数，用于获取可用内存中的偏移量，并返回一个枚举类型，以表示内存区域的类型。

PFN_VIRTUALALLOCEXNUMA是一个函数指针，指向一个BOOL类型的函数，用于在系统缺省情况下虚拟分配内存。


```cpp
static PFN_GETLOGICALPROCESSORINFORMATIONEX GetLogicalProcessorInformationExProc;

typedef BOOL (WINAPI *PFN_SETTHREADGROUPAFFINITY)(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity);
static PFN_SETTHREADGROUPAFFINITY SetThreadGroupAffinityProc;

typedef BOOL (WINAPI *PFN_GETTHREADGROUPAFFINITY)(HANDLE hThread, PGROUP_AFFINITY GroupAffinity);
static PFN_GETTHREADGROUPAFFINITY GetThreadGroupAffinityProc;

typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODE)(UCHAR Node, PULONGLONG AvailableBytes);
static PFN_GETNUMAAVAILABLEMEMORYNODE GetNumaAvailableMemoryNodeProc;

typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODEEX)(USHORT Node, PULONGLONG AvailableBytes);
static PFN_GETNUMAAVAILABLEMEMORYNODEEX GetNumaAvailableMemoryNodeExProc;

typedef LPVOID (WINAPI *PFN_VIRTUALALLOCEXNUMA)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
```

这段代码定义了一些函数指针变量，包括：

1. `VirtualAllocExNumaProc`：指向`VirtualAllocExNumaProc`函数的指针。`VirtualAllocExNumaProc`是一个窗口虚拟分配内存的函数。

2. `VirtualFreeExProc`：指向`VirtualFreeExProc`函数的指针。`VirtualFreeExProc`是一个窗口虚拟释放内存的函数。

3. `QueryWorkingSetExProc`：指向`QueryWorkingSetExProc`函数的指针。`QueryWorkingSetExProc`是一个窗口查询工作区范围的函数。

4. `RtlGetVersionProc`：指向`RtlGetVersionProc`函数的指针。`RtlGetVersionProc`是一个获取操作系统版本的函数。

5. `hwloc_win_get_function_ptrs`：是一个辅助函数，用于获取与该代码相关的函数指针。

这些函数指针变量将在程序运行时被用于调用它们的相应函数。


```cpp
static PFN_VIRTUALALLOCEXNUMA VirtualAllocExNumaProc;

typedef BOOL (WINAPI *PFN_VIRTUALFREEEX)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
static PFN_VIRTUALFREEEX VirtualFreeExProc;

typedef BOOL (WINAPI *PFN_QUERYWORKINGSETEX)(HANDLE hProcess, PVOID pv, DWORD cb);
static PFN_QUERYWORKINGSETEX QueryWorkingSetExProc;

typedef NTSTATUS (WINAPI *PFN_RTLGETVERSION)(OSVERSIONINFOEX*);
PFN_RTLGETVERSION RtlGetVersionProc;

static void hwloc_win_get_function_ptrs(void)
{
  HMODULE kernel32, ntdll;

```

This code appears to be setting up a Windows kernel P/Invoke implementation for retrieving information about the system. It does this by querying various system functions and using the corresponding functions from the kernel32 library.

The code first sets up a pointer to a function table, which will be used to look up the addresses of functions that implement the various system functions that it needs to retrieve. It does this by calling the `GetProcAddress` function of the `kernel32` library, passing the appropriate function name as a parameter.

The code then sets up pointers to the functions that it needs to call to retrieve information about the system. These functions include `GetThreadGroupAffinity`, `GetNumaAvailableMemoryNode`, `GetNumaAvailableMemoryNodeEx`, `GetLogicalProcessorInformationEx`, `GetWorkingSetEx`, and `RtlGetVersion`.

The code also creates a pointer to a function table, which is similar to the one that it previously set up. It creates this table by calling the `GetModuleHandle` function of the `ntdll` library, passing the name of the `ntdll` module as a parameter.

The code then uses the `RtlGetVersion` function to retrieve the version of the Windows kernel that the system is running.

Overall, the code sets up a system-level货架， allowing it to retrieve information about the system and perform various tasks.


```cpp
#if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
#pragma GCC diagnostic ignored "-Wcast-function-type"
#endif

    kernel32 = LoadLibrary("kernel32.dll");
    if (kernel32) {
      GetActiveProcessorGroupCountProc =
	(PFN_GETACTIVEPROCESSORGROUPCOUNT) GetProcAddress(kernel32, "GetActiveProcessorGroupCount");
      GetActiveProcessorCountProc =
	(PFN_GETACTIVEPROCESSORCOUNT) GetProcAddress(kernel32, "GetActiveProcessorCount");
      GetCurrentProcessorNumberProc =
	(PFN_GETCURRENTPROCESSORNUMBER) GetProcAddress(kernel32, "GetCurrentProcessorNumber");
      GetCurrentProcessorNumberExProc =
	(PFN_GETCURRENTPROCESSORNUMBEREX) GetProcAddress(kernel32, "GetCurrentProcessorNumberEx");
      SetThreadGroupAffinityProc =
	(PFN_SETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "SetThreadGroupAffinity");
      GetThreadGroupAffinityProc =
	(PFN_GETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "GetThreadGroupAffinity");
      GetNumaAvailableMemoryNodeProc =
	(PFN_GETNUMAAVAILABLEMEMORYNODE) GetProcAddress(kernel32, "GetNumaAvailableMemoryNode");
      GetNumaAvailableMemoryNodeExProc =
	(PFN_GETNUMAAVAILABLEMEMORYNODEEX) GetProcAddress(kernel32, "GetNumaAvailableMemoryNodeEx");
      GetLogicalProcessorInformationExProc =
	(PFN_GETLOGICALPROCESSORINFORMATIONEX)GetProcAddress(kernel32, "GetLogicalProcessorInformationEx");
      QueryWorkingSetExProc =
	(PFN_QUERYWORKINGSETEX) GetProcAddress(kernel32, "K32QueryWorkingSetEx");
      VirtualAllocExNumaProc =
	(PFN_VIRTUALALLOCEXNUMA) GetProcAddress(kernel32, "VirtualAllocExNuma");
      VirtualFreeExProc =
	(PFN_VIRTUALFREEEX) GetProcAddress(kernel32, "VirtualFreeEx");
    }

    if (!QueryWorkingSetExProc) {
      HMODULE psapi = LoadLibrary("psapi.dll");
      if (psapi)
        QueryWorkingSetExProc = (PFN_QUERYWORKINGSETEX) GetProcAddress(psapi, "QueryWorkingSetEx");
    }

    ntdll = GetModuleHandle("ntdll");
    RtlGetVersionProc = (PFN_RTLGETVERSION) GetProcAddress(ntdll, "RtlGetVersion");

```

这段代码的作用是定义了一个名为hwloc_bitmap_from_ulong_p颠覆平铺位图的函数，该函数接受一个hwloc_bitmap_t类型的被设置位图和一個ULONG_PTR类型的掩码，然后根据SIZEOF_VOID_P宏的值来选择是否使用64位或者32位数据结构。

如果SIZEOF_VOID_P是8，那么函数将使用64位数据结构，否则将使用32位数据结构。函数首先从被设置位图中读取掩码的低32位，然后将其与掩码进行与运算，得到一个新的掩码，这个掩码将用于设置被设置位图的32位和高位。最后，函数将这个新的掩码设置为从被设置位图的左到右扫描距离为32位的偏移量，这样，新的被设置位图将覆盖原有的被设置位图。


```cpp
#if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
#pragma GCC diagnostic warning "-Wcast-function-type"
#endif
}

/*
 * ULONG_PTR and DWORD_PTR are 64/32bits depending on the arch
 * while bitmaps use unsigned long (always 32bits)
 */

static void hwloc_bitmap_from_ULONG_PTR(hwloc_bitmap_t set, ULONG_PTR mask)
{
#if SIZEOF_VOID_P == 8
  hwloc_bitmap_from_ulong(set, mask & 0xffffffff);
  hwloc_bitmap_set_ith_ulong(set, 1, mask >> 32);
```

这段代码定义了两种情况下的函数 `hwloc_bitmap_from_ith_ulong`，用于从输入掩码中获取高度集中使用单元格的服务器区域（`set` 表示目标服务器区域，`mask` 表示输入掩码）。根据输入掩码的类型，代码会采用不同的实现方式：

1. 如果 `SIZEOF_VOID_P == 8`，即 `sizeof(void_ptr) == 8`，那么函数实现会将输入掩码与 `0xffffffff` 进行与运算，并从高字节开始输出每个服务器单元格。
2. 如果 `SIZEOF_VOID_P != 8`，即 `sizeof(void_ptr) != 8`，那么函数实现会将输入掩码与 `0` 进行与运算，并从低字节开始输出每个服务器单元格。

具体来说，如果 `mask` 是一个 `unsigned long`，则 `hwloc_bitmap_from_ulong` 和 `hwloc_bitmap_from_ith_ulong` 函数会向 `set` 输出一个与输入掩码相同的 `hwloc_bitmap_t`，每个服务器单元格的宽度和高字节根据输入掩码的与运算类型不同而不同。


```cpp
#else
  hwloc_bitmap_from_ulong(set, mask);
#endif
}

static void hwloc_bitmap_from_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
{
#if SIZEOF_VOID_P == 8
  hwloc_bitmap_from_ith_ulong(set, 2*i, mask & 0xffffffff);
  hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
#else
  hwloc_bitmap_from_ith_ulong(set, i, mask);
#endif
}

```



该代码定义了一个名为 `hwloc_bitmap_set_ith_ulong_p` 的函数，用于设置一个 `hwloc_bitmap_t` 类型的对象中的某个偏移位置的 `ULONG_PTR` 类型的值，其中偏移位置从 0 开始计数。

函数的实现包括以下几个步骤：

1. 如果 `set` 对象是一个 `hwloc_const_bitmap_t` 类型的对象，并且 `SIZEOF_VOID_P` 宏等于 8，那么先执行以下代码：

  ```cpp
  hwloc_bitmap_set_ith_ulong(set, 2*i, mask & 0xffffffff);
  hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
  ```

  这两行代码将 `set` 对象中的偏移量为 `i` 的位置和低 8 位二进制位清零，然后将偏移量为 `i` 的位置和高压 8 位二进制位设置为给定 `mask` 的值，其中 `mask` 是 `ULONG_PTR` 类型的一个掩码，表示只读或只写通过。

2. 如果 `set` 对象是一个 `hwloc_const_bitmap_t` 类型的对象，并且 `SIZEOF_VOID_P` 宏不等于 8，那么执行以下代码：

  ```cpp
  hwloc_bitmap_set_ith_ulong(set, i, mask);
  ```

  这一行代码将 `set` 对象中的偏移量为 `i` 的位置设置为给定 `mask` 的值，并将高位设置为 0，低位设置为 `~mask`(即对 `mask` 取反)，得到一个只读的 `hwloc_bitmap_t` 对象。

3. 返回 `set` 对象，这样就可以在以后调用函数时使用它了。

该函数的作用是，通过设置 `set` 对象中偏移量为指定 `mask` 的位置的 `ULONG_PTR` 类型的值，来修改 `set` 对象中指定位置的显示值。不过，由于 `mask` 可能是一个有符号或无符号的 `ULONG_PTR`，因此需要根据 `SIZEOF_VOID_P` 宏的值来选择正确的实现方式。如果 `SIZEOF_VOID_P` 宏等于 8，则需要将 `mask` 强制转换为无符号整数类型，否则需要将 `mask` 的符号位清零。


```cpp
static void hwloc_bitmap_set_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
{
#if SIZEOF_VOID_P == 8
  hwloc_bitmap_set_ith_ulong(set, 2*i, mask & 0xffffffff);
  hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
#else
  hwloc_bitmap_set_ith_ulong(set, i, mask);
#endif
}

static ULONG_PTR hwloc_bitmap_to_ULONG_PTR(hwloc_const_bitmap_t set)
{
#if SIZEOF_VOID_P == 8
  ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 1);
  up <<= 32;
  up |= hwloc_bitmap_to_ulong(set);
  return up;
```

这段代码是一个C语言中的函数，定义了两个名为`hwloc_bitmap_to_ulong`和`hwloc_bitmap_to_ith_ulong`的函数，以及一个名为`hwloc_const_bitmap_t`的定义。它们的作用如下：

1. `hwloc_bitmap_to_ulong`函数：该函数接收一个`hwloc_const_bitmap_t`类型的参数`set`和一个整数`i`，然后将其转换为一个无符号整数并返回。

2. `hwloc_bitmap_to_ith_ulong`函数：该函数与`hwloc_bitmap_to_ulong`函数类似，但仅接收一个`hwloc_const_bitmap_t`类型的参数`set`和一个整数`i`，然后将其转换为一个无符号整数。

3. `hwloc_const_bitmap_t`定义：该定义定义了一个名为`hwloc_const_bitmap_t`的类型，用于表示输入参数`set`的类型。

4. `hwloc_bitmap_to_ulong`函数的实现：在函数体中，首先通过`set`的索引`2*i+1`获取一个2位的子掩，然后将其与`set`的索引`2*i`合并为一个3位的掩。最后，将掩作为参数传递给`hwloc_bitmap_to_ulong`函数，得到一个无符号整数类型的结果。

5. `hwloc_bitmap_to_ith_ulong`函数的实现：与`hwloc_bitmap_to_ulong`函数类似，但仅使用了一个无符号整数类型的变量`up`来表示结果。然后，将`up`向左移动32位，再将`set`的索引`2*i`和子掩`2*i+1`作为参数传递给`hwloc_bitmap_to_ulong`函数，得到一个无符号整数类型的结果。


```cpp
#else
  return hwloc_bitmap_to_ulong(set);
#endif
}

static ULONG_PTR hwloc_bitmap_to_ith_ULONG_PTR(hwloc_const_bitmap_t set, unsigned i)
{
#if SIZEOF_VOID_P == 8
  ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 2*i+1);
  up <<= 32;
  up |= hwloc_bitmap_to_ith_ulong(set, 2*i);
  return up;
#else
  return hwloc_bitmap_to_ith_ulong(set, i);
#endif
}

```

这段代码的作用是实现将 `hwloc_const_bitmap_t` 类型的设置转换为 `unsigned` 类型的索引加上 `ULONG_PTR` 类型的掩码。具体来说，如果设置中所有的位都是相同的话，函数将返回一个指向 `ULONG_PTR` 类型的指针，表示索引为 `first_ulf` 的位置，同时将 `mask` 参数设置为 `hwloc_bitmap_to_ith_ULONG_PTR(set, first_ulf)`。否则，函数将返回 `-1`，表明没有找到有效的索引。

函数的实现基于 `hwloc_bitmap_weight` 函数和 `hwloc_bitmap_first` 函数，其中 `hwloc_bitmap_weight` 函数用于计算设置中所有位的重量(即位数目),`hwloc_bitmap_first` 函数用于返回设置中所有位的第一个位置(即索引)。


```cpp
/* convert set into index+mask if all set bits are in the same ULONG.
 * otherwise return -1.
 */
static int hwloc_bitmap_to_single_ULONG_PTR(hwloc_const_bitmap_t set, unsigned *index, ULONG_PTR *mask)
{
  unsigned first_ulp, last_ulp;
  if (hwloc_bitmap_weight(set) == -1)
    return -1;
  first_ulp = hwloc_bitmap_first(set) / (sizeof(ULONG_PTR)*8);
  last_ulp = hwloc_bitmap_last(set) / (sizeof(ULONG_PTR)*8);
  if (first_ulp != last_ulp)
    return -1;
  *mask = hwloc_bitmap_to_ith_ULONG_PTR(set, first_ulp);
  *index = first_ulp;
  return 0;
}

```

这段代码的作用是设置可用的CPU集合，以便给定的进程组。它将可用的CPU列表存储在一个位图数组中，并将其分配给进程组。以下是一些注释：

1. 首先，定义了一个名为 `id` 的整数变量，用于标识要设置的进程组。
2. 然后，定义了一个 `KAFFINITY` 类型的变量 `mask`，用于存储进程组的掩码。
3. 接下来，定义了一个 `hwloc_bitmap_t` 类型的变量 `set`，用于存储进程组的位图数组。
4. 对于每个进程组，设置 `set` 位图的索引为 `id`，并将进程组中所有 CPU 设置为 `mask`。
5. 最后，使用 `hwloc_debug` 函数打印一些信息，用于调试目的。

总之，这段代码的主要目的是设置一组进程组的可用 CPU，以便给定的进程组。


```cpp
/**********************
 * Processor Groups
 */

static unsigned long max_numanode_index = 0;

static unsigned long nr_processor_groups = 1;
static hwloc_cpuset_t * processor_group_cpusets = NULL;

static void
hwloc_win_get_processor_groups(void)
{
  HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
  DWORD length;
  unsigned i;

  hwloc_debug("querying windows processor groups\n");

  if (!GetLogicalProcessorInformationExProc)
    goto error;

  nr_processor_groups = GetActiveProcessorGroupCountProc();
  if (!nr_processor_groups)
    goto error;

  hwloc_debug("found %lu windows processor groups\n", nr_processor_groups);

  if (nr_processor_groups > 1 && SIZEOF_VOID_P == 4) {
    if (HWLOC_SHOW_ALL_ERRORS())
      fprintf(stderr, "hwloc: multiple processor groups found on 32bits Windows, topology may be invalid/incomplete.\n");
  }

  length = 0;
  procInfoTotal = NULL;

  while (1) {
    if (GetLogicalProcessorInformationExProc(RelationGroup, procInfoTotal, &length))
      break;
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      goto error;
    tmpprocInfoTotal = realloc(procInfoTotal, length);
    if (!tmpprocInfoTotal)
      goto error_with_procinfo;
    procInfoTotal = tmpprocInfoTotal;
  }

  processor_group_cpusets = calloc(nr_processor_groups, sizeof(*processor_group_cpusets));
  if (!processor_group_cpusets)
    goto error_with_procinfo;

  for (procInfo = procInfoTotal;
       (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
       procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
    unsigned id;

    assert(procInfo->Relationship == RelationGroup);

    hwloc_debug("Found %u active windows processor groups\n",
                (unsigned) procInfo->Group.ActiveGroupCount);
    for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
      KAFFINITY mask;
      hwloc_bitmap_t set;

      set = hwloc_bitmap_alloc();
      if (!set)
        goto error_with_cpusets;

      mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
      hwloc_debug("group %u with %u cpus mask 0x%llx\n", id,
                  (unsigned) procInfo->Group.GroupInfo[id].ActiveProcessorCount, (unsigned long long) mask);
      /* KAFFINITY is ULONG_PTR */
      hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
      /* FIXME: what if running 32bits on a 64bits windows with 64-processor groups?
       * ULONG_PTR is 32bits, so half the group is invisible?
       * maybe scale id to id*8/sizeof(ULONG_PTR) so that groups are 64-PU aligned?
       */
      hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);
      processor_group_cpusets[id] = set;
    }
  }

  free(procInfoTotal);
  return;

 error_with_cpusets:
  for(i=0; i<nr_processor_groups; i++) {
    if (processor_group_cpusets[i])
      hwloc_bitmap_free(processor_group_cpusets[i]);
  }
  free(processor_group_cpusets);
  processor_group_cpusets = NULL;
 error_with_procinfo:
  free(procInfoTotal);
 error:
  /* on error set nr to 1 and keep cpusets NULL. We'll use the topology cpuset whenever needed */
  nr_processor_groups = 1;
}

```

这段代码定义了一个名为 `hwloc_win_free_processor_groups` 的函数，其作用是释放可处理器组中的处理器和它们的CPU集合。以下是该函数的实现细节：

1. 函数头声明了一个名为 `hwloc_win_free_processor_groups` 的函数，参数类型为 `void`。

2. 函数体内使用了一个 `for` 循环，从 `i` 开始，直到 `i` 达到 `nr_processor_groups` 为止。

3. 循环内部的逻辑判断是一个 `if` 语句，判断是否当前处理器组中包含了一个 CPU 集合。如果是，则使用 `hwloc_bitmap_free` 函数释放该 CPU 集合。

4. 如果当前处理器组中包含的 CPU 集合为空，则将 `processor_group_cpusets` 指向内存中的 NULL，并将 `nr_processor_groups` 设置为 1。

5. 循环结束后，释放 `processor_group_cpusets` 指向的内存，并将 `nr_processor_groups` 设置为 0。

6. 最后，将 `hwloc_bitmap_free` 函数的指针设置为 `NULL`，以释放所有内存分配，函数结束。

综上，该函数的作用是释放可处理器组中的处理器和它们的CPU集合，并释放分配的内存。


```cpp
static void
hwloc_win_free_processor_groups(void)
{
  unsigned i;
  for(i=0; i<nr_processor_groups; i++) {
    if (processor_group_cpusets[i])
      hwloc_bitmap_free(processor_group_cpusets[i]);
  }
  free(processor_group_cpusets);
  processor_group_cpusets = NULL;
  nr_processor_groups = 1;
}


int
```

这段代码的作用是获取指定拓扑结构中的处理器组数量。在 Windows 操作系统中，每个处理器组都由多个处理器组成。获取处理器组数量可以通过在操作系统中使用 hwloc_windows_get_nr_processor_groups 函数获取。

函数接受两个参数：hwloc_topology_t 类型的拓扑结构和unsigned long 类型的标志。如果拓扑结构没有加载或不是当前系统，函数将返回 EINVAL 错误并返回 -1。如果标志参数为真，函数也将返回 EINVAL 错误并返回 -1。

函数返回一个整数，表示拓扑结构中的处理器组数量。这个函数对于在 Windows 系统中基于拓扑结构的虚拟化非常重要，可以帮助您在使用 hwloc 库时正确地处理拓扑结构。


```cpp
hwloc_windows_get_nr_processor_groups(hwloc_topology_t topology, unsigned long flags)
{
  if (!topology->is_loaded || !topology->is_thissystem) {
    errno = EINVAL;
    return -1;
  }

  if (flags) {
    errno = EINVAL;
    return -1;
  }

  return nr_processor_groups;
}

```

这段代码是一个名为`hwloc_windows_get_processor_group_cpuset`的函数，属于`hwloc_topology_t`系列的函数。其作用是返回一个指定的`hwloc_cpuset_t`结构，该结构包含了在指定的`hwloc_topology_t`结构中属于`pg_index`的`hwloc_processor_group_t`结构中指定的`hwloc_cpuset_t`结构。

具体来说，该函数需要满足以下条件才能正常返回：

1. `topology` 参数必须是已初始化的 `hwloc_topology_t` 结构；
2. `pg_index` 参数必须是一个有效的 `pg_index`，即在操作系统支持的情况下，该索引指向的进程组 ID；
3. `cpuset` 参数必须是已初始化的 `hwloc_cpuset_t` 结构；
4. `flags` 参数可以包含 `HWLOC_CPU_SET_FLAG_CPU_SETS` 和 `HWLOC_CPU_SET_FLAG_PASS_THRU` 这两个标志，但必须至少有一个是有效的；
5. 如果 `topology`、`pg_index` 和 `cpuset` 都符合条件，但 `processor_group_cpusets` 指向的内存区域不可用，则返回 `ENOENT` 错误；
6. 如果 `pg_index` 超过了 `nr_processor_groups` 的最大值，则返回 `ENOENT` 错误；
7. 如果 `topology` 中的 `hwloc_levels` 数组长度小于1，则返回 `ENOENT` 错误。


```cpp
int
hwloc_windows_get_processor_group_cpuset(hwloc_topology_t topology, unsigned pg_index, hwloc_cpuset_t cpuset, unsigned long flags)
{
  if (!topology->is_loaded || !topology->is_thissystem) {
    errno = EINVAL;
    return -1;
  }

  if (!cpuset) {
    errno = EINVAL;
    return -1;
  }

  if (flags) {
    errno = EINVAL;
    return -1;
  }

  if (pg_index >= nr_processor_groups) {
    errno = ENOENT;
    return -1;
  }

  if (!processor_group_cpusets) {
    assert(nr_processor_groups == 1);
    /* we found no processor groups, return the entire topology as a single one */
    hwloc_bitmap_copy(cpuset, topology->levels[0][0]->cpuset);
    return 0;
  }

  if (!processor_group_cpusets[pg_index]) {
    errno = ENOENT;
    return -1;
  }

  hwloc_bitmap_copy(cpuset, processor_group_cpusets[pg_index]);
  return 0;
}

```

这段代码定义了一个名为hwloc_pu_numbering的函数，该函数输出当前硬件平台中每个处理器组的独占地址。这个独占地址是基于Windows处理器组的最大数量而确定的，但是由于Windows的一些调整（如使用NUMA节点和调整bcdedit设置组大小），所以这个数量可能少于64个。

函数内部创建了64个物理索引，并为每个处理器组分配一个物理索引。由于硬件平台可能存在非连续的物理索引，因此需要保留一些未使用的时间。

函数还定义了一个名为hwloc_fallback_nbprocessors的函数，该函数返回当前硬件平台中的处理器数量。然而，由于上述原因，该函数也将返回最后一个处理器组的下一个物理索引，而不是实际处理器数量。

最后，函数使用了last_cpu_location函数来获取上一个CPU的位置。


```cpp
/**************************************************************
 * hwloc PU numbering with respect to Windows processor groups
 *
 * Everywhere below we reserve 64 physical indexes per processor groups because that's
 * the maximum (MAXIMUM_PROC_PER_GROUP). Windows may actually use less bits than that
 * in some groups (either to avoid splitting NUMA nodes across groups, or because of OS
 * tweaks such as "bcdedit /set groupsize 8") but we keep some unused indexes for simplicity.
 * That means PU physical indexes and cpusets may be non-contigous.
 * That also means hwloc_fallback_nbprocessors() below must return the last PU index + 1
 * instead the actual number of processors.
 */

/********************
 * last_cpu_location
 */

```

这段代码是一个名为 `hwloc_win_get_thisthread_last_cpu_location` 的函数，属于 `hwloc_topology_t` 类型的枚举类型。它的作用是返回一个整数，表示当前正在运行的处理器（CPU）的位置。

函数的具体实现如下：

1. 首先检查 `GetCurrentProcessorNumberExProc` 是否为真，如果是，则执行以下操作：

  a. 获取当前进程的处理器数量。

  b. 通过 `hwloc_bitmap_from_ith_ULONG_PTR` 函数，将 `set` 中的映射映射到 `num.Group` 对应的处理器组上，并将 `num.Number` 设置为 1。设置完成后，返回 0。

2. 如果 `GetCurrentProcessorNumberProc` 为真，并且当前已经连接了一个处理器组，则执行以下操作：

  a. 通过 `hwloc_bitmap_from_ith_ULONG_PTR` 函数，将 `set` 中的映射映射到 `0` 对应的处理器组上，并将 `num` 设置为 `GetCurrentProcessorNumberProc` 返回的值。设置完成后，返回 0。

3. 如果 `GetCurrentProcessorNumberProc` 为假，或者当前连接的处理器组数量小于 1，则执行以下操作：

  a. 通过 `hwloc_bitmap_from_ith_ULONG_PTR` 函数，将 `set` 中的映射映射到 `0` 对应的处理器组上，并将 `num` 设置为 `GetCurrentProcessorNumberProc` 返回的值。设置完成后，返回 0。

4. 如果 `GetCurrentProcessorNumberExProc` 为假，并且当前连接的处理器组数量大于 1，则执行以下操作：

  a. 通过 `hwloc_bitmap_from_ith_ULONG_PTR` 函数，将 `set` 中的映射映射到 `num.Group` 对应的处理器组上，并将 `num.Number` 设置为 `((ULONG_PTR)1) << num.Number`。设置完成后，返回 0。


```cpp
static int
hwloc_win_get_thisthread_last_cpu_location(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
{
  assert(GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1));

  if (nr_processor_groups > 1 || !GetCurrentProcessorNumberProc) {
    PROCESSOR_NUMBER num;
    GetCurrentProcessorNumberExProc(&num);
    hwloc_bitmap_from_ith_ULONG_PTR(set, num.Group, ((ULONG_PTR)1) << num.Number);
    return 0;
  }

  hwloc_bitmap_from_ith_ULONG_PTR(set, 0, ((ULONG_PTR)1) << GetCurrentProcessorNumberProc());
  return 0;
}

```

This function appears to be a part of the "hwloc" library in C, which is a cross-platform ./config build system. It appears to be responsible for setting the CPU and memory bindings for threads.

The function takes in a topology object and a thread object, along with a set bitmap and a set of flags. The topology object is an hwloc\_topology\_t data type, which presumably contains information about the hardware resources the thread is running on. The thread object is a hwloc\_thread\_t data type, which contains information about the thread itself. The set bitmap is a hwloc\_const\_bitmap\_t data type, which appears to be a bitmap indicating the affinity (i.e. whether the thread belongs to this process or any other process) of the thread for the specified CPU/memory groups. The flags parameter is a combination of several flags, including HWLOC\_CPUBIND\_NOMEMBIND, which specifies whether to set the binding to the default value without memory binding, and HWLOC\_THREAD\_SET\_INFORMATION and HWLOC\_THREAD\_SET\_INFORMATION\_EX, which specify whether to get or set information about the thread.

If the function succeeds in setting the binding, it returns 0. If it fails, it returns ENOSYS.


```cpp
/* TODO: hwloc_win_get_thisproc_last_cpu_location() using
 * CreateToolhelp32Snapshot(), Thread32First/Next()
 * th.th32OwnerProcessID == GetCurrentProcessId() for filtering within process
 * OpenThread(THREAD_SET_INFORMATION|THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID) to get a handle.
 */


/******************************
 * set cpu/membind for threads
 */

/* TODO: SetThreadIdealProcessor{,Ex} */

static int
hwloc_win_set_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_const_bitmap_t hwloc_set, int flags)
{
  DWORD_PTR mask;
  unsigned group;

  if (flags & HWLOC_CPUBIND_NOMEMBIND) {
    errno = ENOSYS;
    return -1;
  }

  if (hwloc_bitmap_to_single_ULONG_PTR(hwloc_set, &group, &mask) < 0) {
    errno = ENOSYS;
    return -1;
  }

  assert(nr_processor_groups == 1 || SetThreadGroupAffinityProc);

  if (nr_processor_groups > 1) {
    GROUP_AFFINITY aff;
    memset(&aff, 0, sizeof(aff)); /* we get Invalid Parameter error if Reserved field isn't cleared */
    aff.Group = group;
    aff.Mask = mask;
    if (!SetThreadGroupAffinityProc(thread, &aff, NULL))
      return -1;

  } else {
    /* SetThreadAffinityMask() only changes the mask inside the current processor group */
    /* The resulting binding is always strict */
    if (!SetThreadAffinityMask(thread, mask))
      return -1;
  }
  return 0;
}

```

这段代码定义了两个名为 `hwloc_win_set_thisthread_cpubind` 和 `hwloc_win_set_thisthread_membind` 的函数，它们属于 `hwloc_topology_t` 结构体的成员函数。

它们的目的是设置 `hwloc_set` 函数的 `cpubind` 标志，用于指示 CPU 绑定，并传回 `hwloc_win_set_thread_cpubind` 函数作为底层函数。

`hwloc_win_set_thisthread_cpubind` 函数的实现比较复杂，因为它需要处理多个操作系统版本和多个硬件平台。具体来说，它会遍历当前系统的所有 CPU 集，并检查设置 CPU 绑定的权限，如果设置了权限，就调用 `hwloc_win_set_thread_cpubind` 函数底层，否则就返回一个错误码。

`hwloc_win_set_thisthread_membind` 函数的实现相对简单，它类似于 `hwloc_win_set_thisthread_cpubind` 函数，但只需要设置内存绑定，而不需要关心 CPU 绑定。它的参数包括 `hwloc_topology_t` 结构体和三个整数标志：`policy`、`nodeset` 和 `flags`。`policy` 标志用于指定内存绑定的策略，可以设置为 HWLOC_MEMBIND_DEFAULT、HWLOC_MEMBIND_BIND 或 HWLOC_MEMBIND_NOCPUBIND。`nodeset` 参数指定了要绑定的 CPU 集合，`flags` 参数用于设置标志，例如 HWLOC_MEMBIND_NOCPUBIND 表示不绑定 CPU。函数返回值是一个整数，表示设置的最终结果。


```cpp
static int
hwloc_win_set_thisthread_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
{
  return hwloc_win_set_thread_cpubind(topology, GetCurrentThread(), hwloc_set, flags);
}

static int
hwloc_win_set_thisthread_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
{
  int ret;
  hwloc_const_cpuset_t cpuset;
  hwloc_cpuset_t _cpuset = NULL;

  if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
      || flags & HWLOC_MEMBIND_NOCPUBIND) {
    errno = ENOSYS;
    return -1;
  }

  if (policy == HWLOC_MEMBIND_DEFAULT) {
    cpuset = hwloc_topology_get_complete_cpuset(topology);
  } else {
    cpuset = _cpuset = hwloc_bitmap_alloc();
    hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
  }

  ret = hwloc_win_set_thisthread_cpubind(topology, cpuset,
					 (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
  hwloc_bitmap_free(_cpuset);
  return ret;
}


```



该代码是一个C函数，名为 `hwloc_win_get_thread_cpubind`，属于 `hwloc_private` 命名空间。其作用是获取指定线程所属的CPU/内存区域，并将该区域初始化到给定的 `hwloc_cpuset_t` 集合中。

具体来说，该函数接收三个参数：

- `topology`：一个 `hwloc_topology_t` 类型的上下文对象，用于获取线程所在的硬件平台。
- `thread`：一个 `hwloc_thread_t` 类型的线程对象，用于指定要获取的线程。
- `set`：一个 `hwloc_cpuset_t` 类型的参数，用于指定要将其中的所有CPU分配给线程的集合。
- `flags`：一个 `int` 类型的参数，用于指定使用哪些操作系统调用函数。

函数首先使用 `GetThreadGroupAffinityProc` 函数获取指定线程所属的CPU/内存区域，如果没有成功，则返回 -1。然后使用 `hwloc_bitmap_from_ith_ULONG_PTR` 函数将线程所属的CPU/内存区域设置为给定的 `hwloc_cpuset_t` 集合中指定日期的位图。最后，函数将 `hwloc_bitmap_from_ith_ULONG_PTR` 函数返回的结果设置给 `set` 参数，这样就可以将线程分配到的CPU/内存区域与给定的集合中的一些CPU绑定在一起了。

该函数是 `hwloc_private` 命名空间中 `hwloc_topology_t` 和 `hwloc_thread_t` 类的成员函数之一，用于帮助用户管理多线程的硬件资源。


```cpp
/******************************
 * get cpu/membind for threads
 */

static int
hwloc_win_get_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
{
  GROUP_AFFINITY aff;

  assert(GetThreadGroupAffinityProc);

  if (!GetThreadGroupAffinityProc(thread, &aff))
    return -1;
  hwloc_bitmap_from_ith_ULONG_PTR(set, aff.Group, aff.Mask);
  return 0;
}

```



这两段代码是用于在 hwloc_topology_t 结构体中获取当前进程的 CPU 设置，并设置给定的 Membind 策略的函数。

hwloc_win_get_thisthread_cpubind函数接受 topology 参数和 flags 参数，返回 GetCurrentThread() 函数返回的当前进程的 CPU 设置。

hwloc_win_get_thisthread_membind函数接受 topology 参数和 flags 参数，返回 Membind 策略的值。在函数内部，首先定义了一个 cpuset 变量，然后调用 hwloc_win_get_thread_cpubind 函数获取当前进程的 CPU 设置，接着设置给定 Membind 策略，最后释放 cpuset 并返回结果。

需要注意的是，这两段代码需要保证在 Windows 操作系统上运行，并包含必要的头文件。


```cpp
static int
hwloc_win_get_thisthread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
{
  return hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), set, flags);
}

static int
hwloc_win_get_thisthread_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
{
  int ret;
  hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
  ret = hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), cpuset, flags);
  if (!ret) {
    *policy = HWLOC_MEMBIND_BIND;
    hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
  }
  hwloc_bitmap_free(cpuset);
  return ret;
}


```

这段代码定义了一个名为 `hwloc_win_set_proc_cpubind` 的函数，用于设置指定进程的 CPU/内存绑定。

函数接受三个参数：

- `topology`：输入的哈威络布局 topology 类型。
- `proc`：要设置定制的进程 ID。
- `hwloc_set`：一个输出 bitmap，用于指定每个处理器组成员的内存区域。
- `flags`：设置为 0 时，使用当前进程的 CPU/内存绑定；设置为 HWLOC_CPUBIND_NOMEMBIND 时，禁用内存绑定。设置为 HWLOC_CPUBIND_SET_THREAD_GROUP 或 HWLOC_CPUBIND_SET_PROCESS 时有特定的用途。

函数内部首先检查设置了的 CPU/内存绑定是否支持内存绑定，如果不支持，则返回 -1。然后设置指定进程的 CPU/内存绑定，并返回 0，表示设置成功。

设置进程的 CPU/内存绑定仅在 `hwloc_set` 的某些有效值范围下有效。


```cpp
/********************************
 * set cpu/membind for processes
 */

static int
hwloc_win_set_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_const_bitmap_t hwloc_set, int flags)
{
  DWORD_PTR mask;

  assert(nr_processor_groups == 1);

  if (flags & HWLOC_CPUBIND_NOMEMBIND) {
    errno = ENOSYS;
    return -1;
  }

  /* TODO: SetThreadGroupAffinity() for all threads doesn't enforce the whole process affinity,
   * maybe because of process-specific resource locality */
  /* TODO: if we are in a single group (check with GetProcessGroupAffinity()),
   * SetProcessAffinityMask() changes the binding within that same group.
   */
  /* TODO: NtSetInformationProcess() works very well for binding to any mask in a single group,
   * but it's an internal routine.
   */
  /* TODO: checks whether hwloc-bind.c needs to pass INHERIT_PARENT_AFFINITY to CreateProcess() instead of execvp(). */

  /* The resulting binding is always strict */
  mask = hwloc_bitmap_to_ULONG_PTR(hwloc_set);
  if (!SetProcessAffinityMask(proc, mask))
    return -1;
  return 0;
}

```

这段代码定义了两个名为 `hwloc_win_set_thisproc_cpubind` 和 `hwloc_win_set_proc_membind` 的函数，属于 `hwloc_win_set_proc` 函数的一部分。它们的目的是设置指定进程的 `CPU` 或 `CpuSet` 内某个特定节点上内存的映射。通过调用 `hwloc_win_set_proc` 函数，然后传递给该函数所需的参数，实现设置的目的。

在这两个函数中，首先检查设置的策略，如果策略不正确或者禁用节点映射，函数将返回 `-1`，否则将执行设置操作。然后，根据策略使用不同的方法来实现设置：如果策略是 `HWLOC_MEMBIND_DEFAULT`，则使用 `hwloc_topology_get_complete_cpuset` 函数获取所有节点的 `CPU` 集，并使用 `hwloc_bitmap_alloc` 函数分配一个内存映射；如果策略是 `HWLOC_MEMBIND_BIND`，则创建一个内存映射；如果策略是 `HWLOC_MEMBIND_NOCPUBIND`，则禁用节点映射。最后，返回设置结果。


```cpp
static int
hwloc_win_set_thisproc_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
{
  return hwloc_win_set_proc_cpubind(topology, GetCurrentProcess(), hwloc_set, flags);
}

static int
hwloc_win_set_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
{
  int ret;
  hwloc_const_cpuset_t cpuset;
  hwloc_cpuset_t _cpuset = NULL;

  if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
      || flags & HWLOC_MEMBIND_NOCPUBIND) {
    errno = ENOSYS;
    return -1;
  }

  if (policy == HWLOC_MEMBIND_DEFAULT) {
    cpuset = hwloc_topology_get_complete_cpuset(topology);
  } else {
    cpuset = _cpuset = hwloc_bitmap_alloc();
    hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
  }

  ret = hwloc_win_set_proc_cpubind(topology, pid, cpuset,
				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
  hwloc_bitmap_free(_cpuset);
  return ret;
}

```

这段代码定义了两个函数，名为`hwloc_win_set_proc_membind`和`hwloc_win_get_proc_cpubind`，它们属于`hwloc_membind_policy_t`类型的函数，作用是设置和获取CPU/内存绑定。

`hwloc_win_set_proc_membind`函数的实现如下：

```cppc
static int
hwloc_win_set_proc_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
{
 return hwloc_win_set_proc_membind_ex(topology, nodeset, policy, flags);
}

```

`hwloc_win_get_proc_cpubind`函数的实现如下：

```cppc
static int
hwloc_win_get_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_bitmap_t hwloc_set, int flags)
{
 DWORD_PTR proc_mask, sys_mask;

 assert(nr_processor_groups == 1);

 if (flags & HWLOC_CPUBIND_NOMEMBIND) {
   errno = ENOSYS;
   return -1;
 }

 /* TODO: if we are in a single group (check with GetProcessGroupAffinity()),
  * GetProcessAffinityMask() gives the mask within that group.
  */
 /* TODO: if we are in multiple groups, GetProcessGroupAffinity() gives their IDs,
  * but we don't know their masks.
  */
 /* TODO: GetThreadGroupAffinity() for all threads can be smaller than the whole process affinity,
  * maybe because of process-specific resource locality.
  */

 if (!GetProcessAffinityMask(proc, &proc_mask, &sys_mask))
   return -1;
 hwloc_bitmap_from_ULONG_PTR(hwloc_set, proc_mask);
 return 0;
}
```

这两个函数是`hwloc_membind_policy_t`类型的函数，用于设置和获取CPU/内存绑定。通过这两个函数，可以实现函数调用者之间的数据交换，以实现在不同进程之间共享数据。


```cpp
static int
hwloc_win_set_thisproc_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
{
  return hwloc_win_set_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
}


/********************************
 * get cpu/membind for processes
 */

static int
hwloc_win_get_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_bitmap_t hwloc_set, int flags)
{
  DWORD_PTR proc_mask, sys_mask;

  assert(nr_processor_groups == 1);

  if (flags & HWLOC_CPUBIND_NOMEMBIND) {
    errno = ENOSYS;
    return -1;
  }

  /* TODO: if we are in a single group (check with GetProcessGroupAffinity()),
   * GetProcessAffinityMask() gives the mask within that group.
   */
  /* TODO: if we are in multiple groups, GetProcessGroupAffinity() gives their IDs,
   * but we don't know their masks.
   */
  /* TODO: GetThreadGroupAffinity() for all threads can be smaller than the whole process affinity,
   * maybe because of process-specific resource locality.
   */

  if (!GetProcessAffinityMask(proc, &proc_mask, &sys_mask))
    return -1;
  hwloc_bitmap_from_ULONG_PTR(hwloc_set, proc_mask);
  return 0;
}

```

这段代码定义了一个名为 `hwloc_win_get_proc_membind` 的函数，它属于 `hwloc_topology_ex` 类的成员函数。它的作用是获取指定 `hwloc_topology_t` 结构中的 `pid` 和 `nodeset` 成员，然后根据传递给它的 `flags` 参数，实现对 `HWLOC_MEMBIND_STRICT` 标志的设置，最后返回一个整数表示调用结果。

函数具体实现如下：

1. 首先定义一个名为 `cpuset` 的 `hwloc_cpu_set`，然后使用 `hwloc_bitmap_alloc` 函数，分配出一定数量的 `CPU` 绑定，并将其存储在 `cpuset` 中。
2. 接着，使用 `hwloc_win_get_proc_cpubind` 函数，获取到指定的 `pid` 和 `nodeset`，并将其存储在 `cpuset` 中。
3. 如果调用 `hwloc_win_get_proc_cpubind` 函数时出错，则执行第 3 步，否则执行第 4 步。
4. 在第 4 步中，如果 `HWLOC_MEMBIND_STRICT` 标志的值为 `1`，则执行第 5 步，否则执行第 6 步。
5. 在第 5 步和第 6 步中，使用 `hwloc_cpuset_to_nodeset` 函数，将 `cpuset` 中的所有 `CPU` 绑定映射到指定的 `nodeset` 中。
6. 最后，释放分配的内存，并返回值。


```cpp
static int
hwloc_win_get_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
{
  int ret;
  hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
  ret = hwloc_win_get_proc_cpubind(topology, pid, cpuset,
				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
  if (!ret) {
    *policy = HWLOC_MEMBIND_BIND;
    hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
  }
  hwloc_bitmap_free(cpuset);
  return ret;
}

```

这段代码定义了两个名为`hwloc_win_get_thisproc_cpubind`和`hwloc_win_get_thisproc_membind`的函数，它们都接受一个名为`hwloc_topology_t`的上下文参数，一个名为`hwloc_bitmap_t`的第二个参数，以及一个名为`int flags`的第三个参数。

这两个函数的主要作用是帮助用户在`hwloc_topology_t`的内存布局中使用内存互斥技术，通过偏移量来指定哪些内存区域是互斥的，哪些内存区域可以同时被访问。

具体来说，`hwloc_win_get_thisproc_cpubind`函数接受一个`hwloc_topology_t`的上下文和一个`hwloc_bitmap_t`，它返回的是一个指向`hwloc_win_proc_cpubind`函数的指针，这个函数用于从当前进程的内存布局中获取与给定CPU集相关的互斥区域，然后返回一个整数，表示成功返回的IDX。

`hwloc_win_get_thisproc_membind`函数接受一个`hwloc_topology_t`的上下文和一个`hwloc_membind_policy_t`，它返回的是一个指向`hwloc_win_proc_membind`函数的指针，这个函数用于从当前进程的内存布局中获取与给定节点集相关的内存绑定策略，然后返回一个整数，表示成功返回的IDX。

需要注意的是，这两个函数的实现主要依赖于操作系统特定的API，以及`hwloc_topology_t`和`hwloc_membind_policy_t`的具体类型定义，因此在不同的操作系统和发行版中，这些函数的实现可能会略有不同。


```cpp
static int
hwloc_win_get_thisproc_cpubind(hwloc_topology_t topology, hwloc_bitmap_t hwloc_cpuset, int flags)
{
  return hwloc_win_get_proc_cpubind(topology, GetCurrentProcess(), hwloc_cpuset, flags);
}

static int
hwloc_win_get_thisproc_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
{
  return hwloc_win_get_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
}


/************************
 * membind alloc/free
 */

```

这两段代码是C语言中的函数，属于hwloc库。它实现了一个内存分配函数和一个内存绑定函数。

hwloc_win_alloc函数用于在硬件设备驱动程序中分配内存空间。在函数中，首先定义了一个topology参数，用于指定内存分配的布局，然后使用VirtualAlloc函数尝试从内存中分配给定的内存大小。如果分配成功，函数将返回新分配的内存的地址。如果分配失败，函数将返回错误代码。

hwloc_win_alloc_membind函数用于将一个内存区域映射到硬件设备驱动程序的虚拟内存中。在函数中，首先定义了一个topology参数，用于指定内存分配的布局，然后定义了一个nodeset参数，用于指定要绑定的节点集合，接着定义了一个policy参数，用于指定内存绑定的策略，最后定义了一个flags参数，用于指定分配的内存大小。函数将检查策略是否为默认策略（HWLOC_MEMBIND_DEFAULT）或内存绑定策略，如果为默认策略，则尝试从内存中分配给定的内存大小，否则抛出ENOSYS错误。如果分配成功，函数将返回新分配的内存的地址。


```cpp
static void *
hwloc_win_alloc(hwloc_topology_t topology __hwloc_attribute_unused, size_t len) {
  return VirtualAlloc(NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
}

static void *
hwloc_win_alloc_membind(hwloc_topology_t topology __hwloc_attribute_unused, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags) {
  int node;

  switch (policy) {
    case HWLOC_MEMBIND_DEFAULT:
    case HWLOC_MEMBIND_BIND:
      break;
    default:
      errno = ENOSYS;
      return hwloc_alloc_or_fail(topology, len, flags);
  }

  if (flags & HWLOC_MEMBIND_STRICT) {
    errno = ENOSYS;
    return NULL;
  }

  if (policy == HWLOC_MEMBIND_DEFAULT
      || hwloc_bitmap_isequal(nodeset, hwloc_topology_get_complete_nodeset(topology)))
    return hwloc_win_alloc(topology, len);

  if (hwloc_bitmap_weight(nodeset) != 1) {
    /* Not a single node, can't do this */
    errno = EXDEV;
    return hwloc_alloc_or_fail(topology, len, flags);
  }

  node = hwloc_bitmap_first(nodeset);
  return VirtualAllocExNumaProc(GetCurrentProcess(), NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE, node);
}

```

这段代码定义了一个名为`hwloc_win_free_membind`的函数，属于`hwloc_topology_t`类型的函数，用于管理内存绑定中的内存。

函数接受两个参数，一个是`topology`参数，指代一个`hwloc_topology_t`类型的局部上下文，另一个是`addr`参数，是一个指向内存地址的指针，以及一个`len`参数，也是一个指向内存长度的指针。这两个参数都被视为`void *`类型的数据。

函数首先检查`addr`是否为`NULL`，如果是，函数返回0，表示操作成功。否则，函数接下来使用`VirtualFreeExProc`函数，属于`ctype_abstract_ix`类型的函数，用于释放内存。函数的最后一个参数是`MEM_RELEASE`，表示释放内存时使用的方式。

如果`VirtualFreeExProc`函数无法释放内存，函数将返回-1。否则，函数返回0，表示操作成功。

这段代码的作用是管理内存绑定中的内存，用于在`hwloc_topology_t`类型的局部上下文中使用`VirtualFreeExProc`函数来释放内存。


```cpp
static int
hwloc_win_free_membind(hwloc_topology_t topology __hwloc_attribute_unused, void *addr, size_t len __hwloc_attribute_unused) {
  if (!addr)
    return 0;
  if (!VirtualFreeExProc(GetCurrentProcess(), addr, 0, MEM_RELEASE))
    return -1;
  return 0;
}


/**********************
 * membind for areas
 */

static int
```

该函数的作用是获取一个硬件设备分配的内存位置，并返回其虚拟地址。它需要传递三个参数：

1. topology：一个hwloc_topology_t类型的数据结构，用于在内存布局中定位要查找的内存位置。
2. addr：一个void指针，包含要查找的虚拟地址。
3. len：一个size_t类型的参数，包含虚拟地址的长度。
4. nodeset：一个hwloc_nodeset_t类型的数据结构，用于在内存布局中定位要查找的内存位置。
5. flags：一个int类型的参数，用于指定返回值的格式。

函数内部首先获取系统信息，然后计算要查找的虚拟地址在内存布局中的偏移量。接下来，它创建一个长度为要查找的虚拟地址长度的数组，并检查内存分配是否成功。然后，它遍历虚拟地址数组，并将创建的节点设置为有效，最后释放内存并返回0。


```cpp
hwloc_win_get_area_memlocation(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr, size_t len, hwloc_nodeset_t nodeset, int flags __hwloc_attribute_unused)
{
  SYSTEM_INFO SystemInfo;
  DWORD page_size;
  uintptr_t start;
  unsigned nb;
  PSAPI_WORKING_SET_EX_INFORMATION *pv;
  unsigned i;

  GetSystemInfo(&SystemInfo);
  page_size = SystemInfo.dwPageSize;

  start = (((uintptr_t) addr) / page_size) * page_size;
  nb = (unsigned)((((uintptr_t) addr + len - start) + page_size - 1) / page_size);

  if (!nb)
    nb = 1;

  pv = calloc(nb, sizeof(*pv));
  if (!pv)
    return -1;

  for (i = 0; i < nb; i++)
    pv[i].VirtualAddress = (void*) (start + i * page_size);
  if (!QueryWorkingSetExProc(GetCurrentProcess(), pv, nb * sizeof(*pv))) {
    free(pv);
    return -1;
  }

  for (i = 0; i < nb; i++) {
    if (pv[i].VirtualAttributes.Valid)
      hwloc_bitmap_set(nodeset, pv[i].VirtualAttributes.Node);
  }

  free(pv);
  return 0;
}



```



这段代码定义了一个名为 `hwloc_win_efficiency_classes` 的结构体，用于表示效率类别的信息。

该结构体包含以下成员：

- `nr_classes`：表示硬链接器中存在的类别的数量。
- `nr_classes_allocated`：表示已经分配但未命名的类别的数量。
- `classes`：一个结构体指针，指向一个分配的内存区域，用于存储每个类别的信息。

结构体中的 `classes` 成员是一个指针，指向一个结构体 `hwloc_win_efficiency_class` 的指针。该指针中包含一个 `value` 字段，表示类别中每个成员的值，以及一个 `cpu_set` 字段，用于表示该类别属于哪些处理器核心。

在 `hwloc_win_efficiency_classes_init` 函数中，初始化了上述成员变量。函数的第一个参数 `classes` 是一个指向 `hwloc_win_efficiency_classes` 结构体的指针，第二个参数 `None` 表示不需要传递任何其他参数。

函数的作用是清除 `classes` 指向的内存区域，如果没有分配内存，则无需进行任何初始化。


```cpp
/*************************
 * Efficiency classes
 */

struct hwloc_win_efficiency_classes {
  unsigned nr_classes;
  unsigned nr_classes_allocated;
  struct hwloc_win_efficiency_class {
    unsigned value;
    hwloc_bitmap_t cpuset;
  } *classes;
};

static void
hwloc_win_efficiency_classes_init(struct hwloc_win_efficiency_classes *classes)
{
  classes->classes = NULL;
  classes->nr_classes_allocated = 0;
  classes->nr_classes = 0;
}

```

这段代码的作用是向 `hwloc_win_efficiency_classes` 结构中添加一个新的效率类（class），该类别的值等于给定的值。

首先，它定义了一个名为 `classes` 的指针变量，它是一个指向 `hwloc_win_efficiency_classes` 结构体的指针。

然后，它定义了一个名为 `cpuset` 的哈瓦格库特集，该哈瓦格库特集用于存储给定的 CPU 集合。

接着，定义了一个名为 `value` 的无符号整数变量，它表示要添加的效率类别的值。

接下来，使用一个 for 循环来查找给定的效率类别的哈瓦格库特集是否已经存在。如果存在，就执行以下操作：

1. 创建一个名为 `tmp` 的结构体变量，该结构体包含一个指向 `hwloc_win_efficiency_class` 的指针。
2. 执行一个 if 语句，判断给定的哈瓦格库特集是否已经被分配过，如果是，则表示已经存在一个与给定值相同的效率类别，可以返回 0。
3. 否则，扩展哈瓦格库特集，如果需要的哈瓦格库特集大小加倍，则创建一个新的哈瓦格库特集，并将其设置为新的哈瓦格库特集的大小。

最后，返回 `0`，表示添加成功。


```cpp
static int
hwloc_win_efficiency_classes_add(struct hwloc_win_efficiency_classes *classes,
                                 hwloc_const_bitmap_t cpuset,
                                 unsigned value)
{
  unsigned i;

  /* look for existing class with that efficiency value */
  for(i=0; i<classes->nr_classes; i++) {
    if (classes->classes[i].value == value) {
      hwloc_bitmap_or(classes->classes[i].cpuset, classes->classes[i].cpuset, cpuset);
      return 0;
    }
  }

  /* extend the array if needed */
  if (classes->nr_classes == classes->nr_classes_allocated) {
    struct hwloc_win_efficiency_class *tmp;
    unsigned new_nr_allocated = 2*classes->nr_classes_allocated;
    if (!new_nr_allocated) {
```

这段代码定义了一个名为 "HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX" 的宏，其含义是 "在 Windows 平台上，为每个进程分配的最大 CPU 数量（以瓦特为单位）"。

在函数 "add_class" 中，首先定义了一个名为 "new_nr_allocated" 的整数变量，用于存储分配给新类别的 CPU 数量。

然后，使用 realloc 函数为新类别分配的内存空间，并检查分配是否成功。如果成功，将新类别的内存空间初始化为其所需要的 CPU 数量。

接着，在 "add_class" 函数中，为每个新类别创建一个名为 "classes" 的结构体，并为它分配新的 CPU 集合。然后，将新类别的数量 "classes->nr_classes" 加一。

最后，在 "add_class" 函数的结束部分，使用 hwloc_bitmap_alloc 函数为新类别创建的 CPU 集合创建一个名为 "cpuset" 的瓦特图，并将其复制到 "classes->classes[classes->nr_classes].cpuset" 中。然后，将 "classes->classes[classes->nr_classes].value" 赋值为给定的值，并将 "classes->nr_classes" 递增一。

整个函数的作用是在 Windows 平台上动态分配 CPU 时间片，为每个进程调度器分配一个最大 CPU 数量，并在调度器满时自动添加新类别。


```cpp
#define HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX 4 /* 2 should be enough is most cases */
      new_nr_allocated = HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX;
    }
    tmp = realloc(classes->classes, new_nr_allocated * sizeof(*classes->classes));
    if (!tmp)
      return -1;
    classes->classes = tmp;
    classes->nr_classes_allocated = new_nr_allocated;
  }

  /* add new class */
  classes->classes[classes->nr_classes].cpuset = hwloc_bitmap_alloc();
  if (!classes->classes[classes->nr_classes].cpuset)
    return -1;
  classes->classes[classes->nr_classes].value = value;
  hwloc_bitmap_copy(classes->classes[classes->nr_classes].cpuset, cpuset);
  classes->nr_classes++;
  return 0;
}

```



该代码定义了 hwloc_win_efficiency_classes_register 和 hwloc_win_efficiency_classes_destroy 函数，用于注册和卸载 hwloc_win_efficiency_classes 结构体。

hwloc_win_efficiency_classes_register 函数接收一个 hwloc_topology_t 类型的 topology 参数，一个 struct hwloc_win_efficiency_classes 类型的 classes 参数，以及一个指向 struct hwloc_win_efficiency_classes 的 pointer cls。该函数使用 hwloc_internal_cpukinds_register 函数将 classes 的 CPU 集合注册到 topology 中，将 classes 存储到 cls 中，然后将 classes 的 CPU 集合设置为 NULL，以便 cpukinds 能够访问到它。

hwloc_win_efficiency_classes_destroy 函数接收一个 struct hwloc_win_efficiency_classes 类型的 classes 参数，以及一个指向 struct hwloc_win_efficiency_classes 的指针 ccls。该函数使用 hwloc_bitmap_free 函数 free 函数从 topology 中删除 classes 的 CPU 集合，然后使用 free 函数释放 classes 内存，以便释放 cpukinds。


```cpp
static void
hwloc_win_efficiency_classes_register(hwloc_topology_t topology,
                                      struct hwloc_win_efficiency_classes *classes)
{
  unsigned i;
  for(i=0; i<classes->nr_classes; i++) {
    hwloc_internal_cpukinds_register(topology, classes->classes[i].cpuset, classes->classes[i].value, NULL, 0, 0);
    classes->classes[i].cpuset = NULL; /* given to cpukinds */
  }
}

static void
hwloc_win_efficiency_classes_destroy(struct hwloc_win_efficiency_classes *classes)
{
  unsigned i;
  for(i=0; i<classes->nr_classes; i++)
    hwloc_bitmap_free(classes->classes[i].cpuset);
  free(classes->classes);
}

```

This code appears to be managing the power consumption of a system with multiple CPUs and/or multiple NUMA nodes. It appears to be using the HWLOC_OBJ_CORE class for core和服务 cores, the HWLOC_OBJ_NUMANODE class for NUMA nodes, and the HWLOC_OBJ_EFFICIENCY class for efficiency classes.

Here's a summary of what this code does:

1. Adds the efficiency class to the existing efficiency class list for the current core.
2. If the NUMA node has the HWLOC\_EFFICIENCY\_CLASS header, sets the id to the current id and adds the availability of the memory node to the local memory availability array.
3. If the NUMA node does not have the HWLOC\_EFFICIENCY\_CLASS header, creates a new memory object with the local memory availability and sets the attributes for the NUMA node.
4. Optionally sets the page types for the NUMA node.

This code may also be doing some additional work, such as setting up the system's power limiting, but it appears to be a core part of the overall power management strategy.


```cpp
/*************************
 * discovery
 */

static int
hwloc_look_windows(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
{
  /*
   * This backend uses the underlying OS.
   * However we don't enforce topology->is_thissystem so that
   * we may still force use this backend when debugging with !thissystem.
   */

  struct hwloc_topology *topology = backend->topology;
  hwloc_bitmap_t groups_pu_set = NULL;
  SYSTEM_INFO SystemInfo;
  DWORD length;
  int gotnuma = 0;
  int gotnumamemory = 0;
  OSVERSIONINFOEX osvi;
  char versionstr[20];
  char hostname[122] = "";
  unsigned hostname_size = sizeof(hostname);
  int has_efficiencyclass = 0;
  struct hwloc_win_efficiency_classes eclasses;
  char *env = getenv("HWLOC_WINDOWS_PROCESSOR_GROUP_OBJS");
  int keep_pgroup_objs = (env && atoi(env));

  assert(dstatus->phase == HWLOC_DISC_PHASE_CPU);

  if (topology->levels[0][0]->cpuset)
    /* somebody discovered things */
    return -1;

  ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  if (RtlGetVersionProc) {
    /* RtlGetVersion() returns the currently-running Windows version */
    RtlGetVersionProc(&osvi);
  } else {
    /* GetVersionEx() and isWindows10OrGreater() depend on what the manifest says
     * (manifest of the program, not of libhwloc.dll), they may return old versions
     * if the currently-running Windows is not listed in the manifest.
     */
    GetVersionEx((LPOSVERSIONINFO)&osvi);
  }

  if (osvi.dwMajorVersion >= 10) {
    has_efficiencyclass = 1;
    hwloc_win_efficiency_classes_init(&eclasses);
  }

  hwloc_alloc_root_sets(topology->levels[0][0]);

  GetSystemInfo(&SystemInfo);

  if (GetLogicalProcessorInformationExProc) {
      HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
      unsigned id;
      struct hwloc_obj *obj;
      hwloc_obj_type_t type;

      length = 0;
      procInfoTotal = NULL;

      while (1) {
	if (GetLogicalProcessorInformationExProc(RelationAll, procInfoTotal, &length))
	  break;
	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	  return -1;
        tmpprocInfoTotal = realloc(procInfoTotal, length);
	if (!tmpprocInfoTotal) {
	  free(procInfoTotal);
	  goto out;
	}
	procInfoTotal = tmpprocInfoTotal;
      }

      for (procInfo = procInfoTotal;
	   (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
	   procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
        unsigned num, i;
        unsigned efficiency_class = 0;
        GROUP_AFFINITY *GroupMask;

        /* Ignore unknown caches */
	if (procInfo->Relationship == RelationCache
		&& procInfo->Cache.Type != CacheUnified
		&& procInfo->Cache.Type != CacheData
		&& procInfo->Cache.Type != CacheInstruction)
	  continue;

	id = HWLOC_UNKNOWN_INDEX;
	switch (procInfo->Relationship) {
	  case RelationNumaNode:
	    type = HWLOC_OBJ_NUMANODE;
            /* Starting with Windows 11 and Server 2022, the GroupCount field is valid and >=1
             * and we may read GroupMasks[]. Older releases have GroupCount==0 and we must read GroupMask.
             */
            if (procInfo->NumaNode.GroupCount) {
              num = procInfo->NumaNode.GroupCount;
              GroupMask = procInfo->NumaNode.GroupMasks;
            } else {
              num = 1;
              GroupMask = &procInfo->NumaNode.GroupMask;
            }
	    id = procInfo->NumaNode.NodeNumber;
	    gotnuma++;
	    if (id > max_numanode_index)
	      max_numanode_index = id;
	    break;
	  case RelationProcessorPackage:
	    type = HWLOC_OBJ_PACKAGE;
            num = procInfo->Processor.GroupCount;
            GroupMask = procInfo->Processor.GroupMask;
	    break;
	  case RelationCache:
	    type = (procInfo->Cache.Type == CacheInstruction ? HWLOC_OBJ_L1ICACHE : HWLOC_OBJ_L1CACHE) + procInfo->Cache.Level - 1;
            /* GroupCount added approximately with NumaNode.GroupCount above */
            if (procInfo->Cache.GroupCount) {
              num = procInfo->Cache.GroupCount;
              GroupMask = procInfo->Cache.GroupMasks;
            } else {
              num = 1;
              GroupMask = &procInfo->Cache.GroupMask;
            }
	    break;
	  case RelationProcessorCore:
	    type = HWLOC_OBJ_CORE;
            num = procInfo->Processor.GroupCount;
            GroupMask = procInfo->Processor.GroupMask;
            efficiency_class = procInfo->Processor.EfficiencyClass;
	    break;
	  case RelationGroup:
	    /* So strange an interface... */
	    for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
              KAFFINITY mask;
	      hwloc_bitmap_t set;

	      set = hwloc_bitmap_alloc();
	      mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
	      hwloc_debug("group %u %d cpus mask %lx\n", id,
			  procInfo->Group.GroupInfo[id].ActiveProcessorCount, mask);
	      /* KAFFINITY is ULONG_PTR */
	      hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
	      /* FIXME: what if running 32bits on a 64bits windows with 64-processor groups?
	       * ULONG_PTR is 32bits, so half the group is invisible?
	       * maybe scale id to id*8/sizeof(ULONG_PTR) so that groups are 64-PU aligned?
	       */
	      hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);

	      /* save the set of PUs so that we can create them at the end */
	      if (!groups_pu_set)
		groups_pu_set = hwloc_bitmap_alloc();
	      hwloc_bitmap_or(groups_pu_set, groups_pu_set, set);

              /* Ignore processor groups unless requested and filtered-in */
              if (keep_pgroup_objs && hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
		obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, id);
		obj->cpuset = set;
		obj->attr->group.kind = HWLOC_GROUP_KIND_WINDOWS_PROCESSOR_GROUP;
		hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx:ProcessorGroup");
	      } else
		hwloc_bitmap_free(set);
	    }
	    continue;
	  default:
	    /* Don't know how to get the mask.  */
            hwloc_debug("unknown relation %d\n", procInfo->Relationship);
	    continue;
	}

	if (!hwloc_filter_check_keep_object_type(topology, type))
	  continue;

	obj = hwloc_alloc_setup_object(topology, type, id);
        obj->cpuset = hwloc_bitmap_alloc();
        for (i = 0; i < num; i++) {
          hwloc_debug("%s#%u %d: mask %d:%lx\n", hwloc_obj_type_string(type), id, i, GroupMask[i].Group, GroupMask[i].Mask);
	  /* GROUP_AFFINITY.Mask is KAFFINITY, which is ULONG_PTR */
	  hwloc_bitmap_set_ith_ULONG_PTR(obj->cpuset, GroupMask[i].Group, GroupMask[i].Mask);
	  /* FIXME: scale id to id*8/sizeof(ULONG_PTR) as above? */
        }
	hwloc_debug_2args_bitmap("%s#%u bitmap %s\n", hwloc_obj_type_string(type), id, obj->cpuset);
	switch (type) {
        case HWLOC_OBJ_CORE: {
          if (has_efficiencyclass)
            hwloc_win_efficiency_classes_add(&eclasses, obj->cpuset, efficiency_class);
          break;
        }
	  case HWLOC_OBJ_NUMANODE:
	    {
	      ULONGLONG avail;
	      obj->nodeset = hwloc_bitmap_alloc();
	      hwloc_bitmap_set(obj->nodeset, id);
	      if ((GetNumaAvailableMemoryNodeExProc && GetNumaAvailableMemoryNodeExProc(id, &avail))
		  || (GetNumaAvailableMemoryNodeProc && GetNumaAvailableMemoryNodeProc(id, &avail))) {
	        obj->attr->numanode.local_memory = avail;
		gotnumamemory++;
	      }
	      obj->attr->numanode.page_types = malloc(2 * sizeof(*obj->attr->numanode.page_types));
	      memset(obj->attr->numanode.page_types, 0, 2 * sizeof(*obj->attr->numanode.page_types));
	      obj->attr->numanode.page_types_len = 1;
	      obj->attr->numanode.page_types[0].size = SystemInfo.dwPageSize;
```

主要负责函数，根据不同的输入，返回不同的结果，主要分为以下几步：
1. 初始化输出设备，并设置相应策略。
2. 创建或查找指定的处理器组。
3. 创建或查找指定的进程组。
4. 创建或查找指定的用户空间内存布局。
5. 根据输入设置相应的策略，例如是否启用效率分类。
6. 根据策略返回相应的信息，例如操作系统版本、进程组别等。


```cpp
#if HAVE_DECL__SC_LARGE_PAGESIZE
	      obj->attr->numanode.page_types_len++;
	      obj->attr->numanode.page_types[1].size = sysconf(_SC_LARGE_PAGESIZE);
#endif
	      break;
	    }
	  case HWLOC_OBJ_L1CACHE:
	  case HWLOC_OBJ_L2CACHE:
	  case HWLOC_OBJ_L3CACHE:
	  case HWLOC_OBJ_L4CACHE:
	  case HWLOC_OBJ_L5CACHE:
	  case HWLOC_OBJ_L1ICACHE:
	  case HWLOC_OBJ_L2ICACHE:
	  case HWLOC_OBJ_L3ICACHE:
	    obj->attr->cache.size = procInfo->Cache.CacheSize;
	    obj->attr->cache.associativity = procInfo->Cache.Associativity == CACHE_FULLY_ASSOCIATIVE ? -1 : procInfo->Cache.Associativity ;
	    obj->attr->cache.linesize = procInfo->Cache.LineSize;
	    obj->attr->cache.depth = procInfo->Cache.Level;
	    switch (procInfo->Cache.Type) {
	      case CacheUnified:
		obj->attr->cache.type = HWLOC_OBJ_CACHE_UNIFIED;
		break;
	      case CacheData:
		obj->attr->cache.type = HWLOC_OBJ_CACHE_DATA;
		break;
	      case CacheInstruction:
		obj->attr->cache.type = HWLOC_OBJ_CACHE_INSTRUCTION;
		break;
	      default:
		hwloc_free_unlinked_object(obj);
		continue;
	    }
	    break;
	  default:
	    break;
	}
	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx");
      }
      free(procInfoTotal);
  }

  topology->support.discovery->pu = 1;
  topology->support.discovery->numa = gotnuma;
  topology->support.discovery->numa_memory = gotnumamemory;

  if (groups_pu_set) {
    /* the system supports multiple Groups.
     * PU indexes may be discontiguous, especially if Groups contain less than 64 procs.
     */
    hwloc_obj_t obj;
    unsigned idx;
    hwloc_bitmap_foreach_begin(idx, groups_pu_set) {
      obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
      obj->cpuset = hwloc_bitmap_alloc();
      hwloc_bitmap_only(obj->cpuset, idx);
      hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
			      idx, obj->cpuset);
      hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:ProcessorGroup:pu");
    } hwloc_bitmap_foreach_end();
    hwloc_bitmap_free(groups_pu_set);
  } else {
    /* no processor groups */
    hwloc_obj_t obj;
    unsigned idx;
    for(idx=0; idx<32; idx++)
      if (SystemInfo.dwActiveProcessorMask & (((DWORD_PTR)1)<<idx)) {
	obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
	obj->cpuset = hwloc_bitmap_alloc();
	hwloc_bitmap_only(obj->cpuset, idx);
	hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
				idx, obj->cpuset);
	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:pu");
      }
  }

  if (has_efficiencyclass) {
    topology->support.discovery->cpukind_efficiency = 1;
    hwloc_win_efficiency_classes_register(topology, &eclasses);
  }

 out:
  if (has_efficiencyclass)
    hwloc_win_efficiency_classes_destroy(&eclasses);

  /* emulate uname instead of calling hwloc_add_uname_info() */
  hwloc_obj_add_info(topology->levels[0][0], "Backend", "Windows");
  hwloc_obj_add_info(topology->levels[0][0], "OSName", "Windows");

```

This code appears to be used to set the name of a Windows system environment variable. The variable is named "OSVersion" and has a value in the format of "Major version (e.g. 10.0)".

It appears to be using a combination of the system environment variable "MajorVersion" and "MinorVersion" to determine the version of Windows the system is running. It is also using the "BuildNumber" to determine the specific version of the Windows SDK installed on the system.

The code is using a lookup table to determine the name of the OS version based on the Major and Minor versions. It is also using a "snprintf" function to format the version string and add it to the "OSVersion" property of the topology object.


```cpp
#if defined(__CYGWIN__)
  hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "Cygwin");
#elif defined(__MINGW32__)
  hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "MinGW");
#endif

  /* see https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexa */
  if (osvi.dwMajorVersion == 10) {
    if (osvi.dwMinorVersion == 0)
      hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "10");
  } else if (osvi.dwMajorVersion == 6) {
    if (osvi.dwMinorVersion == 3)
      hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8.1"); /* or "Server 2012 R2" */
    else if (osvi.dwMinorVersion == 2)
      hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8"); /* or "Server 2012" */
    else if (osvi.dwMinorVersion == 1)
      hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "7"); /* or "Server 2008 R2" */
    else if (osvi.dwMinorVersion == 0)
      hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "Vista"); /* or "Server 2008" */
  } /* earlier versions are ignored */

  snprintf(versionstr, sizeof(versionstr), "%u.%u.%u", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
  hwloc_obj_add_info(topology->levels[0][0], "OSVersion", versionstr);

```

这段代码是一个C函数，它根据操作系统是否支持Cygwin环境来执行不同的操作。

首先，它检查是否已经定义了Cygwin环境变量。如果没有定义，它将执行系统内部函数`GetComputerName`来获取计算机名称，然后将其存储在`hostname`变量中，并获取它的长度存储在`hostname_size`变量中。

如果已经定义了Cygwin环境变量，它将执行系统内部函数`gethostname`来获取主机名称，并将其存储在`hostname`变量中，同时将获取到的主机名称长度存储在`hostname_size`变量中。

接下来，它检查`hostname`是否为有效字符串。如果是，它会执行以下操作：

1. 将`SystemInfo.wProcessorArchitecture`的值存储在`architecture`变量中。
2. 执行一个switch语句，根据当前的处理器架构来设置`architecture`的值。
3. 将设置好的`architecture`值存储在`hwloc_obj_add_info`函数中。
4. 返回0表示操作成功。


```cpp
#if !defined(__CYGWIN__)
  GetComputerName(hostname, &hostname_size);
#else
  gethostname(hostname, hostname_size);
#endif
  if (*hostname)
    hwloc_obj_add_info(topology->levels[0][0], "Hostname", hostname);

  /* convert to unix-like architecture strings */
  switch (SystemInfo.wProcessorArchitecture) {
  case 0:
    hwloc_obj_add_info(topology->levels[0][0], "Architecture", "i686");
    break;
  case 9:
    hwloc_obj_add_info(topology->levels[0][0], "Architecture", "x86_64");
    break;
  case 5:
    hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm");
    break;
  case 12:
    hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm64");
    break;
  case 6:
    hwloc_obj_add_info(topology->levels[0][0], "Architecture", "ia64");
    break;
  }

  return 0;
}

```

This code appears to be a part of a high-level allocation-based virtual memory management engine for the Windows operating system. It appears to define several functions and variables that can be used by users of the virtual memory management engine to manage memory allocation and deallocation.

functions defined in this header file include:

* `hwloc_win_set_proc_membind`: function to set the memory binding of a process to a specific memory region.
* `hwloc_win_get_proc_membind`: function to get the memory binding of a process.
* `hwloc_win_set_thisproc_membind`: function to set the memory binding of the current process to a specific memory region.
* `hwloc_win_get_thisproc_membind`: function to get the memory binding of the current process.
* `hwloc_win_set_thread_cpubind`: function to set the CPU bindings of a thread to a specific memory region.
* `hwloc_win_set_thisthread_cpubind`: function to set the CPU bindings of a thread to a specific memory region.
* `hwloc_win_set_thisthread_membind`: function to set the memory bindings of a thread to a specific memory region.
* `hwloc_win_get_thread_cpubind`: function to get the CPU bindings of a thread.
* `hwloc_win_get_thisthread_cpubind`: function to get the CPU bindings of a thread.
* `hwloc_win_get_thisthread_membind`: function to get the memory bindings of a thread.
* `hwloc_win_alloc_membind`: function to allocate memory for a specific memory region and return a handle to it.
* `hwloc_win_free_membind`: function to free memory from a specific memory region.
* `hwloc_win_get_area_memlocation`: function to get the memory location of a given memory region.

Additionally, the code defines a `hooks` structure which appears to keep track of global state, including the current processor group and the number of virtual cores.


```cpp
void
hwloc_set_windows_hooks(struct hwloc_binding_hooks *hooks,
			struct hwloc_topology_support *support)
{
  if (GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1))
    hooks->get_thisthread_last_cpu_location = hwloc_win_get_thisthread_last_cpu_location;

  if (nr_processor_groups == 1) {
    hooks->set_proc_cpubind = hwloc_win_set_proc_cpubind;
    hooks->get_proc_cpubind = hwloc_win_get_proc_cpubind;
    hooks->set_thisproc_cpubind = hwloc_win_set_thisproc_cpubind;
    hooks->get_thisproc_cpubind = hwloc_win_get_thisproc_cpubind;
    hooks->set_proc_membind = hwloc_win_set_proc_membind;
    hooks->get_proc_membind = hwloc_win_get_proc_membind;
    hooks->set_thisproc_membind = hwloc_win_set_thisproc_membind;
    hooks->get_thisproc_membind = hwloc_win_get_thisproc_membind;
  }
  if (nr_processor_groups == 1 || SetThreadGroupAffinityProc) {
    hooks->set_thread_cpubind = hwloc_win_set_thread_cpubind;
    hooks->set_thisthread_cpubind = hwloc_win_set_thisthread_cpubind;
    hooks->set_thisthread_membind = hwloc_win_set_thisthread_membind;
  }
  if (GetThreadGroupAffinityProc) {
    hooks->get_thread_cpubind = hwloc_win_get_thread_cpubind;
    hooks->get_thisthread_cpubind = hwloc_win_get_thisthread_cpubind;
    hooks->get_thisthread_membind = hwloc_win_get_thisthread_membind;
  }

  if (VirtualAllocExNumaProc) {
    hooks->alloc_membind = hwloc_win_alloc_membind;
    hooks->alloc = hwloc_win_alloc;
    hooks->free_membind = hwloc_win_free_membind;
    support->membind->bind_membind = 1;
  }

  if (QueryWorkingSetExProc && max_numanode_index <= 63 /* PSAPI_WORKING_SET_EX_BLOCK.Node is 6 bits only */)
    hooks->get_area_memlocation = hwloc_win_get_area_memlocation;
}

```



这段代码定义了两个函数，用于在hwloc_topology结构体中注册和卸载hwloc_windows_component_discovery_cb函数。通过这两个函数，可以实现hwloc_windows_component_discovery_cb函数，该函数用于通知hwloc_topology结构体组件的discovery_cb函数，以便正确地注册和卸载组件。

hwloc_windows_component_init函数用于初始化包含hwloc_windows_component_discovery_cb函数的discovery_cb指针。hwloc_windows_component_finalize函数用于在清理和卸载组件时通知hwloc_topology结构体执行的清理操作。

hwloc_windows_component_instantiate函数用于在给定的topology结构体中创建一个新的hwloc_backend实例，包含hwloc_windows_component_discovery_cb函数作为实现了组件的discovery_cb函数。

hwloc_backend_alloc函数用于在topology结构体中查找并返回一个已经创建好的backend实例。如果返回NULL，则表明发生错误，例如分配内存失败或已分配的内存已被释放。

hwloc_look_windows函数用于查找并返回与给定句柄描述相匹配的Windows函数指针。由于hwloc_windows_component_discovery_cb函数是作为已经定义好的函数指针注册到组件中，因此需要使用这个函数指针来实现组件的discovery_cb函数。


```cpp
static int hwloc_windows_component_init(unsigned long flags __hwloc_attribute_unused)
{
  hwloc_win_get_function_ptrs();
  hwloc_win_get_processor_groups();
  return 0;
}

static void hwloc_windows_component_finalize(unsigned long flags __hwloc_attribute_unused)
{
  hwloc_win_free_processor_groups();
}

static struct hwloc_backend *
hwloc_windows_component_instantiate(struct hwloc_topology *topology,
				    struct hwloc_disc_component *component,
				    unsigned excluded_phases __hwloc_attribute_unused,
				    const void *_data1 __hwloc_attribute_unused,
				    const void *_data2 __hwloc_attribute_unused,
				    const void *_data3 __hwloc_attribute_unused)
{
  struct hwloc_backend *backend;
  backend = hwloc_backend_alloc(topology, component);
  if (!backend)
    return NULL;
  backend->discover = hwloc_look_windows;
  return backend;
}

```

这段代码定义了一个 `hwloc_disc_component` 结构体，表示硬件设备的输入输出。

`hwloc_windows_disc_component` 结构体中包含以下成员：

- `"windows"`：表示设备的名称，这里使用了字符串常量。
- `HWLOC_DISC_PHASE_CPU`：表示设备的控制器和CPU插件的 phases。这里使用了 `HWLOC_DISC_PHASE_` 宏，用于将 `CPU` 类型指定为 `HWLOC_DISC_PHASE_CPU`。
- `HWLOC_DISC_PHASE_GLOBAL`：表示设备的国际全局 phases。同样使用了 `HWLOC_DISC_PHASE_` 宏。
- `hwloc_windows_component_instantiate`：函数，用于创建并初始化 `HWLOC_DISC_PHASE_CPU` 类型的设备。
- `50`：表示设备的基础频率，即奇数。
- `1`：表示设备的最大频率，即偶数。
- `NULL`：表示设备的数据，这里通常存储设备的状态、缓冲区等数据。

该 `hwloc_disc_component` 结构体定义了一种在 `hwloc` 配置中使用的硬件设备类型。该类型使用 `HWLOC_DISC_PHASE_CPU` 和 `HWLOC_DISC_PHASE_GLOBAL` 作为设备的控制器和CPU插件的 phases。通过调用 `hwloc_windows_component_instantiate` 函数，可以创建并配置这种设备。最后，将配置好的设备数据存储在 `hwloc_disc_component` 结构体中，以便在 `hwloc` 配置中使用。


```cpp
static struct hwloc_disc_component hwloc_windows_disc_component = {
  "windows",
  HWLOC_DISC_PHASE_CPU,
  HWLOC_DISC_PHASE_GLOBAL,
  hwloc_windows_component_instantiate,
  50,
  1,
  NULL
};

const struct hwloc_component hwloc_windows_component = {
  HWLOC_COMPONENT_ABI,
  hwloc_windows_component_init, hwloc_windows_component_finalize,
  HWLOC_COMPONENT_TYPE_DISC,
  0,
  &hwloc_windows_disc_component
};

```

这段代码是一个名为 `hwloc_fallback_nbprocessors` 的函数，属于 `hwloc` 库。它的作用是处理操作系统在 `hwloc` 库中设置的 `unsigned flags` 标志，如果没有设置该标志，则不做任何处理，否则返回 `hwloc_f和法律` 的 `nbprocessors` 属性的值。

函数的实现包括以下步骤：

1. 初始化函数参数 `n` 和 `sysinfo`。
2. 调用 `GetSystemInfo` 函数，获取当前系统的信息 `sysinfo`，并将其保存到 `n` 的初始值中。
3. 如果当前系统支持 `hwloc_f和法律`，则执行以下操作：
  1. 如果 `GetActiveProcessorCountProc` 函数返回非零值，则执行以下操作：
     1. 如果 `nr_processor_groups` 大于 1，则执行以下操作：
       1. 如果 `GetActiveProcessorCountProc` 函数返回非零值，则执行以下操作：
         1. 计算 `MAXIMUM_PROC_PER_GROUP`，并将其乘以 `(nr_processor_groups-1)`，然后加上 `GetActiveProcessorCountProc` 返回的值，得到 `n` 的初始值。
         2. 否则，计算 `MAXIMUM_PROC_PER_GROUP`，并将其乘以 `nr_processor_groups`，得到 `n` 的初始值。
       2. 否则，执行以下操作：
         1. 计算 `MAXIMUM_PROC_PER_GROUP`，并将其乘以 `nr_processor_groups`，得到 `n` 的初始值。
         2. `n` 的初始值就是 `MAXIMUM_PROC_PER_GROUP*nr_processor_groups`。
       3. 如果没有执行以上操作，执行以下操作：
         1. 返回 `hwloc_f和法律` 的 `nbprocessors` 属性的值。
         2. 如果没有设置 `unsigned flags` 标志，不做任何处理，返回 `n` 的初始值。
3. 如果当前系统不支持 `hwloc_f和法律`，则执行以下操作：
  1. 返回 `hwloc_f和法律` 的 `nbprocessors` 属性的值。
  2. 如果没有设置 `unsigned flags` 标志，不做任何处理，返回 `n` 的初始值。


```cpp
int
hwloc_fallback_nbprocessors(unsigned flags __hwloc_attribute_unused) {
  int n;
  SYSTEM_INFO sysinfo;

  /* TODO handle flags & HWLOC_FALLBACK_NBPROCESSORS_INCLUDE_OFFLINE */

  /* by default, ignore groups (return only the number in the current group) */
  GetSystemInfo(&sysinfo);
  n = sysinfo.dwNumberOfProcessors; /* FIXME could be non-contigous, rather return a mask from dwActiveProcessorMask? */

  if (nr_processor_groups > 1) {
    /* assume n-1 groups are complete, since that's how we store things in cpusets */
    if (GetActiveProcessorCountProc)
      n = MAXIMUM_PROC_PER_GROUP*(nr_processor_groups-1)
	+ GetActiveProcessorCountProc((WORD)nr_processor_groups-1);
    else
      n = MAXIMUM_PROC_PER_GROUP*nr_processor_groups;
  }

  return n;
}

```

这段代码定义了一个名为 `hwloc_fallback_memsize` 的函数，其作用是返回一个 `int64_t` 类型的值。函数的具体实现如下：

```cppc
int64_t hwloc_fallback_memsize(void) {
 /* Unused */
 return -1;
}
```

从代码中可以看出，该函数没有函数体，也没有返回类型，因此它的作用是空的，任何调用该函数都不会产生任何影响。该函数的作用仅限于声明，不会对程序的运行产生任何实际的输出或结果。


```cpp
int64_t
hwloc_fallback_memsize(void) {
  /* Unused */
  return -1;
}

```